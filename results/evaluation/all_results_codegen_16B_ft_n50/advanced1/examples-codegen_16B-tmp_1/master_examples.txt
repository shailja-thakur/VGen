example-0: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = a[7] + b[7] + (s[7] & (a[7] ^ b[7]));
assign s = a + b; 


================================================================
example-1: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 wire carry_out_overflow;
 wire overflow_reflect;

 register_with_clock_divider C9 (b[7], a[7], carry_out, overflow, b[7], a[7], 1, 7);

 // negate or reflect the overflow output to give the total signed adder output or purpose to give the output of an unsigned operator.
 assign overflow_reflect = (overflow == 1) ? ~overflow : 1'bz;
 assign s[7] = (overflow_reflect == 1) ? overflow_reflect : overflow;
 assign s[6] = (overflow == 1) ? overflow : carry_out;
 assign s[5] = (overflow_reflect == 1) ? overflow_reflect : carry_out;
 assign s[4] = (overflow == 1) ? overflow : carry_out_reflect_lower[7];
 assign s[3] =
================================================================
example-2: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


reg [6:0] carry_out = 0;	
wire [7:0] sum = a + b;	// sum bf the result

assign s[7:0] = sum[7:0];	// assign the most significant bits of sum to output s;

assign overflow = 2031 & (~carry_out[6] + carry_out[5] + carry_out[4] + carry_out[3]); // (&b) so that the bit operation is only performed if the carry_out is 0.
// (*4) so all assigned bit operations occur over four cycles starting from the next positive clock edge.



always @(*)
	begin
	if 	(carry_out == 0 & gain_out < gain_min)
	begin
	// gain is too small --> disallow input
	overflow <= 1; 
	s[7
================================================================
example-3: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((a[7]==0 && b[7]==0 && s[7] == 1) || 
	(a[7] == 1 && b[7] == 1 && s[7] == 0) ||
	(a[7] == 1 && b[7] == 0 && s[7] == 1) || 
	(a[7] == 0 && b[7] == 1 && s[7] == 0)) ? 1'b1: 1'b0;
// A signed overflow occurs if the most significant bit of the sum is a one, 
// and the highest non-zero occurence of a or b is a one.
/// Ex. 
//a = 10011
//b = 10011
//s = 10101

// Otherwise, the adder does not overflow
//IF the MSB of the result is a one,
================================================================
example-4: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s [7:0], a + b; 
assign overflow, s [7] ^ a [7] ^ b [7]; // The output overflow is given by the logical XNOR between the most significant bit of a, b and s 


================================================================
example-5: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



//Define the function of a signed adder
function ssigned_adder_37;
input [7:0] a
input [7:0] b;
output [7:0] s;
reg [8:0] result;
output overflow;
reg ov;
assign overflow = ov;

always @ (*)
begin

result = a + b; // perform the addition to get the significand and exponent values
legit_to_s_s(result); // convert to s-representation and the correct output format

if (a[7] == 1'b0 && b[7] == 1'b0)
begin
	assign s = result[7:0]; // assign the output to s if both inputs are 0
	ov = 0; // set overflow to zero
end

if (a[7] == 1'b1 && b
================================================================
example-6: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s [i]=a[i]+b[i]; // s is 8-bit 1=add_min, 1=add_min
assign overflow[i]=(a[i]==1'b0 & b[i]==1'b0 & s[i]==1'b1)| // if one of the two inputs is Zero, 
 it overflows if it adds to '1'
it overflows if a input '1' and b input is '0' and s is '1'



================================================================
example-7: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign s = a + b;
assign overflow = ({a[7],a[7]} == 1 && {b[7],b[7]} == 1 && s[8] == 0) || ({b[7],b[7]} == 1 && s[8] == 0) ||
({a[7],a[7]} == 1 && {b[7],b[7]} == 1 && s[8] == 1) ? 1'b1 : 1'b0; // // The unsigned addition is less than {N-1, N-1} in magnitude. If the binary sum GTE the most significant bit of {N-1, N-1} then s must be >N-1.



================================================================
example-8: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign s= a + b;
	

	 // if a is a positive number then subtract a
	 // with a negative b.
	assign overflow = ((a[6] == 1'b0) && (b[7] == 1'b1)) || 	 // check for signed overflow: Either A is a positive number or B is a negative number
	
	((a[6] == 1'b1) && (b[7] == 1'b0)) ||
	
	 (overflow == 1'b0) ? overflow : 1'b1;



================================================================
example-9: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s[7]=a[7]^b[7]^s[7];

always@(a,b,s)
begin
case({a,b})
4'b0010:s<=s-1;
4'b0011:s<=s+1;
default:s=a+b;
endcase
end
assign overflow=(((a[7]+b[7]-'b1)^(a[7]-'b1)'))'b1;
// create an overflow signal if the most significant bit of sum s is 0 or 1 then the variable overflows is are true, overwritting the least significant bit of overflow with 1. 
 //when the most significant bit of a and b are high,if the most significant bit of s is tright,then the variable overflows becomes true andthe least significant bit of overflow overwrite with 1.



================================================================
example-10: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	 XOR_MUX_0 aor0( w3,a, b);
	 shift b_2signif( w2, a);
	 XOR_MUX_1 aor1( s, w2, w3);
	 
	 XOR_MUX_2 af( w1, a, b);
	 XOR_MUX_3 aor2( overflow, w1,w2 ); 


================================================================
example-11: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0] sig_add;
wire [4:0] out_sig_add;

assign out_sig_add = { a[0] | b[0], out_sig_add_2[4] };

wire out_carry = a[0] & b[0] | a[0] & out_sig_add_2[0] | b[0] & out_sig_add_2[0];

// assigns overflow based on MostSigBits of current adder
// assigns overflow based on flipping the most significant bit
assign overflow = (~a[7] & out_carry)|(~a[7] & ~b[7] & out_sig_add[7]);


assign sig_add = a + b;

assign s = sig_add[7:0];
================================================================
example-12: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign overflow = ((a[7] == 0) & (b[7] == 0) & (s[7] != 0)) | // aNorb if the sign bit in S goes high first, then it signed overflows out.
	((a[7] == 1) & (b[7] == 1) & (s[7] == 0)) | // aB8orB8 if the sign bit in S goes low, then it is overflowed out.
	((a[7] == 1) & (b[7] == 0) & (s[7] == 1)); // aB8orAnOrB8 if the sign bit in S is flipped from what is being added, then the overflow is occuring.

// If the most significant bits of a and b are zero, then the sign bit of s must be one for a signed overflow to occur. 
// yet, if
================================================================
example-13: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = (a[7] == b[7] && a[7] == ~s[7]) ? {a[7:0],1'b0}:
(a[6] == b[6] && (a[7:0] > b[7:0])) ? s[~7:0] + 8'h01:
(a[6] == b[6] && (a[7:0] < b[7:0])) ? s[~7:0] + 8'h81:
(a[5] == b[5] && (a[6:0] > b[6:0])) ? s[~6:0] + 8'h02:
(a[5] == b[5] && (a[6:0] < b[6:0])) ? s[~6:0] + 8'
================================================================
example-14: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = (a[7] == b[7] && a[7] != s[7])?1'b1:1'b0;


================================================================
example-15: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	always @ (a, b) begin
	
// Stage 1

	// Subtract b from a. A is the original adder input value and B is the subtraction of that from what is already on s.

	assign A1 = a[0] ^ b[0]; //learned
	assign B1 = a[0] & b[0];
	assign C1 = a[1] & b[1];
	assign D1 = a[1] ^ b[1];

// Stage 2

	assign E1 = C1 ^ D1;
	assign F1 = C1 & D1;
	assign G1 = A1 & E1;
	assign H1 = A1 ^ E1;

// Stage 3

	// Left-shift A: |A|88307 -> left 7 places. (10000000 -> assign
================================================================
example-16: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = ((a[7]==1) && (b[7]==0) && (s[7]==0)) || ((a[7]==0) && (b[7]==1) && (s[7]==1)); 


================================================================
example-17: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign s [7:0] = a [7:0] + b [7:0];
	assign overflow [7:0] = (a [7] == 1 && b [7] == 1 && s[7] == 0) || (a [7] == 0 && b [7] == 0 && s[7] == 1);


================================================================
example-18: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// Look at Drop A description and code. Make changes as described in the statement.

assign s = (b & 8'h0F) + (a & 8'h07); 

assign overflow = (a[7] == b[7]) && ~a[7] & (s[7] == 1'b1);


================================================================
example-19: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



 //uses the does zig cfg style

assign overflow = (~a[7] & ~b[7] & s[7]) | (~a[7] & b[7] & ~s[7]) | (~b[7] & a[7] & ~s[7]) | (a[7] & b[7] & ~s[7]); 




================================================================
example-20: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 always@(a or b or s) begin

assign overflow=(a[7]==0 & b[7]==0 & s[7]==1) | (a[7]==1 & b[7]==1 & s[7]==0);
assign s[7]=a[7] ^ b[7];
assign s[6:0]=a[6:0] +b[6:0];


================================================================
example-21: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = ~(a[7]&b[7] | a[7]&s[7] | ~a[7]&~b[7]&s[7]) & (a[7]^b[7] | a[7]&s[7] | ~a[7]&~b[7]&~s[7]);


================================================================
example-22: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((a[7] == b[7]) && (a[7] != s[7])) ||
((a[7] != b[7]) && (a[7] != s[7]) && (b[7] != s[7]));
// Add two 8-bit two's complement numbers and then convert the final result to two's complement 


assign s = a + b; // Add the two numbers
assign s[7] = ^s[7]; // If the most significant bit (MSB) of the output number is a 1, flip it (a.k.a, change to 2's complement)
/* If any of the above described events occur, then overflow needs to be a non-zero number */



================================================================
example-23: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 /*
 * check that if most significant a and b are low, and most significant bit s is high, there should be an overflow.
 * check if most significant a and b are high, and most significant bit s is low, there should not be an overflow.
*/
 wire temp0, temp1;
 xor(temp0, a[5], b[5]);

 assign temp1 = a[5] & b[5];

 xor(s[0], temp0, temp1);

// if a[5] and b[5] are low, then the sum is either the new value of a[0] or b[0], or else it is a high output
 assign s[1] = a[1] & b[1];	 
 assign s[2] = a[2] & b[2];

 wire s_0, s_1;
 adder(a[0
================================================================
example-24: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = (({a[7], a[7]} == 1) && ({b[7], b[7]} == 1) && ({s[7], s[7]} == 0)) ||
	(({a[7], a[7]} == 0) && ({b[7], b[7]} == 0) && ({s[7], s[7]} == 1));


================================================================
example-25: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b; // perform an unsigned add and then Test the most significant bit of s to determine if a signed overflow has occured. 

assign overflow = ((a[7] == b[7]) && (a[7] != s[7]))?1'b1:1'b0;


================================================================
example-26: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign {s,of} = a+b;


================================================================
example-27: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


always @(a,b,s)
begin

assign overflow = (s[8] == 1'b1 && (~a[7] || ~b[7]) && (a[7] != s[7]) && (b[7] != s[7])) ||(~(a[7] ^ b[7]) && s[7])!=1'b1; 

assign s = (a + b);

end

================================================================
example-28: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = (~a[7])&(~b[7]) & (~s[7]) | (~a[7])&(b[7]) & (~s[7] | (~a[7]) & (~b[7]) & (~s[7]) );

// Add the second 8-bit numbers a and b respectively to the unsigned 8-bit number s
xor (s[0],b[0],a[0]);
xor (s[1],b[1],a[1]);
xor (s[2],b[2],a[2]);
xor (s[3],b[3],a[3]);
xor (s[4],b[5],a[5]);
assign xor1 = b[5]^a[6];
assign xor2 = b[6]^a[7];
xor (s[
================================================================
example-29: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	wire low_a, low_b, low_s;
	wire [7:0] bpos_a, bpos_b;
	assign bpos_a = (a[7]) ? ~a + 1 : a;
	assign bpos_b = (b[7]) ? ~b + 1 : b;
	assign low_a = !(a[7] || b[7]);
	assign low_b = !(b[7] || a[7]);
	assign low_s = !(s[7] || low_a || low_b);
	assign overflow = s[7] ^ low_s;
	// must test for overflow signficantly (greater than >> overflow bits) based on
	// the widths of the operands
	assign s = (low_a && low_b) ? ((
================================================================
example-30: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 wire signed [8:0] sum; // temporary sum wire

 assign sum[7:0] = a[7:0] + b[7:0];
 assign sum[8] = a[8] & b[8]; 
 assign s[7:0] = sum[7:0];
 assign s[8] = (a[8] & ~b[8] & sum[8]) | (a[8] & b[8] & ~sum[8]) | (!a[8] & b[8] & sum[8]);

 //assign overflow = sum[8];
 //assign overflow = (a[8] & ~b[7]) | (a[8] & b[7] & !sum[7]) | (!a[8] & b[8] & sum[7]);
 //assign overflow = temp_1 + temp_2;
 assign overflow
================================================================
example-31: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire not_a_and_b;
wire nor_overflow;
wire ab0_out_and;
wire ab0_out_or;
wire ab0_out_or_in;
assign or_overflow = (nor_overflow | ab0_out_and) | ab0_out_or_in;


assign s = b << 1; // therefore s for the first bit will be the output
assign not_a_and_b = ~a & b; // logic statement for inverting a and b, -Logic the two numbers all together
assign s0_out = s[0]; //assing the sentence b << 1 to variable s0_out. b << 1 = 2x1 vector which then it treated as the input for s[0]

//Using a variable to store the a & b with respect to bit[0] operation



================================================================
example-32: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = s[8];


================================================================
example-33: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign {overflow,s} = a + b;



================================================================
example-34: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	wire flag_in_most_sig_mul;	
	wire [3:0] unsigned_sum4,unsigned_sum3,unsigned_sum2,unsigned_sum1,unsigned_sum;
	wire signed_overflow_most_sig_mul;
	wire signed_overflow1,signed_overflow2,signed_overflow3,signed_overflow4;
//add all bits of a with flipped most sig bit of b to sum
	assign unsigned_sum4 = (b[7]?~a[7:0] + 1'b1:a[6:0]) + (b[6]?~a[7:0] + 1'b1:a[5:0])+ (b[5]?~a[7:0] + 1'b1:a[4:0])+ (b[4]?~
================================================================
example-35: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	wire [7:0] carry;
	assign carry[0] = a[0] ^ b[0];
	
	assign s[0] = a[0] ^ b[0];
	assign s[1] = a[1] ^ b[1] ^ carry[0];
	assign s[2] = a[2] ^ b[2] ^ carry[1];
	assign s[3] = a[3] ^ b[3] ^ carry[2];
	assign s[4] = a[4] ^ b[4] ^ carry[3];
	assign s[5] = a[5] ^ b[5] ^ carry[4];
	assign s[6] = a[6] ^ b[6] ^ carry[5];
	assign s[7] = a[7] ^ b
================================================================
example-36: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign overflow = (~a[7] & b[7] & ~s[7]) | (~a[7] & b[7] & s[7]) | (a[7] & ~b[7] & s[7]);


// Design an 8-x1 mux with signed select.
// When you select a negative number, a positive number is output.
// When you select a positive number, a negative number is output.

module mux
(
	input select,
	input [7:0] input_to_mux,
	output reg [7:0] output_of_mux
);
always @* 
	begin 
	case(select)
	0: // Positive number selected
	begin
	output_of_mux <= input_to_mux;
	end
	1: // Negative number is selected
	begin
================================================================
example-37: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


always @ (a or b or s)
begin // begin always block1
	
end // end always block1


assign s = a + b;

assign overflow = (a[7] == 1 && b[7] == 1 && s[7] == 0) || (a[7] == 0 && b[7] == 0 && s[7] == 1);


================================================================
example-38: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 wire overflow_wire, complement_of_a, sign_of_b;
 wire [7:0] lost_bits, unmasked_b, bp_extended, b_complement;
wire [7:0] a_sub_b, b_sub_a, a_or_b, a_and_b;
assign sign_of_b = b[7];
assign override_complement_of_a = (a[7] == 0);
assign complement_of_a = (override_complement_of_a == 1) ? ~a[7] : a[7];
assign sign_of_a = (override_complement_of_a == 1) ? ~a[7] : a[7];
assign sign_of_b_complement = ~b[7];

assign lost_bits =
================================================================
example-39: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


always @(*) begin
 if ({a[7], b[7]} == 1'b1) begin
 // case for performance optimizations
 // a and b are 0 when only one of them is signed and the output should be 0
 if ({s[7], s[6], s[5]} == 3'b0_0) s = 8'b0;
 // a and b are both signed
 else begin // {a[7], b[7]} == 1'b0
 // a and b are both positive
 if ({s[7], s[6], s[5]} == 3'b0_0) s = s + a;
 // a is negative and b is pos
 else if ({s[7], s[6], s[5]} == 3'b0_1) s = a - b;
 // a is positive and b is neg
 else if ({s[7], s
================================================================
example-40: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	xor(overflow, a[7], b[7]);
	xor(s[0], a[0], b[0]);
	xor(s[1], a[1], b[1]);
	xor(s[2], a[2], b[2]);
	xor(s[3], a[3], b[3]);
	xor(s[4], a[4], b[4]);
	xor(s[5], a[5], b[5]);
	xor(s[6], a[6], b[6]);
	xor(s[7], a[7], b[7]);


================================================================
example-41: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign x = a[7:0];
assign y = b[7:0];

 
always @ (x or y or s)
begin
xor(s_temp, x, y);

and(s_temp0, x, y);


and(s_temp1, x, s);
xor(s_temp0Or1, s_temp, s);

or(overflow, s_temp1, s_temp0);

end


================================================================
example-42: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b; 
assign overflow = (~a[s] & b[s]) | (b[s] & ~a[s]);



================================================================
example-43: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = a[7] ^ b[7] ^ s[7];

assign s[7:0] = (((a[7] & b[7]) & (a[7] ^ b[7]) & s[7]) | ((~(a[7] & b[7]) & ~(a[0] & b[0])) & s[7]));


================================================================
example-44: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire sum_a_gt_b;
wire sum_a_lt_b;

wire sum_gt_max;
wire sum_lt_min;

assign sum_a_gt_b = ({a[7],b[7]}) > ({b[6:0], a[6:0]}); // found any number that exceeds the range of a and b

assign sum_a_lt_b = ({a[7],b[7]}) < ({b[6:0], a[6:0]}); // found any number less than the range of a and b

assign sum_gt_max = ({a[7],b[7]}>{a[6],b[6]}) && !sum_a_lt_b;

assign sum_lt_min = ({a[7],b[7]} < {a[6],
================================================================
example-45: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Program starts from here - David A. Casey

assign overflow = (a[7] == b[7]) ? ~( | a[7:0])&(|b[7:0]) + ~(|s[7:0]):a[7]&b[7]&(|s[6:0]) + (a[7]&~b[7])&s[7];
always @ (**)
begin
	for (i = 8'h0; i <= 8'h0; i = i+1'b1)
	begin
	
	end
end



================================================================
example-46: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


//assign s[7] = a[7] ^ b[7] ^ s[7]; //this will check if any of the most significant 4 bits are 1 and if any of the 1 val we kept track of in previous frames we set flag high only in that case

always @(s, a, b)
begin
	case(s[7])
	1'b0: if(a[7])overflow = 1'b1;
	1'b1: if(b[7])overflow = 1'b1; //to check for signed overflow.
	endcase	
end


================================================================
example-47: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// assign the overflow field to zero if there is no overflow or to the output of the adder otherwise
assign overflow = (a[7] == b[7])?(a[7] ^ s[7]):(~(a[7]) ^ b[7]); 


// adder with result
adder a1(a[0], b[0], s[0], ci);
adder a2(a[1], b[1], s[1], c[0]);
adder a3(a[2], b[2], s[2], c[1]);
adder a4(a[3], b[3], s[3], c[2]);
adder a5(a[4], b[4], s[4], c[3]);
adder a6(a[5], b[5], s[5], c[4]);
adder a7(
================================================================
example-48: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = (overflow) ? a + b : (a + b);
assign overflow = ((a[7] == 0) && (b[7] == 1)) 

//assigning s output values to this array may hinder the correct operation of the adder having a bus width of 8 bits and 
//however it reduces the space complexity of this code by ~8 - from ~9
//assign s[7] = (overflow) ? 1 : 0;
//assign overflow = (overflow) ? 1 : 0;
//If you want to see the math used to develop this code graphically uncomment this line

// The full program statement is a basic simulation program, which is described in the lab report. 

// Edits may be needed.

// Please Note: The assignment statements within the claer blockTAGE may not (as of yet) compile or perform
================================================================
example-49: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign overflow = ((a[7] == 1'b0 && b[7] == 1'b0 && s[7] == 1'b1) || // addition of two negative numbers
	(a[7] == 1'b1 && b[7] == 1'b1 && s[7] == 1'b0)) // subtraction of two negative numbers
	? 1'b1 : 1'b0;


================================================================
