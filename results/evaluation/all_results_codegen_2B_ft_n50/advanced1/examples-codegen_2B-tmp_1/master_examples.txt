example-0: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign {overflow,s} = a+b;


================================================================
example-1: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// add two 8-bit numbers auronously, without using the Verilog '+' operator
wire intermediate_carry;
always_comb
(
	.a[7],
	.b[7], 
	.sum[7],
	.intermediate_carry
);

================================================================
example-2: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


//Assuming both a and b are of equal length both initial bits should be equal. But if one is wider than the other, 
//the extra bit is still be added. So if a is 8 bits and b is 9 bits, the 9th bit will follow the 8th relative to addition.

//A one vector should be accessed as [7:0]a[i]where i is the index as explained above.

//The number are signed negativs

//For the addition of signed numbers the operator * should be used where the last operand is the sign of the sum, as in a += b*n where n is the negative of b (-5).
module signed_adder(input [7:0] a,
 morninginput [7:0] b,
 glanced input [7:0] c,
 launched input [7:0] d,
 ten input [7:0] e,
================================================================
example-3: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 assign overflow = ({8{a[7]&b[7]}} == 1'b1 & {1'b1,a[7:0]} == {1'b1,b[7:0]});
 
 always@(*) begin
s[7:0] = {~overflow,a[7:0]}+{~overflow,b[7:0]};
 end; 

================================================================
example-4: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Create bus equations.
// Create ten terms and connect them to mux wires.

wire carry1,carry2,carry3,carry4,carry5,carry6,carry7,carry8,carry9,n1;
wire sum_low,sum_high,ov;

// 2's complement terms from -128 to +127
assign carry1 = ~b[1]+1'b1; // ~B[1] is and not; +1 converts 1->1; -1 converts 0->-1
assign carry2 = ~b[2]+1'b1;
assign carry3 = ~b[3]+1'b1;
assign carry4 = ~b[4]+1'b1;
assign carry5 = ~b[5]+1'b1;
assign carry6 = ~b[6]+1'b1;
assign
================================================================
example-5: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


reg signed [7:0] octect;

always @*
begin
fulfiller = 1'b0;
end

always @* 
begin
od = octect;
end

always @* 
begin 
if (a[7] == 1'b1 && b[7] == 1'b0) 
octect = - a + b;

else if (a[7] == 1'b0 && b[7] == 1'b1)
octect = a + - b; 

else if (a[7] == 1'b0 && b[7] == 1'b0)
octect = 8'b00000000; 

else if (a[7] == 1'b1 && b[7] == 1'b1)
octect = 8'bxxxxxxxx;

end


always @*
================================================================
example-6: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = (a[7] & ~b[7]) | ( (a[7] & b[7]) & ~|a[7:0] + 1'i)| ((b[7] & a[7]) & ~|b[7:0] + 1'i);
//Sandoval Alvarado

================================================================
example-7: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0]b_with_sign_extend; 
wire overflow;
assign b_with_sign_extend=(b[7])?(8{1'b1}):b;
wire overflow_temp1; 
wire overflow_temp2; 
wire s_extended;

signed_add_sub_pipe b_type1(.b({8{1'b0}}), b_with_sign_extend, .y(b_with_sign_extend), .sign_overflow_out(), .s_which_overflow(), .y_type());	// Changing signs

wire [7:0]new_input;
wire new_carry_in;
wire new_overflow_out;
wire [7:0]new_s;
//[8:0]x_temp = @(a, b);
================================================================
example-8: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


localparam zero = 8'b0;

assign {out[7] , out[6] , out[5] , out[4] , out[3] , out[2] , out[1] , out[0]} = 
(a[7] ^ b[7] ^ 1'b0) ? 8'bX :

(a[6] ^ b[6] ^ 1'b0) ? {1'b1, a[6] ^ b[6], a[6] , a[5] , a[4] , a[3] , a[2] , a[1] , a[0]}:
(b[6] ^ 1'b0) ? {1'b1, b[6], b[6], b[5], b[4], b[3], b[2], b[1], b[0]}:
================================================================
example-9: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


always @(a or b)
begin
//adder cases
case ({a}) {0b0000_0000:{b}:{1'b0},
1b0000_0000:{b}:{1'b0},
2{b}:{b}:{1'b0},
3{b}:{b}:{1'b0},
4{b}:{b}:{1'b0},
5{b}:{b}:{1'b0},
6{b}:{b}:{1'b0},
7{b}:{b}:{1'b0},
8{b}:{b}:{1'b0},
9{b}:{b}:{1'b0}}
endcase
assign s = a + b;
assign overflow = (a[7] == b[7] && a[7] != s[7]) ? 1
================================================================
example-10: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Negative values meet all tests and greater than 8's compliment, they will saturate
// Nor negative values in the positive range will be given these tests.


// a<b starts in 2. 
// 1). precision of negative numbers greater that the precision of the adder can be reached by 
// adding == unsigned numbers bigger than eight bits or when a=0
// 2). (b>a) never occurs. 
// 2-(b>a) will become sums of values in 1 until values equal. (values saturate as owerflow = 0 because start there is arithmetic always non bug)
// 3). signed overflow will be a legal result

// DONE


// The result of the addition is placed in the sum, unless there was a underflow resulting in a 0. 
// in this case a ValueError exception is raised (divide by zero is potentially happening).


// sometimes, the sum
================================================================
example-11: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign {overflow_1, overflow_0} = a + b;
assign {s_1[7:0], s_0[7:0]} = a[7:0] + b[7:0] + (({overflow_1, overflow_0}[7] >>1) == 1'b1) ? {1'b1, {7{~overflow_1}} } : overflow_1;



================================================================
example-12: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign overflow = a[8] ^ b[8] & s[8];


================================================================
example-13: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


 // when only using $signed the negative sign is prepended in each line 
 
 // when using $unsigned the sign of the number is retained

assign zero = {{8{1'b0}}, {8{1'b0}}};

always @ (a or b or zero)
begin : signed_adder_process
case (a[7])
1'b0 :
begin
s <= a + b + zero;
end
1'b1 :
begin
s <= a - b - zero;
end
endcase
end

always @(*)
begin
	 // separate assignment statements allow variable use
overflow = (((&a + 1'b1) ^ (&a + 1'b1'b1)) & (&b + 1'b1) & (&b + 1'b1'b1) ) & zero;
end


================================================================
example-14: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [8:0] sum_b;
wire carry_over_b;

wire [9:0] sum_ab;
wire carry_over_ab;

wire carry_out;

bit_full_adder b0 (a[0],b[0],1'b0,sum_b[0],carry_over_b);
bit_full_adder b1 (a[1],b[1],carry_over_b,sum_b[1],carry_over_b);
bit_full_adder b2 (a[2],b[2],carry_over_b,sum_b[2],carry_over_b);
bit_full_adder b3 (a[3],b[3],carry_over_b,sum_b[3],carry_over_b);
bit_full_adder b4 (a[4],b
================================================================
example-15: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((a[7] & b[7]) & (~s[7]) & (~|s[7:0])) | ((~a[7] & ~b[7]) & s[7] & (~|s[7:0]));

// Implemented with a full adder 
 

// extend the width of the inputs to 8 to reach the most significat bits 
assign {1'b0,gnd} = {a[6:0],1'b0}; 
assign e_and_ce_b = {gnd, b[6:0]};

// cases section fpga4student.com FPGA projects, VHDL projects, Verilog projects 


================================================================
example-16: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((a[7]==1'b1)&b[7]&(a[7]^b[7])&~s[7])|((a[7]&b[7])&~a[7]&b[7]&(s[7]^~s[7]));
// A simple conversion nibble adder works as adder in all blades. (s, bus)
generate 
genvar num1;
generate
for(num1=0;num1<8;num1++)
begin
add add_temp(.a(a[num1]), .b(a[num1]), .y(s[num1]), .penultch(one[num1]));
end
endgenerate
endgenerate 
// The input 0s are extra to enable negative numbers. 
// Remember itâ€™s enough
================================================================
example-17: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	// The addition operation is only partially vectorizable
	// Just the necessary adders of a, b, and s are implemented. 
	// The variable s is a completely different part of the module.

	// Sum output (s):
	// The addition operation is done on 2's complement numbers,
	// i.e. the adder adds exactly 1 base-e signed number. (e.g. 1 + 0)
	// Perform signed sum.
	// Credits:Christian Sachsse

// find the width for which all input bits cancel
	// in the adder output
	wire [7:0] 	temp_sum;	
	wire 	[7:0]	cancel_sum;
	and 	(cancel_sum[7],a[7],b[7],0,0);
	and 	(cancel_sum[6],a
================================================================
example-18: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low




//An adder is a circuit. The summation is computed using a logical and.
//In this case, the handles to the gray output ports should be statically connected to the respective input ports.
wire overflow;

always @(a,b) 
s = a + b + carry[7];

assign overflow = (a[7] & b[7]) | (carry[7] & a[7] & b[7]);

================================================================
example-19: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



wire [8:0] cout;
wire [7:0] coutoverflow;

sevenseg decoder(a[7:0], coutoverflow);

piporeset<=0;
one_shot<=0;
padfaddsub<=0;

seriesadder adder_part1(a[7:0], b[7:0], 1'b0, bout);
piporeset|>pouset;
one_shot |>doneshot;
serialadder runornov alongwith halfadder

//only one overflow,part1 complete,continue to part 2
// if overflow,s[7:0]=carryout,set overflow(good)
// if no overflow,s[7:0]==sum


//part 2

wire [7:0] srichsum;
//replace the halfadder and runorn
================================================================
example-20: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = overFlow | &YESoverFlow;
output [7:0] s;
output [1:0] yesOver;

================================================================
example-21: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// wire for ringing
wire za, next_borrow, next_sum;

wire one_bit_borr, one_bit_sum;

// assign the connecting wires between the mux and the single bit adder
assign za = (a[0]);
assign next_borr = (a[7] ^ b[7]);
assign next_sum = (a[7] ^ b[7]);

// instantiate the single bit adder module and connect its output to a mux that sends out a and b bit values
// if the incoming peripherals are one-bit, only 1 bit is added. Further, if input is zero, just output 0
// call the wired wires and also observe that if both peripherals are one-bit and sum is high, overflow will occur

wire [1:0] sum_mode = (b[0] & a[0
================================================================
example-22: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


	wire ms1, ls1, ms2, ls2;
	
wire [8:0] sum;
wire [8:0] c;
wire overflow;

//assigns c1 = a-b;
//assigns c2 = a+b;
fa_adder fa_adder1(
.a(a),
.b(b),
.cin1(1'b0),
.cout(c[0]),
.sum(sum[0]),
.overflow(overflow)
);

fa_adder fa_adder2(
.a(a),
.b(b),
.cin1(1'b1),
.cout(c[1]),
.sum(sum[1]),
.overflow(overflow)
);
	

assign ms1 = sum[0] ^ c[0];

================================================================
example-23: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// if the addition is a signed overflow the answer has to be changed from the most-significant-bit signed value to the residual value.
// Most significant-bit adder will be {overflow, zeros} for negative results and unary /> for positive results

// see




assign overflow = b[7] ^ a[7] & ^a[7] & b[7];
assign s = a ^ b;

//assign serial_add(...);

always @*
begin

//always assign {s, overflow} = a + b + overflow_signal;

//serial_add(a, b, overflow, overflow_signal, zeros_zeros);// version 1

serial_add sa(a[7:0], b[7:0], overflow[0], zeros_zero_operation[0], carry[0]);
repeat (
================================================================
example-24: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [7:0] carry;

wire [7:0] s_low;
wire [7:0] s_high;

wire isSigned;
wire isSigned_0;
// If 1, then an operation is a signed operation.
assign isSigned_0 = |{a[7:0],b[7:0]};

assign isSigned = isSigned_0;
assign carry[7:0] = {{8{a[7]}}, a[7:0]};
assign s_low = a[7:0] + b[7:0] - {{8{a[7]}}, a[7:0]}; // may need one additionally
assign s_high = {1'b1,a[7],1'b0,a[7:0]} + {1'b1,
================================================================
example-25: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Equal unless a[i] = 1. A circle addition requires bit i - 1 of a to be 1. Thus we use 1.A[7:1] + A[0] to calculate A.
assign A = a ^ {1'b0, a};
assign A[7:1] = A[7] ^ a[0]; 
 // We want the value of both 0 and 1 add to have the same output. 
assign q = 1;


unsigned_adder uadd0(A[0], q, 1, B[0], outp[0], overflow0);

generate
	genvar i;
	for (i=1; i<7; i=i+1) 
	begin: num_adder
	unsigned_adder uadd1(A[i], q, A[i-1], B[i], outp[i], overflow
================================================================
example-26: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [7:0] s1;
wire signed [7:0] s2;
wire zero1, zero2, zero3;

full_adder adder0(a[0], b[0], 1'b0, s1[0], zero1);
full_adder adder1(a[1], b[1], zero1, s1[1], zero2);
full_adder adder2(a[2], b[2], zero2, s1[2], zero3);
full_adder adder3(a[3], b[3], zero3, s1[3], zero1);
full_adder adder4(a[4], b[4], zero1, s1[4], zero2);
full_adder adder5(a[5], b[5], zero2, s1[5], zero3);
full
================================================================
example-27: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


i1_concatenation i1 (.a(a[7:0]),.b(b[7:0]),.c(1_bitInserter(s[7:0])));
finaladder Final(.a(b_calc[7:0]), .b(a_calc[7:0]), .c(1), .sum(s[7:0]), .carryflag(bin_carry[1:0]));
assign overflow={bin_carry[1],bin_carry[2]};


================================================================
example-28: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow =a[7]^b[7] && (a[7]!=0) && (b[7]!=0) ? 1'b1 : 1'b0;
generate 
	if( overflow ) 
	y[7:0]=8'b11111111;
endgenerate


================================================================
example-29: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



wire aSign; 
wire bSign; 

// Assign the sign of the two inputs
assign aSign = a[7]; 
assign bSign = b[7];

wire bOverflow;
wire aOverflow;

// Determine the sign of the sum
wire sumSign;

or(sumSign,aSign,bSign);

// Instantiate four 2's complement adders
wire signed [5:0] aAddr0;
wire signed [5:0] aAddr1;
wire signed [5:0] bAddr0;
wire signed [5:0] bAddr1;

// Declare the output
wire signed [6:0] sum;
wire sumOverflow;

// Assign the first adders to their outputs
assign aAddr0 = (a[7:5] >
================================================================
example-30: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Reference: https://mathcscholarly.com/archives/?p=204 


always @(*) begin

if({a,b}==24'h00_0000 && {1'b0,{7'b0000001b,1'bx}}==23'h12_0000 || {a,b}==23'h00_0090)
s=23'h0000001a;
else if({a,b}==23'h12_0000 && {a,{7'b0000001b,1'bx}}==24'h14_0000|| {a,b}==24'h00_0010)
s={a==8'h00||{a,{7'b0000001b,1'bx}}==24'h0e_0010&&&b?8'h00:8'b0110010}+8'
================================================================
example-31: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	dff_16bit d0(a,glue(a,[7:0]7'b001001_0010_0000_0000_0000_0000),clk,reset,incrementa, didit); // what we got. test.
	dff_16bit d1(b,glue(b,[7:0]7'b001010_0011_1000_1000_1000_1000),clk,reset,incrementb, didit); // what we got. test.

	bcd b2(incrementa,reset,el,didit);
reg [15:0] x;//this is a 16 bit register, i guess it needed to be so we could print a sum of undetermined size
reg [7:0] a1;
	always@ (posedge clk)
	begin
	if (el & didit) begin
	 x =
================================================================
example-32: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign overflow = (|a&b)&(~s[7]&(|s[6:0]&a))|(a&~b&~s[7]&(|s[6:0]&~s[7]));



================================================================
example-33: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign {overflow, s} = a + b ;
// "+b" is added to "a" as "carry" and then it is added with "s".



================================================================
example-34: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ( greaterZero[7] & (a[7]^b[7]) )|( greaterZero[7] & (~a[7]&~b[7]) ); 



================================================================
example-35: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [8:0] carry;

//whenever something changes, the whole computation has to be restarted
always @(*) 
begin
//initialize the accumulator to all 0's (or will have a 1 in topancial gubinstution zero)
 assign s = 0;
carry = 0;

 end
always @(*) 
if(!--oother) //whenever a or b revert to positive, complete the computation and only in the rest of the cases carry will be 1.
 begin
 //FIXME somebody need to see whether a carry overflow may occur
 //FIXME if carry overflow happens add 1 for the positive value of a, so the carry sum gets 0
//assign s = s + a + s[6:1] + (a[8]^b[8]);
//shortcut if the mantissae are all 1's or 0's we that case we are done,
================================================================
example-36: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire b_sign, a_sign;
assign b_sign = b[7] ^ (b[6:0] == 7'd1);
assign a_sign = a[7] ^ (a[6:0] == 7'd1);

always @(a,b)
begin

if (a_sign == b_sign) begin
// no overflow
assign overflow = 0;
assign s = a + b;
end
else if (a_sign == 1'b0) begin
// no overflow
assign overflow = 0;
assign s = a - b;
end
else if (b_sign == 1'b0) begin
// no overflow
assign overflow = 0;
assign s = a + ~b + 1;
end
else if (a == 8'd0) begin
// negative/both signs, positive/both
================================================================
example-37: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Implementation
// A truth table is given for the number of the selected operation
// x | y | a b | s overflow
// 0 | 1 | + |
// 0 | 0 | + |
// 0 | n | + |
// 1 | n | + |
// n | n | + |
// n | 0 | + |
// anything | - | -
//
assign overflow = (aciescond1) ? ax`bznine :1'b0;

// a and b are added together
assign s = a + b;

// Overflow for the ADD operation
assign acycon = (bracelements[`ADD]) ? (agents[`ADD]|overflow) :1'b0;

// Remove the sign of the negative outputs
assign axn = ~a [7];
assign bxn = ~b [7]; // Remove
================================================================
example-38: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



reg [7:0] s1;
always @ * begin 
if ({b[7],a[7]}) begin
s1= {b[7],8'b0};

end else begin
s1= a;

end
end

reg overflow1;

always @ * begin // The assignment to overflow must be within the always block
if ({b[7],a[7]}) begin
overflow1=1;
end

else begin
overflow1=0; 
end
end

assign overflow=overflow1;
assign s=s1;



================================================================
example-39: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



================================================================
example-40: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// Using the signed addition for non-negative numbers is atomic
wire unsigned_a_plus_b;//upper bits of intervals a and b
//Using the interval representation a and b as shown above atomic signed addition is possible

assign unsigned_a_plus_b = a+b; //overflow signal occurs if a or b is too large for the arithmetic addition

//Check overflow
	//This is done in function and never here
assign overflow = (a_overflow == 1) ? 1 : 0;
	 


//This is different from interval adder
// Expending time is twice that of interval adder
always @(a, b, unsigned_a_plus_b)
begin
	if(b==1'b0) 
	begin
//Expend time is 1
	s = {1'b0, unsigned_a_plus_b};
	
================================================================
example-41: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


reg [7:0] b_comp;
assign b_cmp = ~b + 1'b1;
always @ (a or b or b_comp)
	begin:s_add
	wire [8:0] sum ;
	
	assign sum[0] = ~a[0] + 1'b1;
	assign sum[1] = ~a[1] + b[0];
	assign sum[2] = ~a[2] + b[1];
	assign sum[3] = ~a[3] + b[2];
	assign sum[4] = ~a[4] + b[3];
	assign sum[5] = ~a[5] + b[4];
	assign sum[6] = ~a[6] + b[5];
	assign sum[7] =
================================================================
example-42: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0] a_out;
wire [7:0] b_out;
reg [7:0] s = 8'b00000001;

adder add_1 (a, b, a_out, b_out);
always@*
begin
if(a_out > 8'b00000001)
	begin
	s = s + 1;
	end
else if(a_out < 8'b00000001)
	begin
	s = s - 1;
	end
	
end
// Connect the salphas with the adder
assign s = a_out + b_out;


================================================================
example-43: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0] b_overflow_no_lower_b;
wire b_overflow_lower_b;
wire [7:0] b_overflow;
wire b_overflow_sign;

// if top most bit is high the adder subtraction will result in a negative overflow
divider_top_bit_filter divider(.input_signal(a[7]), .output_signal(b_overflow_no_lower_b), .suppress_zero_signal(1'b1));

// divider_top_bit_filter takes in a signal input_signal and outputs the bit in the input that was equivalent to 0 and also the complement of the most significant bit to be subtracted

// subtract b_overflow_no_lower_b as it will remove the sign and potential 
// leading 0 from the sign bit of b
================================================================
example-44: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [7:0] existing_overflow_sign_in;
wire [7:0] carry_input ={1'b0,1'b1}; //OLD COMMENTS Changed to 1'b1 for adding to gain extra 1 else it'll be 0 which does NOT look correct
wire addone1 = (a[7] == b[7]) ? (a) + carry_input : (a) + {1'b0,1'b1}; 
wire [7:0] top_overflow_output;


top_adder_and top_adder(
.a(addone1),
.b(b),
.cin(1'b0),
.s(s),
.out(top_overflow_output)
); 

wire [3:0] halfstep;
wire [7:0] secstep; 

both_
================================================================
example-45: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


 
// always @ * 
// begin 
 
 
// end 
 
assign overflow = 1'b0; // by default no errors
 
if((a[7]&^b[7]==1'b1) || (b[7]&^a[7]==1'b1)) 
if((s[7]&^a[7]==1'b0) || (a[7]&^s[7]==1'b0)) 
overflow = 1'b0; 
 
// more specific designs may be faster in the compiled circuit. 

always @(a,b,s) 

if ((a[7]&b[7]) || (a[7]&~b[7])) begin 
s = s+1; 
if (s[7] == 1'b
================================================================
example-46: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire carryb0,carryb1,carry_overflow;
wire [7:0] s,over,temp_over,borrowb,sumdiff;
wire carrya0,carrya1,overflow,overflow_o;
wire [7:0] a_tmp;
wire [7:0] temp;

assign s = sumdiff ; //shunt the sumdiff to the final result itself

assign carrya0 = a[0];
assign carrya1 = a[1];
assign carrya0b1 = (carrya0 & b[0]) + (b[0] & carrya1) ;
assign carryb0b1 = (carryb0 & b[0]) + (b[0] & carryb1) ;
assign overflow_o = (carrya0b1 & carryb0b1) + (
================================================================
example-47: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 multiplexer_always 
	#(32)(a => s) 
 
	fifo_async_top
 
// Create an 8-bit preamp and precharge with the data inputs.
initial 
	$write("\n");
	$write("============================================================\n");
	$write("= Testbench for Sensitivity List%0s Control\n", strings);
	$write("============================================================\n");
#30 $write("| a[7:0] | b[7:0] | s[7:0] | overflow |\n");

================================================================
example-48: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



wire signed [8:0] op1; 

// check b bit before loop
wire signed [7:0] a0b, upper;

assign a0b = a[7] ? {1'b1, a[7:1]} : {1'b0, a[7:0]};
assign upper = {{2{a[7]}}, a[7:0]};

assign op1 = a0b + upper;
always @(*) begin
	if(op1[8] == 1'b1) 
	begin
	s[7:0] = sum;
	overflow = 1;
	
	end
	// tc adjust overflow 
	else if(op1[7] == 1&&op1[7] == 0)
	begin
	s[7:0] = sum;
	over
================================================================
example-49: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low




wire [7:0] s_input_sign;
double_flipflop signed_add(s_input_sign[7:0],a[7:0], b[7:0], (78'b000000000000));

wire overload;
wire s_over;

assign overflow = a[7] & b[7] & ~s_input_sign[7];

always@(*)
begin
assign s[7:0] = s_input_sign[7:0] + (overflow? 1'b1 : (s_over? 1 : 0) );
end

assign s_over = (~a[7] & b[7] & s_input_sign[7]) | (a[7] & ~b[7] & ~s_input_sign[7]);


////////////////////////////////////////////////////////////////////////
// End design



================================================================
