example-0: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if one of them is high then the state changes to SA and the other to SB. 
always @ (posedge clk)
begin
if (!reset)
cur_state <= IDLE;
else
case (cur_state)
IDLE:
begin
if (a)
next_state <= SA;
else if (b)
next_state <= SB;
else
next_state <= IDLE;
end
SA:
begin
if (a)
next_state <= SB;
else
next_state <= SA;
end
SB:
begin
if (b)
next_state <= SAB;
else
next_state <= SA;
end
SAB:
begin
if (a)
next_state <= SA;
else if (b)
next_state <= SAB;
else
next_state <= IDLE;
end
endcase
================================================================
example-1: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if a is high and not input b, change to SA. 
// if b is high and not input a, change to SB. 
always @(posedge clk)
begin
if (reset == 1)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(a or b)
begin
case (cur_state)
IDLE:
begin
if (a)
next_state <= SA;
if (b)
next_state <= IDLE;
end
SA:
begin
if (b)
next_state <= IDLE;
else
next_state <= SAB;
end
SB:
begin
if (a)
next_state <= SAB;
else
next_state <= IDLE;
end
SAB:
begin
if (a)
next_state <= IDLE;

================================================================
example-2: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If either one of input a or b is high, then current state 
// remains the same and output z is 1. If reset function triggers, 
// current state is AL1.
// cur_state assignments:
always @(posedge clk or negedge reset) begin
if (~reset)
cur_state<=IDLE;
else
cur_state<=next_state;
end
always @(cur_state or a or b) 
case(cur_state)
IDLE: begin
next_state = SA;
if(a&b)
z=1;
else 
z=0;
end
SA: begin
next_state = SB;
end
SB:begin
next_state = SAB;
end
SAB:begin
next_state = IDLE;
end
endcase

================================================================
example-3: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only a or b are high, the bus line is high?
always @(posedge clk,posedge reset) 
begin 
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <=next_state;
end
always @(cur_state,a,b) 
begin
// if input is high, return SA
	case(cur_state)
	
	IDLE:
	begin
	if(a == 1'b1 && b == 1'b1) next_state = SA;
	else if(a == 1'b0 && b == 1'b0) next_state = SB;
	else next_state = IDLE;
	
	end
	
	// a and b are both low: return SAB
	SA:
	begin
	if(a == 1'b0
================================================================
example-4: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk) begin
if(reset)
cur_state <= IDLE;
else 
cur_state <= next_state;
// Update state
end
// Next state assignment:
always @(*)
case(cur_state)
IDLE: if(a&b)

next_state <= SA; 

else if(a&~b) 
next_state <= SB; 

else if(~a&~b) 
next_state <= AB; 
endcase

================================================================
example-5: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high and input b is low, state changes to SA
// if input a is low and input b is high, state changes to SB
always @(posedge clk)
 if (reset)
cur_state <= IDLE;
else
cur_state <= next_state;
always @(*)
case (cur_state)
IDLE: begin next_state <= (a)?1:0; z <= 0; end
SA: begin next_state <= (b)?1:2; end
SB: begin next_state <= (a)?1:0; end
SAB: begin next_state <= IDLE; z <= 1; end
endcase


================================================================
example-6: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b is high only, the state changes to SA.
// if input a or b are both low, the state changes to IDLE. 
reg z;
always@(posedge clk)
	if (reset) cur_state <= IDLE;
	else cur_state <= next_state;
always@(*)
begin
case(cur_state)
IDLE: if({a,b}==2'b1) next_state = SA; else next_state = IDLE;
SA: if({a,b}==2'b0) next_state = SA; else next_state = IDLE;
IDLE: if({b} == 1'b1) next_state = SB; else next_state = IDLE;
// labeled sub-expressions to make it clearer:
SA: begin
	if(a==1'b0 && b==
================================================================
example-7: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// else if only a is high, then current state is SA. 
// If only b is high, then current state is SB. 
assign {z, dunut_a, dunut_b} = {uart_w0_3,b,a};


always @(posedge clk or posedge reset)
 begin
 if(reset ==1'b1)
 cur_state <= IDLE;
 else
 cur_state <= next_state;
 end
// FSMtransition logic (combinational logic)
always @ ( * )
begin
case ( cur_state )
IDLE :
begin
if ( reset == 1'b1 )
 next_state <= IDLE;
else
next_state <= SA;
//$display("Current state: IDLE\nNext state: SA Instant NA0%d",$time);
end
SA :
begin

================================================================
example-8: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only a is high, state changes to SA
// if only b is high, state changes to 
// next_state = status from params is also constant.
reg [1:0] s_reg;
// Edge detect. The state is not changed unless this
// is true. This means it is also reset to IDLE
always @(posedge clk, posedge reset) begin
	if(reset) begin
	cur_state <=IDLE;	 	//Initial state, should be looking at params
	s_reg <= IDLE;	 	//Defaults to IDLE.
	end
	else begin //state not reset
	cur_state <= next_state;	//update state
	s_reg <= s_reg;	//update status register
	end //end else
end //end always
always @(s_reg) begin
	case(s_
================================================================
example-9: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// Otherwise, if input a is high only, state changes to SA
// otherwise, if input b is high, state goes to SB
assign rst_shft = reset;
// applicable to both dynamic state machines and non-blocking flip flops 
assign a_yn = cur_state == SA & a;
assign b_yn = cur_state == SA & b;
shift_reg s0
sf_flipflop sl
dur_flipflop dl

================================================================
example-10: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a and b are both low, state dattaches.
always @(posedge clk) begin
if(reset==1) cur_state <= IDLE;
else cur_state <= next_state;
end
always @(*) begin
case(cur_state,IDLE)
SA: begin
next_state = a?SAB:IDLE;
end
SB: begin
next_state = b?IDLE:SB;
end
default: next_state = IDLE;
endcase
end
// Output logic:
assign z = (cur_state==SAB);

================================================================
example-11: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high, state changes to SA. 
// if input b is high, state changes to SB. 
// Active logic:
// output is asserted for one clock cycle. 
// at time 0, z is high for one clock cycle.
always @(posedge clk)
if(reset | cur_state==IDLE)
	cur_state <= next_state;
else
	cur_state <= IDLE;
always @(cur_state,a,b)
if(cur_state==IDLE)
	if(a&b) next_state <= SA;
else if(a) next_state <= SB;
else if(b) next_state <= SAB;

================================================================
example-12: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b is high and a is low, SA becomes SAB and transition to next state.
// if input a, b all low, transition back to the same state.
always @(posedge clk) 
	if(reset) cur_state <= IDLE;
	else cur_state <= next_state;
always @(*)begin
	next_state = cur_state;
	case(cur_state)
IDLE:
	begin
	if(a&&b) next_state = SA;
	else if(a) next_state = SA;
	else if(b) next_state = SB;
	else next_state = IDLE;
	end
	SA:
	begin
	if(a&&b) next_state = SAB;
	else if(b) next_state = SA;
	else next_state = SA;
================================================================
example-13: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always@(posedge clk or negedge reset)
begin
if(~reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always@(*)
case(next_state)
SA: if(a == b)
next_state <= SA;
else
next_state <= IDLE;
SB:
next_state <= SA;
endcase
always@(*)
if(a == ((cur_state === SA)||(cur_state === SB))
z = 1'b1;
else
z = 1'b0;

================================================================
example-14: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only a is high, the output z goes high
always @(posedge clk, negedge reset)
begin
if (reset == 0)
cur_state <= IDLE;
else
cur_state <= next_state;
end
// Next state selector
always @(cur_state or a or b)
begin
case(cur_state)
IDLE:
begin
if (a==1 & b==1)
next_state <= SA;
else if (b==1 & a==0)
next_state <= SB;
else
next_state <= IDLE;
end
SA: next_state <= SAB;
SB: next_state <= IDLE;
SAB: if (a==1 & b==1)
next_state <= SA;
else if (a==1 & b==0)
next_state <= SB;
else if
================================================================
example-15: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If a is high and b is, then S to SB i.e. S+ -> SB, second state.
// If both are low/high, state remains stays same.
always @(posedge clk or posedge reset)
begin
if (reset) begin
cur_state <= IDLE;
end 
else
cur_state <= next_state;
end
// Output z is asserted 1 or 0 depending on the activity of state SAB.
// Asserted when input a, b is held high and the next input is high or when rst == 1. 
// The neuron will reset to IDLE state whenablohow is asserted.
always @(posedge clk or posedge reset)
begin
if(reset) begin
	z <= 0;
end 
else begin
	// The output is high for each clock cycle.
	z <= (~cur_state[
================================================================
example-16: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b is high and input a is NOT high, SINGLE if O is low; ON every other clock edge SINGLE goes OFF and SINGLE gets stable; STATE comes SINGLE an else becomes STATE itself.
// when in STATE SINGLE, permanent_one stays low unless else becomes true(SA) while state remains SINGLE so state remains SINGLE.
// when in IDLE and b is high and a is high, a and b stay high for time MIN_ON after clock edge the second falling edge starts, then reset 1ns after; z is asserted
// o otherwise. Note: remaining bits of state are always kept, even in IDLE state.
always @ (posedge clk or posedge reset)
case (cur_state)
IDLE: begin
if (reset)
 next_state = SA;
else
next_state = IDLE;
end
SA: begin
================================================================
example-17: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if a is high only, state changes to SA.
// if b is high only, state changes to SB.
// if none of a or b are high, remain IDLE.
// cur_state registers last input values of a and b, and outputs z only if 
// it is one of the levels of SA, SB, or SAB.
always @(posedge clk or reset)
begin
if (reset == 1'b1)
cur_state <= 3'b000;
else
cur_state <= next_state;
end
always @(*)
case (cur_state)
IDLE: next_state <= (a & b) ? 1 : IDLE; 
SA: next_state <= (a & b) ? 1 : IDLE; 
SB: next_state <= (a & b) ? 1 : IDLE; 
SAB: next_state
================================================================
example-18: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// Otherwise, current state is 'idle'
always@(posedge clk or posedge reset)
begin
if (reset)
cur_state <= {2{1'b0}};
else
cur_state <= next_state;
end
always@(*)
begin
next_state <= SA;
case(cur_state)
IDLE:
if(a==b)
next_state <= SA;
else
next_state <=	IDLE;
SA:	
if(a == 0 && b == 0)
next_state <=SID;
else
next_state <= SA;
SID:
if(a == 0 && b == 1)
next_state <=SAB;
else
next_state <= SA;
SAD:
if(a == 0 && b == 1)
next_state <=AB;
else next_state <= SA
================================================================
example-19: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only a is high, SA is entered.
// if only b is high, SB is entered.
always@(posedge clk)
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
always@(*)
begin
case(cur_state)
IDLE : if(a & b) begin 
next_state <= SA; end
else if(a) begin
next_state <= SB; end
else if(b) begin
next_state <= SAB; end
endcase
end
// busz generation: if qutntest is 00 1010 or 00 1010 1100, then busz is high.
reg [2:0] qutntest;
always@(*)
begin
case(cur_state)
SA:begin
qutntest = 3'b011;
if
================================================================
example-20: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high, state changes to SA. 
// if input b is high, state changes to SB.
always @(posedge clk)
if(reset) cur_state <= IDLE;
else cur_state <= next_state;
always @(*)
if(reset) next_state <= IDLE;
else next_state <= cur_state;
// Output logic.
// z is asserted 1 when the current state is SAB.
assign z = ((cur_state == SAB) || 
(cur_state == SA && b == 1) ||
(cur_state == SB && a == 1));

================================================================
example-21: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk)
begin 
if (reset)
cur_state <= IDLE;
else
cur_state <= next_state;
if (a == b)
next_state <= SA;
else
next_state <= IDLE;
end 
// Output z based on the current state. On each clock edge the state changes based on the enable input.
always @(*)
begin
case (cur_state)
SA: begin 
assign z = b;
end
IDLE: begin
assign z = 1'b1; 
end
default: begin
assign z = 1'b0; 
end
endcase
end 

================================================================
example-22: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// else, cahnges to SA.
	always@(posedge clk) begin
	if(~reset_n) 
	cur_state <= IDLE;
	else 
	cur_state <= next_state;
	end
	// NEST STATE
	always@(*) begin
	case(cur_state)
	IDLE : begin 
	if(~a & ~b)	next_state = SA; 
	else 
	next_state = IDLE; 
	end
	SA : begin 
	if(~b)	next_state = SA; 
	else 
	next_state = IDLE; 
	end
	SB : begin 
	if(~a & b)	next_state = SAB; 
	else 
	next_state = IDLE; 
	end

================================================================
example-23: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a and b are both low, SABEL after SA. 
// if input a is high and b is low,SABEL following SA.
// if input a is low, and b high, SB followed after SA. 
always@(posedge clk, posedge reset)
 if(reset)
 cur_state <= IDLE;
 else
 cur_state <= next_state;
always@(cur_state or a or b)
 begin
 case(cur_state)
 IDLE :
 if(a and b) 
 next_state <= SA;
 else
 next_state <= IDLE;
 SA :
 if(a and b) 
 next_state <= SAB; 
 else
 next_state <= SA;
 SAB :
 if(a) 
 next_state <= SABEL; 
 else
 next_state <= SBEL;

================================================================
example-24: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If one of input a or b is high, and the other high, the transition 
// is made dependent on one of the inputs.
// if one of input a or b is high, and the other is low, the trans
// to SAB is assigned HIGH.
always @(posedge clk) 
begin
	if (reset) 
	cur_state <= IDLE;
	else
	cur_state <= next_state;
end
always @(cur_state,a,b)
begin
case(cur_state)
/*
IDLE
SMOOTH = if a,b = 0 (0 means pressing toggle button ?);
SA = a pressed and b is high. next state: SAB.
SB = b pressed and a is high. next state: SAB.
Explicit don't wait assignment:
always @(*)
begin
case(next_state
================================================================
example-25: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high and b is low, state is SA (the abro becomes 1 high). 
// if input a, b, and c are low simultaneously then state becomes SB. 
assign next_state = ((cur_state == SA && a && b) || (cur_state == SB && b && c));
always@(posedge clk)
	begin
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
	assign z = (cur_state == SAB);
	end

================================================================
example-26: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if one of them is high, sa is 0 and b is asserted.
always @(cur_state or a or b) 
begin
case(cur_state)
IDLE: 
	if(a==1'b1 & b==1'b1)
	begin 
	next_state = SA; 
	end
	else if(a==1'b0 & b==1'b0)
	begin
	next_state = SB; 
	end
	else
	begin
	next_state = IDLE; 
	end
SA: 
	begin
	if(a==1'b1 & b==1'b0)
	begin
	next_state = IDLE; 
	end
	else 
	begin
	next_state = SAB; 
	end
end
SB:
	begin

================================================================
example-27: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b only is high, then SAB is entered twice and the 
// cursor will advance to the next state while mominently 
// consisting of two SAB states.
always @(posedge clk or negedge reset)
if (!reset)
cur_state <= IDLE;
else
cur_state <= next_state;
always @(*)
begin
case(cur_state)
IDLE: if (a&b)
next_state <= SA;
else if (b) 
next_state <= IDLE;
else next_state <= SB;
una = cur_state = SA;
SB: if (a)
next_state <= IDLE;
else
begin
next_state <= SB;
ena = 2'b10;
end
endcase
end
// omit branch of default

// using always_ff only requires instantcing extra

================================================================
example-28: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
assign z = (cur_state == SA && a && b);
always @(posedge clk) begin
if(reset==1'b0) 
cur_state<=IDLE;
else 
cur_state <= next_state;
end 
always @(*) begin
case(cur_state)
IDLE: begin
next_state = (a)? SA:IDLE;
end
SA: begin
next_state = (b)? SB:SA;
end
SB: begin
next_state = SAB;
end
SAB: begin
next_state = IDLE;
end
default: 
next_state=IDLE;
endcase
end 
always @(cur_state) begin
case(cur_state)
IDLE:begin
z=1'b0;
end
SA:begin
z=1'b0
================================================================
example-29: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk or negedge reset)
begin
if (~reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
// next state generation:
always @(*)
begin
case(cur_state)
IDLE : begin
if(a && b)
next_state <= SA;
else if(a)
next_state <= IDLE;
else if(b)
next_state <= SB;
end
SA : begin
if(a && b)
next_state <= SAB;
else
next_state <= IDLE;
end
SB : begin
if(a && b)
next_state <= SAB;
else
next_state <= IDLE;
end
SAB : begin 
if(a && b)
next_state <= SAB;
else
next_state <= ID
================================================================
example-30: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If only a is high, the state changes to SA, if only b is high, to IDLE.
always@(posedge clk, posedge reset)
begin
	if(reset)
	cur_state <= #1 IDLE;
	else
	begin
	case(cur_state)
	IDLE:
	if(a)
	cur_state <= #1 SA;
	else if(b)
	cur_state <= #1 IDLE;
	else
	cur_state <= IDLE;
	SA:
	if(a)//State stays SA if only a is high
	cur_state <= #1 SA;
	else
	cur_state <= #1 IDLE;
	endcase
	end
always@(posedge clk)
begin
case(cur_state)
IDLE: next_state <= #1 IDLE
================================================================
example-31: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high but b is low, state changes to SA. 
assign z = ({cur_state}!=={IDLE});
always @(posedge clk or reset)
if (reset)
cur_state <= IDLE;
else
cur_state <= next_state;
// FSM next state and outputs logic:
always @(*)
begin
case(cur_state)
IDLE:
begin
if(a==high & b==high)
	next_state = SA;
else if (b==high)
	next_state = SB;
else
	next_state = IDLE;
end
SA:
begin
	if(a==high)
	begin
	next_state = IDLE;
end
else
	next_state = SAB;
end
SB:
begin
	if(a==high)

================================================================
example-32: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only a is high, the state becomes SA.
// if only b is high, state becomes SB.
always@(posedge clk or negedge reset)
if(reset == 1'b0)
cur_state <= IDLE;
else
cur_state <= next_state;
// nextstate
always@(*)
begin
case(cur_state)
	IDLE:
	begin
	if (a == 1'b1 & b == 1'b1)
	next_state <= SA;
	else if (a == 1'b1 & b == 1'b0)
	next_state <= SB;
	else if (a == 1'b0 & b == 1'b1)
	next_state <= SAB;
	else if (a == 1'b0 & b == 1'b1)
	next_state <= S
================================================================
example-33: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk or posedge reset) 
if (reset)
cur_state <= IDLE;
else 
cur_state <= next_state;
// next state
always @(*)
case (cur_state)
IDLE: begin
if (a && b) 
next_state = SA;
else
next_state = IDLE;
end
SA: begin
if (a && b) 
next_state = SAB;
else
next_state = SA;
end
SB: begin
if (a)
next_state = SB;
else
next_state = IDLE;
end
SAB:
next_state = SAB;
default: 
next_state = IDLE;
endcase
// output
assign z = (cur_state == SAB);

================================================================
example-34: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
assign z = ((cur_state == SA) && (a == 1) && (b == 1))?1:0;
always @(posedge clk)
begin
	if (reset == 1'b1)
	begin
	cur_state = IDLE;
	end
	else
	begin
	cur_state = next_state;
	end
end 
always @(cur_state or a or b)
begin
	// The state nest: state transition logic
	case (cur_state)
	IDLE:
	begin
	if (a == 1)
	begin
	next_state = SA;
	end
	else if (b == 1)
	begin
	next_state = SB;
	end
	else
	begin
	next_state = IDLE;
	end
	end
	SA:
	begin
================================================================
example-35: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high only, state changes to SA.
always @(posedge clk) 
begin
if(reset==1'b1)
cur_state <= IDLE;
else
cur_state <= next_state;
end
// Edge rate logic:a_rising_edge, a_falling_edge, b_rising_edge, and b_falling_edge
// are assign statements.
// Cur_state is assign statements.
// The procedural programming here is synthesizable:
// There are cases where synthesis process will fail,
// A simulation will fail too.
// 1. a can only go HIGH to create a nest state SA in the next block.
// 2. Jet cannot see that a, even though input a is high in the next block, this signal still needs to be routed thru next block through an always do statement.
// The synthesis process may create warnings in this corner
================================================================
example-36: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b and a are both high, state becomes IDLE.
// if any of input a or b is high, the other is asserted high,
// and IDLE state is entered (making this the nest state).
always @(posedge clk) begin
if (!reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
// Update state sequencer.
// FSM would be completed when both a and b are low.
always @(cur_state) begin
case (cur_state)
IDLE : begin
if (b===0) next_state <= SA;
else next_state <= IDLE;
end
// if a is high and input b is low.
SA : begin
if (b===0) next_state <= IDLE;
else next_state <= SB;
end
// if a is low and input b
================================================================
example-37: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If only a is high, the next state is SA.
// If only b is high, the next state is SB.
always @(*) 
case (cur_state)
IDLE: 
	if(a)
	begin
	next_state = SA;
	z=~a;
	end 
else
	begin
	next_state = IDLE;
	z=0;
	end
SA: 
	begin
	if(b)
	begin
	next_state = IDLE;
	z=0;
	end
	else
	{next_state,z}= {based on b,z};
	end
SB: 
	begin
	if(b)
	begin
	next_state = BUFFER_DELAY
	end
	else
	next_state = IDLE;
	end
	
================================================================
example-38: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input b is high only, state changes to SA
// if input a is high only, state changes to SB
// z is asserted when state is SAB
always @(posedge clk,posedge reset)
	if(reset==1)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
/*
always @(posedge clk,posedge reset)
	if(reset==1)
	cur_state <= IDLE;
/*
	if (reset)

*/
always @(1'b0,a,b) //combined statement.
	
always @(cur_state)
	case(cur_state)
	IDLE: begin 
	
	if ((a==0)&(b==0)) q1=0;
	else if (a==b) q1=1;

================================================================
example-39: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// If only input a is high, state drops to IDLE.
// If only input b is high, the state changes to SA and z is 1.
always @ (reset or cur_state or next_state or a or b) begin
case (cur_state) 
// IDLE state must be initial state.
IDLE: begin
if (a ==0 & b == 0)
next_state = IDLE;
else if (~a & ~b & z == 1)
next_state = IDLE;
else next_state = SA;
end
// SA state, only a high input is significant.
SA: begin
if (~a & ~b & z == 1)
next_state = SA;
else if (a == 0 & b == 0)
next_state = SAB;
else next_state = IDLE;
end
// SAB state, only b high
================================================================
example-40: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high and b is low, state transitions to IDLE. 
always@(posedge clk or reset)
if(reset) cur_state <= IDLE;
else cur_state <= next_state;
// Enable latch to next_state on each posedge of clk.
// Combinational next_state logic.
always@(*)
case(cur_state)
IDLE:
if((a)and(b)) next_state <= SA;
else if((a)or(b)) next_state <= SB;
else next_state <= IDLE;
SA:
if((a)) next_state <= SAB;
else next_state <= SA;
SB:
if((b)) next_state <= SAB;
else next_state <= IDLE;
default: next_state <= IDLE;
endcase
// Output logic
assign
================================================================
example-41: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk used as clk) begin
case (cur_state)
IDLE:
	if (a & b)
	next_state <= SA;
	else
	next_state <= IDLE;
SA:
	if (b)
	next_state <= SB;
	else
	next_state <= SA;
SB:
	if (a)
	next_state <= SAB;
	else
	next_state <= SA;
default:
	next_state <= IDLE;
endcase
end

// Output of current state
always @(cur_state) begin
case (cur_state)
SA: z = 1'b1;
SB: z = 1'b0;
SAB: z = 1'b0;
default: z = 1'b0;
endcase
end

// Complex path
================================================================
example-42: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always@(posedge clk, posedge reset)
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
// vertical_nand: create a 2 input NAND.
// Input a and b on each clock cycle. Assert b at the end.
// cur_state is SA, i.e. a is low. Input a on the next clock cycle will be negated.
// Input b on each clock cycle is high and assribted to cur_state on each clock cycle
// is abro since it has been asserted high when cur_state was SA.
// Notice: Invoking "always" in combinational block ensures this is run only once.
// The standard combinational logic has a time delay of 0.4 clock cycles which is 
// not usually suitable for the activity analysis simulation.
vertical_nand vertical_nand_a_
================================================================
example-43: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk or negedge reset)
begin
	if(!reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
end
// Output logic:
assign z = ((next_state == SA) || (next_state == SAB));
always @(cur_state or a or b)
case(cur_state)
	IDLE:
	begin
	if(a and b)
	next_state = SA;
	else
	next_state = IDLE;
	end
	SA:
	begin
	if(a and b)
	next_state = SA;
	else
	next_state = IDLE;
	end
	SAB:
	begin
	if(a and b)
	next_state = SAB;
	else
	next_
================================================================
example-44: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if only input b is high, state changes to SB. 
// else if only input a is high, state changes to SA. 
always @(posedge clk or negedge reset) begin
if(!reset) cur_state <= IDLE;
else cur_state <= next_state;
end
// other combinatorial logic come later.
// Combinational Logic below:
always @(*) begin
case(cur_state)
IDLE: next_state= a?SA:b?SB:1'b0;
(* parallel_case *) case(1'b1):
SA: next_state=SA;
sbAB: begin
case(1'b1)
a?(b):(z)=1;
endcase
end
sbBC: begin
case(1'b1)
b?(a):(z)=1;
endcase
================================================================
example-45: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high, state changes to SA, if input b is high SAB remains same.
always @ (posedge clk or posedge reset)
begin
	if (reset)
	// reset asserted
	cur_state <= IDLE;
	else
	// always else if
	cur_state <= next_state;
end
always @(*)
begin 
	case (cur_state) 
	idle:begin
	//Nest Basilics components
	next_state=sa;
	end
	sa:begin
	next_state= Note1 & Note2;
	end
	Note1 & Note2:begin
	next_state=sa;
	end
	endcase
end

================================================================
example-46: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
always @(posedge clk) 
begin
	if(reset == 1) 
	begin
	cur_state <= IDLE; 
	end
// Issue a clock pulse for 1 ns.
	else 
	begin
	#ns
	cur_state <= next_state;
	end
end
// FSM
always @(posedge clk) 
begin

case(cur_state)
IDLE : begin
// If reset, cur_state is intialiazed to idle state. 
if (reset == 1)
	next_state = SA;
else 
	next_state = IDLE; 
	end
SA : begin
//If reset a is high or if input b is high and current state is not SAB,
//cur_state transitions to SA.
if(a == 1) //current state is IDLE or reset is
================================================================
example-47: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if both input are low, state changes to IDLE. 
always @(posedge clk or negedge reset)
if(!reset) cur_state <= IDLE;
else cur_state <= next_state;
// nest state transitions generation:
always @(cur_state)
case(cur_state)
IDLE : next_state <= SA;
SA : next_state <= (a&b) ? IDLE : SB;
SB : next_state <= (a&b) ? SA : SAB;
SAB : next_state <= p ? IDLE : SAB;
default : next_state <= IDLE;
endcase
// Output z when in SA or SAB:
assign z = (cur_state == SAB || cur_state == SA) ? 1:0;

================================================================
example-48: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// otherwise, states change to SA, SB right to the following SA.
// All these states click instead of remain as in IDLE state and can be used to determine current state further.
always @(posedge clk or posedge reset)
	if (reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
// combinational constraints such isto:nest state 주기
	always @( * )
	begin	
	//	if A or B is high, then this is a nested SA
	//	otherwise, nest has ist here
	next_state <= INVAL_bit (cur_state,a) + INVAL_bit(cur_state,b);
	end
// combinational signal generation:
assign z = ((cur_state == SAB)|(cur_state == SAB) );

================================================================
example-49: 
// This is an FSM 
module abro(
input clk,
input reset,
input a,
input b,
output z 
);
parameter IDLE = 0, SA = 1, SB = 2, SAB = 3;
reg [1:0] cur_state,next_state;
// Update state or reset on every clock edge.
// Output z is asserted 1 when the current state is SAB.
// Nest state generation logic:
// if input a and b both are high, state changes to SAB. 
// if input a is high z is cleared.
// if input b is high, state changes to SB. 
always @(*)
begin
case(cur_state)
IDLE: begin 
	if(a & b)
	next_state=SA;
	else
	next_state=IDLE;
	z=0;
	end
SA: begin
	if(!a)
	next_state = IDLE;
	else 
	next_state = SB;
	z = 0;
	end
SB: begin
	if(b)
	next_state = SAB;
	else
	next_state = IDLE;
	z=0;
	end
SAB: begin
	if(!b)
	next_state=IDLE;
	else
	next_state = IDLE;
	z=0
================================================================
