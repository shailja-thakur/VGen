example-0: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state, in)
begin
next_state = present_state;
case(present_state)
0:
begin
if(in)
next_state = 1;
else
next_state = 0;
end
1:
begin
if(in)
next_state = 0;
else
next_state = 1;
end
endcase
end
// Outputs
assign out = (present_state == 1)? 1:0;

================================================================
example-1: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// States
parameter s0=0,s1=1;
// State machine
always @(posedge clk or posedge reset)
begin
if(reset)
present_state <= s0;
else 
present_state <= next_state;
end
always @(present_state or in)
begin
case(next_state)
s0: if(in) next_state <= s1;
s1: if(in) next_state <= s0;
default: next_state <= s0;
endcase
end
assign out= (!present_state)&&in;

================================================================
example-2: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next_state is the state which is being transitioned to
// present_state is the state which is currently present
// out is the output of the state being present
// clk is the clock signal for the state registering
// reset is the reset signal for the state registering
// present_state_register, next_state_register, out_register
// in_register
// clk_enable_register
// reset_register
initial
begin
present_state = 1'b0;
next_state = 1'b0;
out = 1'b0;
end
always @(posedge clk)
begin
if (reset)
present_state <= 1'b0;
else
present_state <= in;
end
always @(posedge clk)
begin
case (present_state)
0:
	begin
	if (in)
	next_state <=
================================================================
example-3: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

always @(posedge clk, posedge reset)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end

always @(present_state, in)
begin
case (present_state)
0 : begin
next_state <= in ? 0 : 1;
out <= 0;
end
1 : begin
next_state <= in ? 0 : 1;
out <= 1;
end
endcase
end


================================================================
example-4: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
if(reset == 1)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state, in)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 0 : 0;
endcase
end
always @(present_state)
begin
case(present_state)
0: out = 0;
1: out = 0;
endcase
end

================================================================
example-5: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
if (reset == 1)
present_state = 0;
else
present_state = next_state;
end
always @(present_state, in)
begin
case (present_state)
0 : if (in == 1)
next_state = 0;
else
next_state = 1;
1 : if (in == 0)
next_state = 0;
else
next_state = 1;
default : next_state = 0;
endcase
end
// Output logic
assign out = (present_state == 0) & (next_state == 0);

================================================================
example-6: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
if (reset)
present_state <= 0;
else
present_state <= next_state;
// Next state
always @(present_state, in)
begin
case (present_state)
0 : begin
if (in == 1) next_state = 1;
else next_state = 0;
end
1 : begin
if (in == 0) next_state = 0;
else next_state = 1;
end
default : begin
next_state = 0;
end
endcase
end
// Output logic
assign out = (present_state == 1) & (next_state == 0);

================================================================
example-7: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
	if (reset) begin
	present_state <= 0;
	next_state <= 0;
	end
else begin
	present_state <= next_state;
	end
end
// always block for output
always @(posedge clk, posedge reset)
begin
	if (reset) begin
	out <= 0;
	end
else begin
	case (present_state)
	0: if (in) begin
	next_state <= 1;
	out <= 0;
	end
	else begin
	next_state <= 0;
	out <= 0;
	end
	1: if (in) begin
	next_state <= 1;
	out <= 0;
	end
	else begin
	next_state <= 0;
	out <= 1;
	end
================================================================
example-8: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or reset)
if (reset)
present_state <= 0;
else
present_state <= next_state;
// Next state logic
always @(present_state or in)
case (present_state)
0 : next_state <= in ? 0 : 1;
1 : next_state <= in ? 0 : 1;
endcase
// Output logic
assign out = (present_state == 1) && (next_state == 0);

================================================================
example-9: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter s0=0, s1=1;
always @(posedge clk or negedge reset)
begin
if(!reset)
present_state <= s0;
else
present_state <= next_state;
end
always @(present_state or in)
begin
// We dont have an if statement in Verilog, use case statement 
// A combinational logic block, such as a case statement is a combinational logic block. 
// The case statement lets you make decisions in your code based on specific input conditions. 
case(present_state)
s0:begin
if(in)
next_state = s1;
else
next_state = s0;
end
s1:begin
if(in)
next_state = s1;
else
next_state = s0;
end
endcase
end
always @(
================================================================
example-10: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk or negedge reset)
begin
if(~reset)
present_state <= 0;
else
present_state <= next_state;
end
always @ (*)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 1 : 0;
default: next_state <= 0;
endcase
end
assign out = (present_state == 1) & (next_state == 0);

================================================================
example-11: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

always @(posedge clk, posedge reset)
if (reset)
present_state <= {1'b0};
else
present_state <= next_state;

always @(present_state, in)
case (present_state)
0: next_state = in ? 0 : 1;
1: next_state = in ? 1 : 0;
default: next_state = present_state;
endcase

assign out = (present_state == 1) && (next_state == 0);

================================================================
example-12: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
 if(reset)
 present_state <= 0;
 else
 present_state <= next_state;
end
always @(present_state, in)
begin
 case(present_state)
 0: next_state <= in ? 0 : 1;
 1: next_state <= in ? 1 : 0;
 endcase
end
always @(present_state)
begin
 case(present_state)
 0: out = 0;
 1: out = 0;
 endcase
end

================================================================
example-13: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(in, present_state)
case (present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 1 : 0;
default: next_state <= 1'bx;
endcase
assign out = (present_state == 0);

================================================================
example-14: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next_state=in
assign present_state = 0;
// next_state=in
// next_state=next_state
always @(posedge clk or posedge reset)
if (reset)
present_state <= 0;
else
present_state <= next_state;
// next_state=next_state
always @(present_state or next_state or in)
begin
case(present_state)
0:
	begin
	if(next_state == 1)
	out = 1;
	else
	out = 0;
	end
1:
	begin
	if(next_state == 0)
	out = 1;
	else
	out = 0;
	end
endcase
end

================================================================
example-15: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state, in)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 0 : 1;
endcase
end
// output logic
assign out = (present_state == 1) && (next_state == 0);

================================================================
example-16: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or reset or in)
begin
if(reset==1) begin
	present_state<=0;
	next_state<=0;
	end
else begin
	present_state<=next_state;
	end
end
always @(present_state or in or next_state)
begin
case(present_state)
	0: begin
	if(in==1) next_state<=1;
	else next_state<=0;
	end
	1: begin
	if(in==1) next_state<=0;
	else next_state<=1;
	end
endcase
end

================================================================
example-17: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
	if (reset)
	begin
	present_state <= 0;
	next_state <= 0;
	end
	else
	begin
	present_state <= next_state;
	end
end
always @(in or present_state)
begin
case (present_state)
	0 : next_state <= in ? 1 : 0;
	1 : next_state <= in ? 1 : 0;
	default : next_state <= 0;
endcase
end
assign out = (present_state == 1);

================================================================
example-18: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state or in)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 0 : 0;
default: next_state <= 0;
endcase
end
always @(present_state or in)
begin
case(present_state)
0: out <= 0;
1: out <= 0;
default: out <= 0;
endcase
end

================================================================
example-19: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk)
begin
if (reset) present_state <= 0;
else present_state <= next_state;
end
always @ (*)
begin
case (present_state)
0: if (in) next_state = 1;
else next_state = 0;
1: if (in) next_state = 0;
else next_state = 1;
endcase
end
assign out = (present_state == 1);

================================================================
example-20: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
	if (reset == 1)
	begin
	present_state <= 0;
	next_state <= 0;
	end
	else
	present_state <= next_state;
end
always @(present_state, in)
begin
case(present_state)
	0: next_state <= in ? 0 : 1;
	1: next_state <= in ? 0 : 1;
	default: next_state <= 0;
endcase
end
always @(present_state)
begin
case(present_state)
	0: out <= 0;
	1: out <= 0;
	default: out <= 1;
endcase
end

================================================================
example-21: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(*)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 0 : 0;
default: next_state <= present_state;
endcase
end
assign out = present_state == 1;

================================================================
example-22: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// This is a Moore state machine
always @(posedge clk)
if (reset)
present_state <= 0;
else
present_state <= next_state;

always @(*)
if (reset)
next_state <= 0;
else
case (present_state)
0: next_state <= 0;
1: next_state <= 1;
default: next_state <= 0;
endcase

always @(*)
case(present_state)
0: out <= 0;
1: out <= 1;
default: out <= 0;
endcase


================================================================
example-23: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter s0=0, s1=1;
// States
always @(posedge clk)
	if(reset) present_state <= s0;
	else present_state <= next_state;
always @(present_state)
	case(present_state)
	s0: begin
	if(in) next_state <= s1;
	else next_state <= s0;
	end
	s1: begin
	if(in) next_state <= s0;
	else next_state <= s1;
	end
	endcase
assign out = (present_state == s1);

================================================================
example-24: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// State change logic
always @(posedge clk or posedge reset)
begin
if (reset == 1)
present_state <= 0;
else
present_state <= next_state;
end
// Next state logic
always @(present_state or in)
case (present_state)
0:
begin
if (in == 1)
next_state <= 1;
else
next_state <= 0;
end
1:
begin
if (in == 0)
next_state <= 0;
else
next_state <= 1;
end
default:
next_state <= 0;
endcase
// Output logic
assign out = (present_state == 1) && (next_state == 1);

================================================================
example-25: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
	if (reset)
	begin
	present_state <= 0;
	next_state <= 0;
	end
	else 
	present_state <= next_state;
end
parameter s0 = 0, s1 = 1;
always @(present_state or in)
begin
case (present_state)
	s0 : if (in) next_state = s1;
	s1 : if (in) next_state = s1;
	default : next_state = s0;
endcase
end
assign out = (present_state == s1);

================================================================
example-26: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next_state=in in state 0, & next_state=in in state 1
always @(posedge clk or negedge reset)
begin
if(!reset)
present_state<=0;
else
present_state<=next_state;
end
always @(present_state or in)
begin
case(present_state)
0: next_state<=in?1:0;
1: next_state<=in?1:0;
endcase
end
assign out=present_state?0:1;

================================================================
example-27: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
if (reset) begin
present_state <= 0;
next_state <= 0;
end else begin
present_state <= next_state;
end
always @(present_state or in)
case (present_state)
0 : begin
if (in) next_state <= 1;
else next_state <= 0;
end
1 : begin
if (in) next_state <= 0;
else next_state <= 1;
end
default : next_state <= 0;
endcase
end
assign out = (present_state == 1);

================================================================
example-28: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// combinational logic
always @(posedge clk)
begin
	if (!reset)
	present_state <= 0;
	else
	present_state <= next_state;
end

// Next state and output assignment
always @(present_state or in)
begin
	case (present_state)
	0 : next_state <= in ? 0 : 1;
	1 : next_state <= in ? 0 : 1;
	default : next_state <= 0;
	endcase
end

// Output
assign out = (present_state == 1) && (next_state == 0);

================================================================
example-29: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state, in)
begin
case(present_state)
0: next_state = in ? 0 : 1;
1: next_state = in ? 0 : 0;
default: next_state = 0;
endcase
end
always @(present_state)
begin
case(present_state)
2'b00: out = 0;
2'b01: out = 0;
2'b10: out = 1;
default: out = 0;
endcase
end

================================================================
example-30: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
	if(reset)
	present_state <= 0;
	else
	present_state <= next_state;
end
// next_state logic
always @(present_state or in)
begin
	case(present_state)
	0:
	if(in)
	next_state <= 1;
	else
	next_state <= 0;
	1:
	if(in)
	next_state <= 1;
	else
	next_state <= 0;
	default:
	next_state <= 0;
	endcase
end
// output logic
always @(present_state)
	case(present_state)
	0: out <= 0;
	1: out <= 1;
	endcase

================================================================
example-31: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
if(reset==1)
present_state<=0;
else
present_state<=next_state;
end
always @(present_state, in) begin
case(present_state)
0: begin
if(in==1)
next_state<=1;
else
next_state<=0;
end
1: begin
if(in==1)
next_state<=1;
else
next_state<=0;
end
default: next_state<=0;
endcase
end
always @(present_state) begin
case(present_state)
0: out=0;
1: out=0;
endcase

================================================================
example-32: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign present_state = 0;
assign next_state = 0;
always@(posedge clk)
begin
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end

================================================================
example-33: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// present_state = 0 or 1; next_state = 0 or 1;
always @(posedge clk)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
// next_state = present_state;
// Assignment 2: Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// present_state = 0 or 1; next_state = 0 or 1;
always @(posedge clk)
begin
if(reset
================================================================
example-34: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
	if (reset == 1'b1) begin
	// reset is high, set all to initial states.
	present_state <= 1'b0;
	next_state <= 1'b0;
	end
	else begin
	present_state <= next_state;
	end
end
always @(present_state or in) begin
	case (present_state)
	1'b0: next_state <= in ? 1'b0 : 1'b1;
	1'b1: next_state <= in ? 1'b1 : 1'b0;
	endcase
end
assign out = (present_state == 1'b1);

================================================================
example-35: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk)
	if(reset)
	present_state <= 0;
	else
	present_state <= next_state;
always@(present_state)
case(present_state)
	0:	next_state <= in ? 0 : 1;
	1:	next_state <= in ? 1 : 0;
endcase
// Output
assign out = (present_state == 1) ? 1 : 0;

================================================================
example-36: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
 if (reset)
 present_state <= 0;
 else
 present_state <= next_state;
// next state
always @(present_state, in)
 case (present_state)
 0: next_state <= in ? 0 : 1;
 1: next_state <= in ? 1 : 0;
 endcase // case (present_state)
// out=1 in state 0 and out=0 in state 1

================================================================
example-37: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end
// next_state logic
always @(*)
case (present_state)
0: begin
if (in)
next_state <= 0;
else
next_state <= 1;
end
1: begin
if (in)
next_state <= 1;
else
next_state <= 0;
end
default:
next_state <= 0;
endcase
// out=1 in state 0 and out=0 in state 1
assign out = (present_state==0) & (present_state==1);

================================================================
example-38: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always@(present_state or in)
begin
case(present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 1 : 0;
endcase
end
assign out = (present_state == 1);

================================================================
example-39: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
if(reset)
present_state <= 1'b0;
else
present_state <= next_state;
// Next state assignment
always @(present_state or in)
case(present_state)
0: begin
	if(in == 1'b1)
	next_state <= 1'b0;
	else
	next_state <= 1'b1;
	end
1: begin
	if(in == 1'b0)
	next_state <= 1'b1;
	else
	next_state <= 1'b0;
	end
default:
	next_state <= 1'b0;
endcase
// Output out assignment
assign out = (present_state == 1'b0) ? 1'b1 : 1'b0;

================================================================
example-40: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(posedge present_state or posedge reset)
begin
if(reset)
next_state <= 0;
else
begin
case(present_state)
0:
begin
if(in)
next_state <= 0;
else
next_state <= 1;
end
1:
begin
if(in)
next_state <= 1;
else
next_state <= 0;
end
default:
next_state <= 0;
endcase
end
end
assign out = (present_state == 1);

================================================================
example-41: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
if(reset)
present_state <= 0;
else
present_state <= next_state;
// Next state
always @(present_state or in)
case (present_state)
0: next_state<=in ? 0 : 1;
1: next_state<=in ? 1 : 0;
default: next_state<=0;
endcase
// Output present state
assign out = present_state;

================================================================
example-42: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state or in)
begin
case(present_state)
0: next_state = in ? 0 : 1;
1: next_state = in ? 0 : 0;
endcase
end
always @(present_state or in)
begin
case(present_state)
0: out = 1;
1: out = 0;
endcase
end

================================================================
example-43: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter s0=0, s1=1;
// State transition logic
always @(posedge clk, posedge reset)
if (reset) 
present_state <= s0;
else 
present_state <= next_state;
// Moore FSM
always @(present_state, in)
case (present_state)
s0: if(in) next_state = s1;
s1: if(in) next_state = s0;
default: next_state = s0;
endcase

================================================================
example-44: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter s0=0, s1=1;
always @(posedge clk or posedge reset)
begin
	if (reset)
	begin
	present_state <= s0;
	next_state <= s0;
	end
	else
	begin
	case (present_state)
	s0:
	begin
	if (in)
	begin
	next_state <= s1;
	end
	else
	begin
	next_state <= s0;
	end
	end
	s1:
	begin
	if (in)
	begin
	next_state <= s1;
	end
	else
	begin
	next_state <= s0;
	end
	end
	endcase
	end
assign out = (present_state == s1);

================================================================
example-45: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
	if (reset)
	present_state <= 0;
	else
	present_state <= next_state;
always @(present_state, in)
case (present_state)
0: next_state <= (in)? 1 : 0;
1: next_state <= (in)? 0 : 1;
endcase

================================================================
example-46: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next state assignment
// Moore FSM
// present state = next state
always @(posedge clk)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state or in)
case (present_state)
0: begin
next_state = in ? 0 : 1;
end
1: begin
next_state = in ? 0 : 1;
end
default:
next_state = present_state;
endcase

================================================================
example-47: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter state_0=0, state_1=1;
always @(posedge clk)begin
if(reset) present_state <= state_0;
else present_state <= next_state;
end
always @(present_state, in)begin
case(present_state)
state_0:
	if(in) next_state = state_1;
	else next_state = state_0;
state_1:
	if(in) next_state = state_0;
	else next_state = state_1;
default:
	next_state = state_0;
endcase
end
assign out = (present_state == state_1);

================================================================
example-48: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign next_state = (reset) ? 0 : ((in) ? 1 : present_state);
always @(posedge clk)
begin
if (reset)
present_state <= 0;
else
present_state <= next_state;
end
// observer

================================================================
example-49: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
if (reset)
present_state <= 0;
else
present_state <= next_state;
// Next state
always @(present_state, in)
case (present_state)
0: next_state <= in ? 0 : 1;
1: next_state <= in ? 1 : 0;
default: next_state <= present_state; // no change to present state
endcase
// out
assign out = (present_state == 1) && (next_state == 0);

================================================================
