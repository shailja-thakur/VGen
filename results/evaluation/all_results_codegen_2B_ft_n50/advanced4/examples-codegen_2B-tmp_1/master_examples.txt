example-0: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
case (amount)
	2'b00: q <= {data[31:0], 16'h00000000};	// Left shift by 1 bit.
	2'b01: q <= {data[55:32], 24'h00000000}; // Left shift by 8 bit
	2'b10: q <= {data[63:56], 32'h00000000}; // Right shift by 1 bit.
	2'b11: q <= {q[0], data[63:32]};	// Right shift by 8 bit
endcase

================================================================
example-1: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	reg [63:0] temp; 
	
	always @(*) begin
	
	case (amount)
	
	2'b00: temp = q << 1;
	2'b01: temp = q << 8;
	2'b10: temp = q >> 1;
	2'b11: temp = q >> 8;
	default: temp = q[63:0];
	endcase
 	// if shift left, clear q from right.
	// if shift right, leave q alone.
	if (load) q = data;
	// if ena, shift the q without aalusators.
	else begin
	// if ena is high, assert
	if (ena) q <= temp;
	end
	end
	

================================================================
example-2: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.



always @(posedge clk)
begin
	if(load)
	begin
	q <= data;
	end
	else if(ena)
	begin 
	case(amount)
	2'b00: begin 
	q <= { q[62:0], 1'b0 };
	end
	2'b01: begin 
	q <= { q[63:1], q[62:0] };
	else if(q[63] == 1'b0) 
	begin
	q <= Q_1 + 1'b1 * { q[63:1] , q[62:0] };
	end
	end
	2'b10: begin
	q <= { q[63:0], 8'b0 };
	end
	2'b11: q <= q >> 1;
always @(q
================================================================
example-3: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if (load) begin
	case(amount)
	2'b00: q <= data ;
	2'b01: q <= { 1'b0, data[63:1] }; 
	2'b10: q <= { data[63], data[62:0] };	
	2'b11: q <= { data[0] };	
	endcase
	

end
if (ena) begin
	q <= { q[62:0], 1'b0 };


end
end

================================================================
example-4: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk)
 begin
 if(load) begin
	q <= data;
 end
 if(ena) begin
	if(amount[1]) begin
	case(amount[0])
	0:	q <= q << 8'd1;	
	1:	q <= q << 8'd1;	
	2:	q <= q << 8'd8;	
	3:	q <= q << 8'd8;	
	endcase
	end
	else
	case(amount[0])
1:	q <= q << 1'd1;	
2:	q <= q << 8'd1;	
3:	q <= q << 1'd1;	
4:// this is not implemented
//	2'd2: q<= q >> 2'd8;// q<= q >> 2'd8;
//	2'd3:
================================================================
example-5: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk)
 if (load) q = data;
 always @ (ena)
 if (ena)
 if (amount == 2'b00) q = q << 1;
 if (amount == 2'b01) q = q << 8;
 if (amount == 2'b10) q = q >> 1;
 if (amount == 2'b11) q = q >> 8;

================================================================
example-6: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// ***********************************************************************************************************************
// * Design - Data Type Comments easier At the start of the assignment*
// ***********************************************************************************************************************
	reg [63:0] RegData; // in the diagram, here is the status 
	reg [63:0] ShiftLeft;
	reg [63:0] ShiftRight;
	reg [63:0] Ans; // Declaring another Reg to use inside the always blocks
	
	initial 
	begin
	 
	reg [63:0] Datain; // assigning same data to each 
	
	ShiftLeft[63:0] = 8'b00000000; // assign 0 to ShiftLeft
	ShiftRight[63:0] = 8'b00000000; // assign 0 to shiftright 
	
	
	RegData <= 0; // assign 11223345 low to RegData
	
	
	end

================================================================
example-7: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin
	
	if	(ena)
	begin 
	
	if (load == 1)
	
	// when load line high, load d[63:0] into the register
	q <= data[63:0];
	
	else begin
	
	if (amount == 2'b00)
	begin
	q <= q << 1;
	end 
	
	else if (amount == 2'b01)
	begin
	q <= q << 7;
	end
	
	else if (amount == 2'b10)
	begin
	q <= q >> 1;
	end
	
	else if (amount == 2'b11)
	begin
	q <= q >> 7;
	end
	end
	
	else q <= q;
	
	end
================================================================
example-8: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
	if (load) begin
	q <= data;
end
	else if (ena) begin
	case (amount)
	2'b00:begin
	q <= {q[62:0], 1'b0};
end 
	2'b01:begin 
	q <= {q[62:0], 1'b1};
end
	2'b10:begin
	q <= {q[63], q[63:1]};
end
	2'b11:begin
	q <= {q[63], q[63:1]};
end
	endcase
	end
 else
	q <= q;
end


================================================================
example-9: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk or posedge load)
	begin
	if (load)
	q <= data;
	else begin
	//if you choose the load command, the q value will stay constant.
	q <= {q[62:0][63], {amount == 3'd0? q[63]: q[63:1]}};
	end
end

================================================================
example-10: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.



always@(posedge clk)
begin
case({amount, load})
2'b00: ?q <= {data[0], q[63:1]};
2'b01: ?q <= {q[62:0], data[63:1]};
2'b10: ?q <= {q[63-:8], data[63:8]};
2'b11: ?q <= {q[63-:16], data[63:16]};
default: ?q <= q;
endcase
if (load) q <= data;
else if (ena) begin

end

================================================================
example-11: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk) begin
	case (amount)
4'b0000:
q<={{amount},data[63:8]};
4'b1111:
q<=data>>8;
4'b0010:
q<={8'b0,data[15:0]};
4'b1100:
q<={data[31:0],{amount},8'b0};
4'b1010:
q<={{amount},data[63:0]};
4'b0110:
{amount,data[63:8]}<={{amount},data[63:8]};
4'b0011:
{amount,data[63:8]}<={8'b0,data[15:0]};
default:


endcase
	end

================================================================
example-12: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
 if (load || ena)
 q <= data;
end 


================================================================
example-13: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
if (load) 
q <= data;
else if (ena) begin
case(amount)
2'b00:
q <= {q[62:0], 1'b0};
2'b01:
q <= {q[60:0], 2'b0};
2'b10:
q <= {q[56:0], 4'b0};
2'b11:
q <= {q[54:0], 6'b0};
endcase
end
end

================================================================
example-14: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@ (posedge clk)
begin
if (load) 
q <= data;
else if (ena)
begin
if (amount == 2'b00)
q <= {q[62:0], 1'b0};
if (amount == 2'b10)
q <= {q[62:0], q[63]};
if (amount == 2'b01)
q <= {q[63:1]};
if (amount == 2'b11)
q <= {q[63:8], 1'b0};
end
end


================================================================
example-15: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk) begin
 if (load) 
 q <= data;
 else if (ena) begin
 if (amount == 2'b00) 
 q <= {{4{q[63]}},q[63:1]};
 if (amount == 2'b01)
 q <= {{8{q[63]}},q[63:1]};
 if (amount == 2'b10)
 q <= {{4{q[63]}},q[63:8]};
 if (amount == 2'b11)
 q <= {{8{q[63]}},q[63:8]};
 end
 end
 endmodule
module top_tb();
reg clk, load_, ena;
reg[4:0] amount;
reg signed [63:0] data;
wire [63:0] q;
top UUT(clk
================================================================
example-16: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk)
	begin
	if (load)
	begin 
	q<= data[63:0];
	end
	else if (ena) 
	begin
	case (amount) 
	2'b00:begin
	q<={q[62:0],1'b0};
	end
	2'b01:begin
	q<={q[63],q[63:1]};
	end
	2'b10:begin
	q<={q[60],q[63:2]};
	end
	2'b11:begin
	q<={q[56],q[63:4]};
	end
	endcase
	end
	end

================================================================
example-17: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	
reg [4:0] direction;
reg [5:0] amount_backup;

	always @(*) begin
	case(amount)
	6'b000000: direction = 2'b00;
	6'b000001: direction = 2'b01;
	6'b000010: direction = 2'b10;
	6'b000011: direction = 2'b11;
	6'b000100: direction = 2'b00;
	6'b000101: direction = 2'b00;
	6'b000110: direction = 2'b00;
	6'b000111: direction = 2'b00;
	6'b001000: direction = 2'b00;
	6'b001001: direction = 2'b00;
	6'b001010: direction = 2'b00;

================================================================
example-18: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @*
begin
case(amount)
2'b00:
q <= q << 1;
//: clk;

2'b01:
q <= q >> 8;
//: clk;

2'b10:
q <= q >>> 1;
//: clk;

2'b11:
q <= q >>> 8;
//: clk;

endcase
end



================================================================
example-19: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
case (amount) 
2'b00: begin if (ena)
if (load)
q <= data;
else
q <= {q[62:0], 1'b0};
end

2'b01: begin if (ena)
q <= q[63:8];
else
q <= {8'h00, q[63:1]};
end 

2'b10: begin if (ena)
q <= {q[56:0], 8'h00};
else
q <= {q[63:56], q[57]};
end

2'b11: begin if (ena)
q <= q[63:56];
else
q <= {q[63:56], 4'h0};
end

default:;

endcase
end

================================================================
example-20: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @ (posedge clk)
if (load || ena)
 q <= data;
 
always @ (amount)
 case(amount) 
 0: q <= {q[63:1], q[0]}; 
 1: q <= {1'b0, q[63:1]};
 2: q <= {{8{q[63]}}, q[63:1]}; 
 3: q <= {{7{q[63]}}, q[63:1]}; 
 endcase
 

================================================================
example-21: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin

if(load) begin
q <= data;
end else if(ena) begin
if (amount == 2'b00) begin
q <= {q [63:0], 1'b0};
end

else if (amount == 2'b01) begin
q <= {q [63:0], 8'b0};
end

else if (amount == 2'b10) begin
q <= {q [63:0], 4'h0};
end

else if (amount == 2'b11) begin
q <= {q [63:0], 2'b0};
end

else begin
q <= q;
end

end else begin
q <= q;
end




end
 

================================================================
example-22: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


	always @(posedge clk)
	begin
	if (load)
	q<=data;
	else if(ena)
	begin
	if(amount==2'b00)
	q<={1'b0,q[63:1]};
	
	else if(amount==2'b01)
	q<={1'b0,q[63:1]};
	else if(amount==2'b10)
	q<={q[62:0],1'b0};
	else if(amount==2'b11)
	q<={q[0],1'b0};
	else
	q<=64'b0;
	end
	
	end
	
	
================================================================
example-23: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
//----------------------------------------------------------------------------------
// The shifter, with asynchronous loads and enable.
//----------------------------------------------------------------------------------

reg [63:0] s1,s2,s3,s4;

always @(posedge clk, posedge load)
 begin
	if(load) 
	q <= data; 
	else begin
	case(amount)
	2'b00:
	begin
	s1 <= q;
	s2 <= s1 << 1;
	end
	2'b01:
	begin
	s1 <= q;
	s2 <= s1 >> 1;
	end
	2'b10:
	begin
	s2 <= q <<< 8;
	end
	2'b11:
	begin
	s2 <= q >>> 8;
	end
	endcase
	q <= s2; 
================================================================
example-24: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk)
 begin: Shift
 case ({amount, load, ena})
 3'b100:
 begin
 if (load)
 q<=data;
 else
 begin
 case ({amount}) //Choose high or low amount
 2'b00: q<={1'b1, q[62:1]}; //When 'amount' is 00, shift left.
 2'b01: begin
 q={q[62:8], q[7:0], q[1:0]}; //When 'amount' is 01, shift left, and place higher 2 bits into lower 2 bits.
 q=q>>1; //Shift to the right.
 end
 2'b10: q={q[56:0], q[63:56]}; //When 'amount' is 10, shift right.
 2'b11: q={q[56:56], q
================================================================
example-25: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@ (posedge clk)
begin
	if(load)
	begin
//	{{q[63:8]}, 	{q[7:0],	qd}} <= {{data[63:8]}, {data[7:0],	data}, q, ena, 1'b1};
//	{{q[7:0]}, 	{q[63:8]}, {qd[63:8],	qd}} = {{q[63]}, {q[62:0]}, qd, {qd[7:1]}, 1'b1};
	begin
	q <= {data[63:0],	data[63:0]};
	qd <= {data[64], data[63:1]};
	end
	end
	else begin
if(ena)
q <= q << amount;

================================================================
example-26: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	reg [63:0] q2 = 0;

	
	always @ (posedge clk) 
	begin
	
	if (load) 
	begin 
	q <= data;
	end
	else if (ena) 
	begin 
	
	if (amount == 2'b00) 
	begin
	q2 <= {q[63:1], q[0]};
	end
	if (amount == 2'b01) 
	begin 
	
	q2 <= {{q[63:8]), q[7:0]};
	end
	if (amount == 2'b10) 
	begin
	
	q2 <= {{q[63:56]), q[55:0]};
	end 
	if (amount == 2'b11)
	begin
	
	q2 <=
================================================================
example-27: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	if (load == 1'b1) begin
	q <= data;
	end
	else if (ena == 1'b1) begin
	case (amount)
	2'b00: begin
	 q <= {q[62:0],1'b0};
	end
	2'b01: begin
	 q <= {q[60:0],2'b0};
	end
	2'b10: begin
	 q <= {q[55:0],4'b0};
	end
	2'b11: begin
	 q <= {q[50:0],8'b0};
	end
	endcase
	end

================================================================
example-28: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk) 
begin
if(load)
	q <= data;
if(ena)
	begin
	case(amount[1:0])
	2'b00: q <= q << 1'b1;
	2'b01: q <= q << 8'b1;
	2'b10: q <= q >> 1'b1;
	2'b11: q <= q >> 8'b1;
	endcase
	end
end

================================================================
example-29: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// Shift is ALWAYS asynchronous, but load and shift are synchronized so that loads with ena.
always @(posedge clk)
begin
	if (load)
	begin
	q <= data;
	end
	else begin
	if (ena)
	begin
	case (amount)
	1'd0: begin 
	q <= q << 1; 
	end
	1'd1: begin 
	q <= q << 8; 
	end
	1'd2: begin 
	q <= q >> 1; 
	end
	1'd3: begin 
	q <= q >> 8; 
	end
	endcase
	end
end
	
end
	

================================================================
example-30: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin
	if(ena)
	begin
	/*
	if (load)
	begin
	 	q <= data; 	// load data into shifter
	end */
	case (amount)
	2'b00: q <= {data[55:0], 8'b00000000}; 
	2'b01: q <= {data[63:56], 8'b00000000}; 
	2'b10: q <= {data[71:64], 8'b00000000}; 
	2'b11: q <= {data[79:72], 8'b00000000}; 
	endcase
	end

================================================================
example-31: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
begin

	if (load)	
	begin
	q <= data;
	end
	else if (ena)
	begin
	case (amount)
	2'b00:	q <= q << 1;
	2'b01:	q <= q << 8;
	2'b10:	q <= q >> 1;
	2'b11:	q <= q >> 8;	
	endcase
	end
end


================================================================
example-32: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	reg [63:0] leftshift_d;

	always @(posedge clk) 
	begin
	if(load)
	data <= data >> amount;
	else
	begin
	if(ena)
	begin
	case(amount)
	2'b00:
	leftshift_d <= data << 1;
	2'b01:
	leftshift_d <= data >> 8;
	2'b10:
	leftshift_d <= (data >> 1) >> (63 - amount);
	2'b11:
	leftshift_d <= (data >> 8) >> (63 - amount);
	endcase
	end
	else
	leftshift_d <= data;
	q<=leftshift_d;
	end
	end
	assign q=leftshift_d;

================================================================
example-33: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


 
always @(posedge clk) begin
	if(load) begin
	q <= data;
	end 
	else if(ena) 
	begin
	
	case(amount)
	2'b00: q <= {q[62:0], 1'b0};
	2'b01: q <= {1'b0, q[63:1]};
	2'b10: q <= {q[56:0], 8'b0};
	2'b11: q <= {8'b0, q[63:8]};
	endcase
	end
	end

================================================================
example-34: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	if(load)
	begin
	q<=data;
	end
	
	else if(ena)
	begin
	case(amount)
	2'b00:
	begin
	q=q<<1;
	end
	2'b01:
	begin
	q=q<<8;
	end
	2'b10:
	begin
	q=q>>1;
	end
	2'b11:
	begin
	q=q>>8;
	end // endcase
	end // end else
end // end always

================================================================
example-35: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if (load)
	begin
	q <= data;
	end
	else if (ena)
	begin
	if (amount == 2'b00)
	q <= q << 1'b1;
	else if (amount == 2'b01)
	q <= q << 8'b1;
	else if (amount == 2'b10)
	q <= q >> 1'b1;
	else if (amount == 2'b11)
	q <= q >> 8'b1;
	end	
end

================================================================
example-36: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
 if (load)
 begin
 q <= data;
 end
 else if (ena)
 begin
 case(amount)
 2'b00:
 begin
 q = {q[62:0], 1'b0};
 end
 2'b01:
 begin
 q = {q[60:0], 2'b0};
 end
 2'b10:
 begin
 q = {q[56:0], 4'b0};
 end
 2'b11:
 begin
 q = {q[48:0], 8'b0};
 end
 default:
 begin
 end
 endcase
 end else
 q <= q;
end 

================================================================
example-37: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if (load)
q <= data;
else if (ena)
q <= {q[62:0], 1'b0}; // We first shift from both left and right, followed by inserting right most bit.
end

================================================================
example-38: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// shift on ena, with amount == 0
	always @(posedge clk) begin
	 
	if(ena) begin
	
	
	case(amount)
	
	// 2'b00: {q[63:48], q[47:0]} = {data[63:48], data[47:0]};
	// q[47] = data[63];
	// q[46] = data[62];
	// q[45] = data[61];
	// q[44] = data[60];
	// q[43] = data[59];
	// q[42] = data[58];
	// q[41] = data[57];
	// q[40] = data[56];
	// q[39] = data[55];
	// q[38] = data[54];
================================================================
example-39: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk) begin
 if (load) 
 q <= data;
 else if (ena) begin
 if (amount == 2'b00)
 q <= {q[62:0], q[63];
 if (amount == 2'b01)
 q <= {q[59:0], q[63:1], q[63]};
 if (amount == 2'b10)
 q <= {q[51:0], q[63:2], q[63]};
 if (amount == 2'b11)
 q <= {q[43:0], q[63:3], q[63]};
 end
 else if (amount == 2'b00)
 q <= {q[63], q[63:1], q[63:2]};
 if (amount == 2'b01)
 q <= {q[63], q[63:
================================================================
example-40: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin 
	if (load) q <= data;	// if load is high, load data at register q.
	else 
	begin
	if (ena) begin
	case (amount)
	2'b00: q <= {q[62:0], 1'b0};	// Shift left by 1 bit.
	2'b01: q <= {q[0], q[63:1]};	// Shift left by 8 bits.
	2'b10: q <= {q[63], q[62:0]};	// Shift right by 1 bit;
	2'b11: q <= q;	// If we haven't shifted, just assign q to itself.
	endcase
	end
	end

================================================================
example-41: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load) begin
	// load data into q.
	case(amount) 
	0: q <= data;
	1: q <= {ryptime{1'b0}};
	2: q <= {{64-1{1'b0}}, data[63:1]};
	3: q <= {{63-8{1'b0}}, data[63:8]};
	endcase
	end else if (ena) begin
	// shift q.
	case(amount) 
	0: q <= {{amount{1'b0}}, q[62:1]};
	1: q <= {{amount{1'b0}}, q[63:0]};
	2: q <= {{amount{1'b0}}, q[63:1]};
	3
================================================================
example-42: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
	if (load) begin 
 	end 
 	else if (ena ) begin 
 	 	 	if (amount==2'b00) q <= {1'b0,data[63:1]};
	 	 	if (amount==2'b01) q <= {1'b1,data[63:0]};
	 	 	if (amount==2'b10) q <= {data[0],user_defined(data[63:1], 1'b0, 1'b0, 1'b0, data[31:0], 1'b0, 1'b0, 1'b0, q[63:1])};
	 	 	if (amount==2'b11) q <= {user_defined(data[63:0], 1'b
================================================================
example-43: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	if(ena)
	begin
	//if load is high, assign data[63:0] to this shift register.
	if(load) q <= data;
	else
	//when ena is high, shift q.
	if(ena)
	begin
	//if shift left is chosen ...
	if(amount == 2'b00)
	// ... shift left 1 bit
	q <={q[62:0], 1'b0};
	//if shift right is chosen ...
	else if(amount == 2'b01)
	// ... shift right 8 bits
	q <={q[63], q[63:1]};
	//if shift left is chosen ...
	else if(amount == 2'b10)
	// ... shift right 1 bit
	q <={q[63], {
================================================================
example-44: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin
	if (load)
	begin
	q <= data;
//	$display("in advshift.Load is asserted high.");
	end
	else if (ena)
	begin
	case (amount)
	2'b00:
	q <= {q[62:0], 1'b0};
	2'b01:
	q <= q << 8'd1;
	2'b10:
	q <= q << 8'd8;
	2'b11:
	q <= q >> 8'd8; 
	{q[63], q[63:1]} :
	q <= q >> 8'd1;
	endcase
	end
	else
	begin
	q <= q;
//	$display("in advshift.ena is low.");
	end
	
================================================================
example-45: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// special shift amount of 0 chooses q
always@(posedge clk) begin
if (load) q <= data[63:0];
else if (ena) 
case(amount)
0: q <= {q[62:0], q[63]};
1: q <= {q[61:0], q[62]};
2: q <= {q[59:0], q[60]};
3: q <= {q[57:0], q[58]};
4: q <= {q[55:0], q[56]};
5: q <= {q[53:0], q[54]};
6: q <= {q[51:0], q[52]};
7: q <= {q[49:0], q[50]};
8: q <= {q[47:0], q[48]};
9:
================================================================
example-46: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always@ (posedge clk) begin
 if(load)
	q<=data[63:0];
 else if(ena)begin
	case(amount)
	2'b00: q<={q[62:0], 1'b0};
	2'b01: q<=q>>8;
	2'b10: q<=q>>1;
	2'b11: q<={{64{q[63]}}, q[63:1]};
	endcase
	end
 end

================================================================
example-47: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
if (load) begin // load or load and ena.
assign q = data; // Load data
else if (ena)
 begin // if ena high, register is not empty.
 case(amount)
 0:
 q = {q[62:0], 1'b0};
 1:
 q = {q[58:0], 2'b00};
 2:
 q = {q[50:0], 4'b0000};
 3:
 q = {q[42:0], 8'b00000000};
 default:
 q = q;
 endcase
 end
 else
 q = q; // No changes.
 end // always @ (posedge clk)

================================================================
example-48: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk)
	begin
	if(load)
	q<=data;
	else
	q<={q[62:0], q[63]};
	end
	
	always @(posedge clk or negedge clk)
	if(ena) 
	begin
	if(amount==0)
	q<={q[0], q[63]};
	
	if(amount==1)
	q<={{8{q[63]}} , q[63:1]};
	
	if(amount==2)
	q<={{16{q[63]}} ,q[63:2]};
	
	end
	
	
	
	
	
	

================================================================
example-49: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk) begin
	if (load) begin
	// q <= data;
	Alex_system_a_r <= data;
	end
	if (ena) begin
	case (amount)
	2'b00: begin q <= { q[62:0], 1'b0 }; end
	2'b80: begin q <= { q[36:0], 8'b0, q[63:39] }; end
	2'b01: begin q <= { q[56:9], q[63:37] }; end
	2'b81: begin q <= { q[15:1], q[63:58] }; end
	2'b10: begin q <= { q[24:5], q[63:50] }; end
	2'b82: begin q <= { q[31:1], q[63
================================================================
