example-0: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk, posedge reset)
begin
	if (reset) r_reg <= 1'b1;
	else r_reg <= r_next;
end
assign q = r_reg;
assign r_next = {r_reg[1:0], r_reg[3:2]^reset};
wire [3:0] feedback_wire = r_next[3:1]_inv ^ r_reg[4];
//wire q_and_routput_sum;
assign feedback_value = (r_reg[4]^reset) ? 
back_porch :
(r_reg[4]^reset) ? ((feedback_wire[2]^feedback_wire[1])^feedback_wire[3]) : 
back_porch;

================================================================
example-1: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk or posedge reset) begin
	if (reset) begin
	{r_reg} = 5'b0000;
	end
	else begin
	{r_reg} = {r_int};
	end
end
assign r_next = {r_reg} ^ ({1'b0} ^ ({7'b0_3b_2a_41_32_18_01_00_00_0f_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00_00
================================================================
example-2: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset)? 1 : (q == 5'b00000) ? {3'h1,feedback_value} : r_reg;
assign q = r_reg;
always @(posedge clk, posedge reset) begin
	if (reset) begin
	 	r_reg <= 5'b00000;
	end else begin
	 	// if q == 5'b00000 and the left bit is 1111 then set
	 	// the feedback value to be a value from 0-127,
	 	// set the other bits in the combined register value 
	 	// to all r' value, and move the other bits to r_reg
	 	if (q == 5'b00000) begin
	 	end
	 	else if (q == 5'b11001) begin
	 	end
	 end
================================================================
example-3: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// REGISTER_N _Register[4:0] #(5)
// q
// feedback
// -----------------------------------------------------------------------
assign q = { 1'b0,grstval, Tele_MF_reg[4:0] , r_reg[4:0]};
// special case when r_reg = 0, assign {1'b0,grstval} to r_next and set it on the feedback value
// assign {1'b0,grstval} to q 0 0 0 0
generate 
if(PL_lowp) 
	begin : LFSR_PL_lowpass
	reg [4:0] r_const;
	always @(posedge clk or posedge reset)
	begin
	if(r_const = 5'h08) //Irrelevant if r_reg is 8 or below
	grstval = 1'b
================================================================
example-4: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk)
begin
if (reset)
	begin
	r_reg <= 5'b01011;
	end
else
	begin
assign r_next = feedback_value ? r_reg ^ 5'b01101 : 
	r_reg; 
	end
end

================================================================
example-5: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@(posedge clk, negedge reset) 
	begin
	// reset
	if(reset == 1'b0) 
	r_reg <= 5'b10001;
	if(reset == 1'b1) 
	r_reg <= 5'b0;
	end
assign r_next = r_reg ^ ({5{check_input}});
assign feedback_value = r_next[1] ^ r_next[3]; //check r[0] is a majority or minority

================================================================
example-6: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk, posedge reset)

begin

// assign feedback to feedback_value
// assign q to r_next
if (reset == 1'b1)
begin
	r_reg <= {1'b1,1'b0,1'b0,1'b0};
end
// else assign r_next to r_reg
else
begin 
	r_reg <= r_next;
end 
end
// in always block
	assign q = r_next;
	assign feedback_value = (r_next & {9{7'b0000000}}) ^ (r_next & {9{7'b0001000}}) ^ (r_next & {9{7'b0010010}}) ^ (r_next & {9{7'b0010001}}) ^ (r_next & {9{
================================================================
example-7: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset) ? 5'd1 :((first_half) ? {{4{q0_state[0]}}, {q0_state}} : {{4{q1_state[0]}}, {q1_state}});
assign r_next_remove_2 = (reset) ? 5'd1 : r_reg[0];
assign r_next_remove_4 = (reset) ? 5'd1 : r_next_remove_2;
assign r_next_include_2 = (reset) ? 5'd1 : r_reg[1];
assign feedback_value = (reset) ? 1'b0 :
(feedback_on) ? {{4{r_reg[3] ^ r_reg[0]}}} : {5'bx,r_reg[3:0]};
assign r_next_combinational
================================================================
example-8: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
	
always @(posedge clk or posedge reset) 
if (reset) 
r_reg <= 1; // always reset to all 0
else // freak out if r_reg exceeds 5 bits (you can output a 6 bit number)

// feedback value = (r_reg[1] ^ r_reg[2]) ^ ((r_reg[3] | r_reg[0]) & r_reg[0])
// so (clk has to be running)
assign feedback_value = ((r_reg[3] ^ r_reg[0]) & q[4]) | (r_reg[1] ^ r_reg[2] & q[0]);
	


always @(posedge clk or posedge reset) 
begin
if (reset) 
r_reg <= 1; // always reset to all 0
else
	

// read
================================================================
example-9: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// generate clk signals (from modules in pipeline) for cl1_r, the internal, regular r_reg
wire clk_r; repeat (5)
instantiate
cabek
xq0
rqb0
rckt0
d1

================================================================
example-10: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q

always @*
begin
r_reg <= {1'b0,r_reg[3:0]};
end
assign r_next = r_reg;
assign feedback_value = r_reg[4];
assign r_next[4] = feedback_value ^ (r_reg[1] ^ r_reg[4]);
assign q = r_reg;

================================================================
example-11: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// increment the q in the ram with the q_entry (on reset value of q == 21)
assign q = r_reg;

parameter forbits = 4;
//parameter skip = 5;
assign op_bit_4 = q[4];
assign op_bit_3 = q[3];
assign op_bit_2 = q[2];
assign op_bit_1 = ^(q | r_reg);
assign feedback_value = ((~feedback_value) ^ (q[0] ^ q[10]));

dfrlct u168(.aclr(r_reg == 4'b0000), .clk(clk), .clken(1), .sin(feedback_value), .q(r_next));

always @(posedge clk) begin
	if(reset || reset_q_reg
================================================================
example-12: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset)
begin
if(reset)
	r_reg <= 5'b0101;
else
	r_reg <= r_next;
end
xor xor0(feedback_value, r_reg[2], r_reg[3]);
xor xor1(feedback_value, feedback_value, q[4] && r_reg[4]);

================================================================
example-13: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset)? 5'b00000 : (r_reg<<1) | {r_reg[3],r_reg[2]} | r_reg[1] ^ r_reg[0];
assign feedback_value = r_next[2]^r_next[3]^r_reg[4];
always @(posedge clk)
begin
	if (reset == 1'b1)
	begin
// set r_reg to initial 0 value
r_reg <= 5'b0;
{r_reg[1], r_reg[0]} <= {r_reg[0], 1'b0};
end 
else
	begin
// Use feedback_value to TR ripple circuit
// on the rising and falling edge of feedback_value
// increase bit2 and bit3
r_reg <= {r_reg[3], r_
================================================================
example-14: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @(posedge clk or posedge reset)
begin
if(reset)
r_reg = 5'b00000;
// exclusively highlighting the position 2 of the register to inject
// feedback
//r_reg[2] = 1'b1;
// in the example below r_reg[2:0] are "replaced" here and not "read"
r_reg[2:0] = {4{1'b1}};
end
// LINKED A at the position 3 of lfsr
// r_reg = {1,1,1,1,1,1,1};
// ASSIGNING THE VALUE OF R_NEXT AT THE POSITION OF REGISTER 2 FROM THE r_Reg
// R_next[2] = r_reg[2_cuts]] where 0 < (2_cuts) < 4
================================================================
example-15: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = (reset || r_reg == 3) ? r_reg : r_reg_next;
assign feedback_value = {1'b0, q[4] & q[2] & ~q[0] & ~q[1]};
assign r_reg_next = (reset) ? (initialvalue) ? 5'b0 : {q[3], key, q[3]};
// keycorl.v
module key_corl (
	.input [12:0] key,
	.output [28:0] parity_mul,
	.output parity_init
);
	wire [1:0] w_hi,w_lo;
assign w_hi = key[11:9];
assign w_lo = key[8:6];
assign parity_init = ~key[12];
assign parity
================================================================
example-16: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assigns the feedback value to the output q
assign r_next= (reset)?{1'b1,1'b0,1'b1,1'b0}:r_reg;
assign feedback_value = r_next[0] ^ r_next[1];
dfrl12b dfrl_q(clk, 1'b0, r_reg[4], r_reg[3], q, 1'b0, 1'bz);
dfrl4b dfrl_r(clk, 1'b1, r_reg[4:3], r_reg[2:0], r_reg[5], r_reg[4:3], feedback_value, r_next[4:3], r_reg[5]);

================================================================
example-17: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// if reset is asserted then assign the output q to the input q
assign r_next = (reset==1'b1) ?	{5'b10000,r_reg} : {feedback_value, r_reg};
assign r_reg = {hot_r_reg};
assign hot_r_reg = {1'b0,r_reg};
assign q = r_next ^ (last_shift & q_next);
assign xor3 = {q_next[4],r_next[4],hot_r_reg[4]};
assign feedback = {xor3[1],0,3'b0};
assign q_next = q & {{3{~last_shift}},1'b0} | {feedback_value, {5{~last_r_reg}}};

================================================================
example-18: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
	assign r_next = reinitq ? 5'h1 : (feedback_value ? r_reg ^ {q[3], q[4], q[5] ^ q[4], q[5], q[4] ^ q[3] } : r_reg);
generate
if (SEL==1) begin always @(posedge clk)
	if (reset || reinitq) r_reg <= 5'h1;
	else	 r_reg <= r_next;
end else begin always @(posedge clk)
	if (reset || reinitq) r_reg <= 5'h1;
	else	 r_reg <= 5'h0;
end
endgenerate

================================================================
example-19: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk, posedge reset)
begin : register
if(reset == 1) 
	r_reg <= 5'b00001;
else 
	r_reg <= r_next;
end
// the next states are current states + 1
// 1 + random = [r_reg + 2^5 * k~_random] % 256
// quinton revenue update: code modified to include a slow clock division and adder as is from project
assign r_next = r_reg + {5'b00001, r_reg [4], r_reg [4:1] ^ {feedback_value, r_reg [0]}};
// this divide and conquer shift register will feed the feedback 'wires'
shift_unsigned_left shift_div
(
	.clk(clk),
	.reset(reset),
	.data(
================================================================
example-20: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@(ghost #4,q_reg,feedback_value) 
begin
,if (reset==0)
begin
q <= 8'b11110000;
r_reg <= 8'b10000000;
end
else
begin
r_reg <= r_next;
end
end
// definition of next state function
// return r_next when reset = 0 and q_reg = 0n
// when reset = 0 and q_reg is not 0
assign r_next = (~q_reg)&z & feed;
// feedback part
// set r_next to the concatenation of the function of r_reg, feedback_value for every position, not considering feedback_value[0]
assign feedback = {r_reg[3]^feedback_value[0],r_reg[2]^feedback_value[1],r_reg[1]
================================================================
example-21: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk or posedge reset)
begin
	if (reset)
	begin
	r_reg	<=	5'b10001;
	end
	else
	begin
	r_reg <= r_next;
	end
end
assign r_next = ((~r_reg)<<1)^((~r_reg)>>4);
assign feedback_value = r_reg [2] ^ r_reg [3];
assign q = {feedback_value, r_reg};

================================================================
example-22: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign q to the next value r_next
assign r_next = r_reg<<2|r_reg<<3;
always @(posedge clk)case(r_reg)
5'b00000:r_reg <= 5'b00001;
5'b00100:r_reg <= 5'b00011;//5'b00010;
5'b00101:r_reg <= 5'b0011;//5'b001110;
5'b00110:r_reg <= 5'b00111;//5'b0011010;
5'b00111:r_reg <= 5'b0000;//5'b00111000;
5'b01000:r_reg <= 5'b0001;//5'b0001000;//5'b10101010;
5'b01001:r_reg <=
================================================================
example-23: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q

assign q = r_reg;
always @ *
begin
	if(reset)
	begin
	r_reg = <loading-terms>;
	end
begin
	else
	begin
	r_reg = r_next;
	end
	end
end

// implementation: 1 bit group delay ahead of feedback, 3 bit group delay after last bit and 1 bit delay after the last bit
	// "output" bit is assigned to the bit position 4

// --------------
// combinational logic
// ----------------

assign r_next = {
live_vvvv and { [4:0] {r_reg[3:0]} } | { [2:0] {feedback_value} } | { 15'b0, r_reg[4] } };


================================================================
example-24: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @ (posedge clk or posedge reset) if (reset) r_reg <= 5'b00001;
else begin
assign feedback_value = q[1] ^ q[4]; // repeat assignments for all the wires in the ring
assign r_next = q[0] ^ feedback_value;
end

================================================================
example-25: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
/*
 pwm uload (
.familiar_lsf(~r_reg ,r_reg[4:0]) 
`ifdef ALPHAE49U
`ifdef WORKING
 );
 `endif
 `endif
`endif
*/
always @ (posedge pause)
 begin
 if ( ~reset ) r_reg <= 42'b1;
 else 
 begin: random_coefficient
 /*
 // assume the value of r_reg is defined, check a_reg, a_reg_l
 if (akey[0][0]==1) r_reg[4:3] <= (~ack_reg[key_in_grp[EX1_GKEY]] & 17'b1)^8;
 if (key[13][1]==1) r_reg[2:0] <= (~ack_reg_l[key_in_grp
================================================================
example-26: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
genvar i;
generate 
for(i=0;i<5;i=i+1)
begin
//if reset is high define input values as 2500
//if reset is low let the assign statements in the Basic Encoding in the procedural
//if none are defined fall back to the basic encoding
	always@(posedge clk or posedge reset)
	//if reset is Halt the signal of the sequencer to be sure
	//to the next assignment value when the clock cycle finishes
	if (reset)begin
	//if not reset write 12bit initial value 0x0000000000 in that the
	//output is 4 MSB of the input value
	r_reg = {5{1'b0}};
	end
	else
begin 
	assign r_next[i] = ((~a[i] & r_reg[i]) | (~b
================================================================
example-27: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset)
begin
	if(reset)
	begin
	r_reg = 5'b1;
	end
	else
	begin
	r_reg = r_next;

end

xor(feedback_value,r_reg[2],r_reg[4]);

assign r_next[4] = r_reg[4]; //feedback concatenated with remaining
assign r_next[3] = feedback_value;
assign r_next[2] = feedback_value ^ r_reg[3];
assign r_next[1] = feedback_value ^ r_reg[2];
assign r_next[0] = feedback_value ^ r_reg[1];



================================================================
example-28: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q

assign r_reg = (reset) ? 5'd1 : 5'd2;
xor(feedback_value, r_reg[0], r_reg[2], r_reg[3], r_reg[4]);
xor(r_next, r_reg[1], feedback_value, r_reg[2], r_reg[4]);
assign q = r_reg;

================================================================
example-29: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q[4] = (reset) ? 1'b0 : feedback_value;
assign q[3] = (reset) ? feedback_value : r_reg[3];
assign q[2] = (reset) ? r_reg[2] : feedback_value;
assign q[1] = (reset) ? r_reg[1] : feedback_value;
assign q[0] = (reset) ? r_reg[0] : feedback_value;
always @ (posedge clk) begin
if (reset)
r_reg <= 5'b10000;
else
r_reg <= r_next;
end 
assign r_next = r_reg ^ {r_reg[1]: r_reg[3],
{r_reg[3],} ^ {r_reg[1]: r_reg[3]}, {r
================================================================
example-30: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset)
begin
	if(reset)
begin
	r_reg <= 5'b00001;
end
else
begin
	r_reg <= r_next;
end
end
assign feedback_value = bit1_cnt == 1'b1 && check_bit_cnt2 == 1'b0 && check_bit_cnt3 == 1'b1;
assign bit23_cnt = r_reg[4];
always @(posedge clk or posedge reset)
begin
	if(reset)begin
	r_next[4] <= 0;
	r_next[3] <= 0;
	end
else
begin
	if(bit23_cnt == 1'b1)
	begin
if((check_bit_cnt2 == 1'b0) && (
================================================================
example-31: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign feedback_value to the q latch
always @ (posedge clk or posedge reset) 
 begin
 if (reset) 
 r_reg <= 5'h1;
 else 
 r_reg <= r_next;
 end
assign r_next = (glitchfilter & )
 assign q = r_reg;
 // assign r_next to q for combinational logic

================================================================
example-32: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = (r_reg == 5'b00000) ? 1 : 
(r_reg == 5'b00001) ? 0 : (r_reg == 5'b00010) ? 0 : (r_reg == 5'b00011) ? (~(r_reg[1])) : 1;
assign r_next = (r_reg == 5'b00000) ? 5'b00000 :
(r_reg == 5'b00001) ? r_reg :
(r_reg == 5'b00010) ? 5'b00011 : 
(r_reg == 5'b00011) ? 5'b00001 :
(r_reg == 5'b10000) ? r_reg :
(r_reg == 5'b10001) ? 5'b10010 : 
(r
================================================================
example-33: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always_ff @ ( posedge clk or negedge reset )
begin
if(reset == 1'b0)
r_reg <= 5'b00000;
else if(idthis)
r_reg <= r_next; 
end
// 1: above lift shifter, 2: below, 3: rotate
assign r_next = ({{5{r_reg[2]}}}),
({{1{r_reg[4]}}}),
({{3{r_reg[4]}}},
r_reg[4],
r_reg[3:0],
r_reg[4]);
assign feedback_value = r_reg[2] ^ r_reg[3];
and #(5'b11111)
assign r_reg_1 = {1'b0,r_reg[4]};
xor #(5'b
================================================================
example-34: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
parameter bit =5;
always @(posedge clk) begin
	if (reset)
	begin
	r_reg <= {bit};
	end
	else
	begin
	r_reg <= r_next;
	end
end
assign r_next ={~q[0],r_reg[4:1]};
assign feedback_value = r_reg[2] ^ r_reg[4];
// xor the above with the 4 most significant bits to obtain d
xor d(q[1:0], r_reg[0], r_reg[3]);
xor d1(q[3], feedback_value, r_reg[1]); 

================================================================
example-35: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset) 
if (reset) r_reg <= 5'b00100;
else r_reg <= r_next;
assign feedback_value = feedback | (r_reg[2] ^ r_reg[3]) |
(r_reg[4] ^ r_reg[2]);
assign r_next = {r_next[2:0], feedback_value};
assign q = r_reg + {1'b0, r_reg[4:3]};

================================================================
example-36: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk, posedge reset) 
begin
if (reset == 1'b1) 
begin
r_reg = q[4:0];
end
else 
begin
r_reg = r_next;

end
end
assign q = r_reg;
//first atan
assign feedback_value = {{3'h0},q[2:0]^q};
generate
genvar i;
for(i=0;i<4;i=i+1)
begin
//assign HEX0[i] = ( (r_reg >> i)& 1) + (r_reg >> i) + overflow + {3'h0, r_reg[i]};
end
endgenerate
assign overflow = (r_reg[3:0] & r_reg[3:1])|(
================================================================
example-37: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk)
	if (reset)
	// assign r_next to r_reg
	r_reg <= 5'b00001;
always @(*)
begin
case ({r_reg, 2'b0})
5'b000000 : r_next = r_reg; // feed output r_reg for first 5 cycles
5'b000001 : r_next = {r_reg[0], r_reg[4] ^ feedback_value}; // combine input "value" and feedback value
5'b000100 : r_next = {r_reg[2], r_reg[3] ^ r_reg[4] ^ declarationofcounters[3] ^ r_reg[4]}; // modify to generate timing delays
5'b000101 : r_next = {r_reg[1], r_reg[0] ^ r_reg[
================================================================
example-38: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk or posedge reset) begin
	// reset
	if (reset) r_reg <= 5'b00100;
	// on posedge return the next value, whatever the value of the input
	else r_reg <= r_next;
end
assign r_next = {r_reg[1:4], {4{q[4]}}, r_reg[3:2]};
assign feedback_value = q[0] ^ q[2];

================================================================
example-39: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
initial begin
	r_reg <= 5'd1;
	end
always @(posedge clk)
begin
	if (reset)
	begin
	r_reg <= 5'd1;
	end
	else
	begin
	r_reg <= r_next;
	end
end

================================================================
example-40: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset)? {5{1'b1}}: (feedback_value) ? ({q[4:0], q[3], q[2], q[1], q[0] } ^ r_reg) : (q | r_reg);
always @ (posedge clk) begin
	if (reset) r_reg <= 5'd1;
	else r_reg <= r_next;
end
always @ (posedge clk) begin // if r_reg value happens to be a potential feedback and pair value. r_next in the output q.
	if(r_reg[4] == 1) // test for pair value
	begin
	if (!r_reg[3] && r_reg[2] && !r_reg[1] && r_reg[0])
	q = r_next[4:0]; // set
================================================================
example-41: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@(posedge clk, posedge reset)
begin
if(reset)
	r_reg <= 5'b00001;
else
	r_reg <= r_next;
end
assign feedback_value = r_reg[4] ^ r_reg[3];
assign r_next = {r_reg[3],r_reg[2],r_reg[1],r_reg[0],feedback_value};

================================================================
example-42: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// add r_reg and r_next
always @(posedge clk or posedge reset)
begin
 if (reset == 1'b1) 
begin
	r_reg <= 5'b00000;
end
else
begin
 r_reg <= r_next;
end
end
assign r_next = r_reg << 1;
xor xor_1(.a(r_reg[2]), .b(r_reg[4]), .out(feedback_value));
xor xor_2(.a(feedback_value), .b(r_reg[4]), .out(r_next[4]));
assign q = r_reg;

================================================================
example-43: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@( posedge clk, posedge reset ) begin
if( reset == 1'b1 ) begin
	r_reg <= 5'b10111;
end
else begin
r_reg <= r_next;
end
end
assign r_next = r_reg ^ ({5'b010001, r_reg[4:0]});
assign feedback_value = {r_reg[4:3] ^ r_reg[2:0]};
assign q = r_reg;

================================================================
example-44: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// NOTE: in one hand this counter base is less efficient, yet it is easier to code, only 1 register
initial begin
 r_reg = r_next = 8'b10000001;
end

================================================================
example-45: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset) 
begin : BIT_3
if (reset) 
	r_reg <= 0;
else
begin
	r_reg <= (r_reg ^ 164269) + (r_reg >> 4);
	//r_reg <= {r_reg[3:0], r_reg[4]};	//shift the r_reg value into the FPGA
	r_next[0] <= r_reg[0] ^ r_reg[4];
	r_next[1] <= r_reg[1];
	r_next[2] <= r_reg[2];
	r_next[3][0] <= r_reg[3] ^ r_reg[4];
	r_next[3][1] <= r_reg[3] ^ r_reg[4];
	r_next
================================================================
example-46: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next =	(reset)?	5'b00000 : r_reg ^ {q[4:3], feedback_value};
always @(posedge clk) begin
	// reset
	if(reset) begin
//	 finish
	r_reg = 5'b00000;
	end
	// increment
	else begin
	begin
	r_reg = r_next;
	end
	end
	end
	
================================================================
example-47: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_reg = r_next ^ 5'b10000;
assign r_next = r_reg ^ q;
// assign feedback_value to the result of carrying the feedback through q and r_reg
generate
	genvar i;
	if(QUIET_RESET == 1)
	begin
	for(i = 4; i <= 5; i = i+1)
	begin
	assign feedback_value = (r_reg[i]) ? feedback_value : 1'b0;
	end
	//end for
	assign q = r_reg ^ {1'b0, feedback_value, 1'b0};
	end
	else 
	begin
	for(i = 4; i <= 5; i = i+1)
	begin
	assign feedback_value = (r_reg[i]) ? feedback_value
================================================================
example-48: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign feedback_value to the input q[4] of the AND gate
and(q[0], !q[4], r_reg[1], q[4], feedback_value);
and(q[1], q[4], !q[2], r_reg[2]);
and(q[2], !q[4], r_reg[0]);
and(q[3], q[4], !q[0], r_reg[3]);
and(q[4], !q[4], r_reg[3]);
or(q[5], q[4], q[2]);
and(q[6], q[5], q[2]);

================================================================
example-49: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @( posedge clk or posedge reset )
begin
if ( reset == 1 )
	r_reg <= 5'b00000;
else begin
	// Sum the next most significant bits and feed the next most significant bit
	r_reg[4] <= r_reg[0];
	r_reg[3] <= r_reg[1];
	r_reg[2] <= r_reg[4] ^ (r_reg[4] | (r_reg[3]^r_reg[1]));
	r_reg[1] <= r_reg[2] ^ (r_reg[2] | (r_reg[1]^r_reg[0]));
	r_reg[0] <= r_reg[1] ^ (r_reg[1] | (r_reg[0]^r_reg[4]));
end
================================================================
