example-0: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


genvar i;
for (i=0;i<8;i = i+1) begin:loop
	wire [3:0] t1 = {a[i],b[i]}; 
	wire [3:0] s1 = {t1[2],t1[1],t1[0],a[i]};
	wire [3:0] t2 = {b[i],a[i]}; 
	wire [3:0] s2 = {t2[2],t2[1],t2[0],b[i]};
	assign s[i] = s1[3]^s2[3];
	//s[i] = s1[3]*s2[3];
	assign t1[3] = a[i]&b[i];
	assign t2[3]
================================================================
example-1: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// 8-bit signed adder

assign s = a + b +
	// If a or b is negative, just add a negative sign to the sum
	//if (is_signed && (a[7] ^ b[7]))
	//	s = (~a[7] & ~b[7]) ? -s : s;
	//if (is_signed && (a[7] ^ b[7]))
	//	s[7] = ~a[7] & ~b[7];
	//add two numbers a and b, or numbers a and b fcw depend on the sign of a and b be 
	//defined by the sign of sum
//assign s = a + b;
//assign sign_of_num_b = (div_num[7]) ? 1'b1 : 1'b0;

//ass
================================================================
example-2: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign output_overflow = ((a[7]==1'b0 & b[7]==1'b0) & s[7]==1'b1) | 


if ((a[7]==b[7]) & (a[7]!=s[7]))
begin	
	//if the most significant bit of a and b differ and the most significant bit of a is already in the set of digits of s, for example s=100000000, 
	//then s is reset to 0100000000
	//this is because a-b=(a1(a[7])-(b1(b[7])))*log2(10); (log2(10)=3.32)
	//so be in the s=0100000000-100000000, (b1(b[7]))=((b1*)log2(10))*-1@@
================================================================
example-3: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [6:0] mathch = a>>b;

assign s=(overflow ==1'b1) ? (~a+1'b1) : (a+(b<<(~b)) ; 

// assigns the result to s as the output. 
// If a or b are positive and the operation is a-b, s is negative. Overflow occurs when the sum is outside the range [-128,127).


assign overflow=(a[6]^b[6])&&(a[7]^b[7]);


================================================================
example-4: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


reg signed [8:0] s;

always@(a or b or s)
if (s[7] == a[7] && s[7] != b[7]) 
overflow = 1; 
else overflow = 0; 
//It seems like if a and b have opposite signs, then the sum has opposite signs. I'm gonna make this mistake a signed overflow.

//The carry into the msb of s[7] is calculated after the carry is calculated into the msb of s[8].

always @(s[8] or a[6] or b[6])
if (a[6] && b[6] && s[7]) 
s[0] = 1; 
else if (!a[6] && !b[6] && s[0]) 
s[0] = 0; 

assign s[1
================================================================
example-5: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [7:0] b_most_significant_bit_pos; //n bit number with only the most significant bit pos. ie. 0 in 100 bit number
assign b_most_significant_bit_pos = b[7]; // Assign the most significant bit position.

add add11 (.a(a[7]), .b(b_most_significant_bit_pos), .s(s[7]), .c_out(c_out));

generate 
	// If the carry is generated from the sum and c_out_bar is high then we have a signed overflow
	assign overflow = (carry[7]^carry[6]); 
endgenerate
// if a carry is required then c_out_bar is high

// if A < B, a signed ordering is violated. and it results in a signifigcant carry or negative sum.

================================================================
example-6: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed a1; // the most significant bit of a is replaced with a1 and the rest of a[7:1] are 0
wire signed b1; // the most significant bit of b is replaced with b1 and the rest of b[7:1] are 0

assign a1 = a[7];
assign b1 = b[7];

assign s = {a1, a[6:0]^b[6:0]}; // s is a[7:1], where s[7] is the bias of the most significant bit of s = (b[7])((a[7]^b[7])^(a[6]^b[6])^(a[5]^b[5])^(a[4]^b[4])^(a[3]^b[3])^(a[2]^b[2
================================================================
example-7: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



================================================================
example-8: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low




// Design a 8-bit signed adder Sum[7:0] = a[7:0] + b[7:0]

// if the enable in the && statement is 1 then add else subtract. 

// If the ring counter has ticked the add and subtract counts just have been done and the output is passed to the final system
// Overflow is reset whenever the a or b are updated.

assign overflow = up_up_counter ^ up_down_counter;

// Set the most significant bit to 0 to represent a negative sign bit and set the least significant bit to 1 for a positive sign bit.

assign b_next = ((b[0] == 1'b0) ? b_out : ~b_out);
assign a_next = ((a[0] == 1'b0) ? a_out : ~a_out); 

//
================================================================
example-9: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


output [7:0]s; 
output overflow;
input [7:0]a;
input [7:0]b;
wire [8:0]c;
wire [1:0]carry;

assign carry[0] =1'b0; 

// 8-bit ripple carry adder with carry out
fulladder b0carry0(.a(a[0]), .b(b[0]), //inputs and carry in 
	.s(s[0]), //output and sum 
	.carry(carry[1])); //carry out 

fulladder b1carry1(.a(a[1]), .b(b[1]), .carry(carry[2]), //inputs and carry in 
	.s(s[1]), //output and sum 
	.carry(carry[3])); 

full
================================================================
example-10: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = (a[7] & b[7]) | (((a[7] & b[7]) & (~s[7])) ;
// these statements are true if a or b have a signed overflow 
// true if a or b have a signed overflow 
// true if s has a signed overflow 


================================================================
example-11: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



================================================================
example-12: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire b_extended [7:0] b_extended_from_carry; 

// ensures that b is 2s extended and added to a[7:0] to form b_extended
carry_extender b_carry_extender(
.carry_in(b),
.db(b_extended)
);

// this block generates the initial carry based on the 2s extended sum
initial_carry_adder a_0(
.a(a),
.b(b_extended),
.carry(s[0]),
.sum(s[1])
);

// this block adds the second carry after the first carry is generated to form integers a and b

carry_adder a_1(
.a(a),
.b(b_extended),
.carry(s[2]),
.sum(s[3])
);

================================================================
example-13: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// A design for simulating the adder 

module sc_adder_8(s, cout, x, y, cin
);

input [7:0] x, y;input cin; // I/O signals will be explained later 
output [7:0] s;output cout; // again, I/O signals will be explained later

// Initially, all the output signals are 0 
assign {cout, s} = 0;

// A full adder simulation 
// wires and regs are used to model structural full adder 

reg[7:0] x_dff, y_dff; //computer_science_not_verilog
 // 8-bit reg

// Behavioral and sequential designs

// A latch with a single input and output, when the input and output are ready both the latch 
// and the output
================================================================
example-14: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// the above conditions for the signed overflow have to be detected and the value of s be determined



// the value of the most significant bit of s is input to this module.

assign Simplified_EA = a[7] ^ b[7] ^ s[0]; 




ISOE E3

================================================================
example-15: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 

always @ (a or b or s)
 begin
	if ((a[7]==0)&&(b[7]==1)&&(s[7]==1)) // check if a and b have opposite signs and s has a positive sign
	
	overflow = 1;
	else if ((a[7]==1)&&(b[7]==0)&&(s[7]==0)) // check if a and b have opposite signs and s has a negative sign 
	
	overflow = 0;
	else 
	overflow =0;
end
 

assign s[0]=(a[0]^b[0])^sign; // set the first bit of s to (a^b)^sign if a or b are negative, else set it to a or b's positive sign.
 
assign s[1
================================================================
example-16: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0] s;
wire overflow;

reg signed [7:0] b_local; // used for comparing if the b in the statement is signed or unsigned

always @ (a or b) begin
 if (a[7] == b[7]) begin // if a and b have opposite signs //(a[7]^b[7]), //the exponent will be the same, but significand won't be.
 if (a[6:0] > b[6:0])	
 b_local <= (~b) + 1'b1; 
 else
 b_local <= b;

// B will always be 2s comp, but will be 0s comp in the statement. 
 
 s = (a < b_local) ? (~a + 1'b1) : a;	 
 overflow = 0;
 end
else begin 

s
================================================================
example-17: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



//if both the numbers are signed and there second bit from the numbers is a signed overflow then make the sum as signed otherwise make it as unsigned
// if the second bit of a or b is high make the number as signed else make the sum unsigned

assign s[0] = (a[1:1]+b[1])^(a[2:2]+b[2]);
assign s[1] = (a[3:3]+b[3])^(a[4:4]+b[4]);
assign s[2] = (a[5:5]+b[5])^(a[6:6]+b[6]);
assign s[3] = (a[7:7]+b[7])^(a[0:0]+b[0]);
assign s[4] = (a[2:0]+b[2:0])^
================================================================
example-18: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// temporary storage for the while loops when adding the 2's
reg [7:0] c;
reg [5:0] f;
	
^	integer i; // used to indicate if a signed overflow ocurs
always @(*) begin
if (a[6]^b[7]) begin // indicate if a and b have a signed overflow
^ (c[6],f[3]); // indicate if c has a signed overflow
(*c[6],s[5])=(a[6]*(~b[7]));
(*c[6],s[4])=(a[6]*(~b[6]));
(*c[6],s[3])=(a[6]*(~b[5]));
(*c[6],s[2])=(a[6]*(~b[4]));
(*c[6],s[1])
================================================================
example-19: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = {a[6:0],b[6:0]};
assign overflow = (a[6:0]< b[6:0])?(a[7]):(b[6:0]<a[7]);


================================================================
example-20: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = {a[6],b[6]} ^ s[6];

// utility carry 

//Full adder 1

/*
reg [8:0] c;

//Half adder 1

//Full adder 2

//Half adder 2

//Half adder 3
*/
 


================================================================
example-21: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


generate
begin
	
	case(a[6:0]+b[6:0]) // case a + b
	8'dxx:(8'd0 > a[6:0] && 8'd0 > b[6:0]) ? (s[6:0]=(a[6:0]^b[6:0])^(~a[6:0])) : (8'd1=a[6:0] && b[6:0]) ? (s[6:0]=(a[6:0]^b[6:0])^(~a[6:0])) : (8'd1=b[6:0] && a[6:0]) ? (s[6:0]=(a[6:0]^b[6:0])^(~b[6:0])) : (s[6:0]=(a[
================================================================
example-22: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign s =a[7]^b[7]^overflow; // a and b are added or subtracted, depending on the value of the bit a[7] xor b[7]
assign overflow = (a[7]&b[7]) | ((~a[7])&(~b[7])); // a[7]%b[7] will give the sign of b[Mem[7]=1 for subtraction, requiring agreement of the most significant bit of a and b. For addition, b[7]%a[7] will give the same result, requiring agreement of the most significant bit of a and b.


================================================================
example-23: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// NETSim representation of the signed adder.
// It contains a module instance of a.
// At high time, the most significant bit of a is connected to the lower switch output.
// The sum of a and b is displayed at high and low time.
 

module signed_adder_tb;
 
 // Define the inputs and output of the signed adder
 reg[7:0] a;
 reg[7:0] b;
 wire[7:0] s;
 wire overflow;

// Initialize DUT Inputs
 
 initial
 fork
 a = 0; b = 0; //initialize both the inputs at time 0
 #100 a = 7; b = 7; //at time 100, assign the inputs to + -ve numbers
 #200 $finish; //at time 200, output is displayed at total time 300
 //at time 300, output is
================================================================
example-24: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire bout;
output [7:0] s; // the 8-bit output is split into 8-bit MSB and 8-bit LSB
output overflow; // indicates the signed overflow occured

reg signed [7:0] lb; //stores the sign of b
assign lb = a[7] ^ b[7]; //extracted the sign of b from the two 8-bit numbers a and b

reg signed [7:0] ab; // stores the sign of a and b
assign ab = a[7] ^ b[7]; // extracted the sign of a and b

//generates half signed adder
assign half_adder = a[3]^b[3]; //outputs the signed sum of the two half adders
assign adder = {4'b0000,half_adder}; //concatenates the unsigned numbers a and b

ass
================================================================
example-25: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


/*

TODO:

Write a test bench that tests that any combination of a and b generates a signed sum that carries only a single negative or positive sign bit.

Write a test bench that tests that any combination of two 1's and an even number of 0's is treated as an unsigned lossless addition. Implement a hexadecimal logic function to interpret the two numbers and any control signals you put on the input and output ports. Essential control signals are manually set if a default test condition isn't adequate.

Specify when and how much information is written to a terminal during the simauation process.
For example, every time the number of digits is updated when the test CNN design switch is high.
Test whether the result functions as its expect externally.

Read and write the size of a decimal program unit.
Produce a command that simulates a decimal operation.


*/

/////////

// part
================================================================
example-26: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire [7:0] b_ext = ~b+1[7:0]; // Extended version of b

assign s = a + b_ext;

assign overflow = (a[7] & b_ext[7] & ~s[7]) | ( b_ext[7] & a[7] & ~s[7]); 




================================================================
example-27: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign {overflow,s}=a+b;


================================================================
example-28: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// Below uses an exclusive-or operator to find the result of a signed add of two numbers with signed bit high or low respectively. 
assign {overflow,s} = a+b; 
// The above sets s to be the sum of a and b. If there is an overflow of a and b, then s is set to be the two signed numbers' sum with the most significant bit turned into the negative value. Our exclusive-or sets the output to being the two numbers' sum with the sign bit of s changed to negative. 
// It also sets anoverflow to high, signaling when a signed overflow occured.
//--------------------------analysis of the outputs--------------------------
//If we subtract the two numbers' sums, the overfow should continue to be high, but s should no longer be negative. This is what our analysis tests.



================================================================
example-29: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((a[6:0]^b[6:0]) & (a[7]|b[7]));



assign s = ((a[6:0]^b[6:0])& (a[7]|b[7])) ? ((a[6:0]&b[6:0]) ? ((a[6:0]&b[7]) ? ((a[7]&b[7]) ? overflow : (~a[7]&~b[7])) : ((a[7]&b[7]) ? overflow : ~a[7]&~b[7])) : ~(a[6:0]^b[6:0])); 

/* alternative implementation

// a and b are added if signed (a[i] + b[i] = s[i]), otherwise carry is updated
// s =
================================================================
example-30: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



//Solution:
dct_top dct(.clk(clk), 
.reset(reset_n), 
.convert(!b[7]), 
.signed_data(a), 
.start(s_start), 
.dct_valid(s_valid), 
.dct_value(s), 
.overflow(overflow_dmw), 
.signed_ret(s_out), 
.done1()

);



================================================================
example-31: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = (a[7]&b[7])^(a[7]&overflow)|(b[7]&overflow&a[7]);
assign overflow = (a[7]&b[7])&(a[7]|b[7]);


================================================================
example-32: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low




================================================================
example-33: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// A full adder 

module fulladd(input a,b,c,output s);

assign s=a^b^c;


================================================================
example-34: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


//if overflow is positive it means we have a signed overflow
//if most signals of a are high and s is low then it means we have a signed overflow
	
wire signed [7:0]e1;	
assign e1[63:55] = {7{a[7]}} & b[7:0];	
assign e1[7:0] = {8{a[7]}} + {8{b[7]}} + {64{op}} ; 

wire n1, n2, n3, n4, n5, n6, n7, n8 ; 
	
adder_1b a0 (n1, n2, a[0], b[0], op);
adder_1b a1 (n3, n4, a[1], b[1], n1);
adder_1b a2 (n5
================================================================
example-35: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 initial begin
	assign overflow= a[7] & b[7] & s[7];
	//operator = is used because in the case of if 
	//the else statement of an assign statement
	tri0 = ((~a[7]) & b[7]),
	tri1 = ((~a[7]) & (~a[6]) & b[7]),
	tri0 = ((~a[7]) & (~a[6]) & (~a[5]) & b[7]),
	tri1 = ((~a[7]) & (~a[6]) & (~a[5]) & (~a[4]) & b[7]),
	tri0 = ((~a[7]) & (~a[6]) & (~a[5]) & (~a[4]) & (~a[3]) & b[7]),
	tri1 = ((~a[7]) & (~a
================================================================
example-36: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [8:0] c;

assign c[0] = 0; // I'm gonna have the carry be its own separte module which is a little bit more interesting

assign c[1] = (a[0] == b[0]) ? a[0] : (a[0] ^ b[0]) ; //if a[0] and b[0] have opposite signs, subtract c[0] from a[0] and c[0] from b[0]
assign c[2] = (a[1] == b[1]) ? a[1] : (a[1] ^ b[1]) ; //if a[1] and b[1] have opposite signs, subtract c[1] from a[1] and c[1] from b[1]
assign c[3] = (a[2] == b[2
================================================================
example-37: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


//plus_4(e7,e6,e5,e4,e3,e2,e1,e0, f7,f6,f5,f4,f3,f2,f1,f0)
//plus(s7,01,e7,a[7], b[7],c[1]); 

assign s=a+b;
assign overflow=(p[3]^p[2]^p[1]^p[0]^s[7]);
assign ea=(p[3]^p[2]^p[1]^p[0])^s[7];
assign eb=(p[3]^p[2]^p[1]^p[0])^s[6];
assign e0=(p[2]^p[1]^p[0])^s[
================================================================
example-38: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire b_direction;
wire signed [(8)]b_shift; // << 1;

assign b_direction = b[0]; //b[0]; //opposite of b dir from b[0]=1 to b[0]=0;

// define shift operation on b
assign b_shift = b >> 1; // unsigned shift >>;
// define signed build of shift. Ssgn(b) << 1;

assign signed [(8)]b_signed = {b[7],b_shift[7]}; //concatenates the values together.



assign s = signed [(8)]a_signed << 1; //first defines the size; then concatenates; then defines the output.

assign overflow = a[7] & b[7] & ~s[7]; //s[7]; // final output is given by the most significant bit.
================================================================
example-39: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign c = a ^ b;
// calculates the 2s complement of the negative number (-a+1) or (b-1) 
// adds the results

assign s = c + 1;

// XOR of a and b adds the output to a 
// OR negation of a paired with b adds b	
assign s[0] = (a[0]^b[0])^(c[0]); 
// corrects analysis error (gilight)


================================================================
example-40: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire s[0]; // perform the addition on two initially zeros.
 assign s=a+b; // you'll get the answer in the form of sinfo. 
assign overflow=s[7]; // since s is an infinty number or greater, it must be high because d and c are low.
 //(c+d) 

// if the ud segment propagates logic high, add 3 and 2. Blocking cont. assign the result to s. 
// if the q segment propagates logic high, add 3 and 2. If the q segment isative, Blocking cont. assign the result to s. 
/*Cont. version of the priod Mux*/
always @* 
	if((c&d) == 1 || (b[0]&a[0]) ==1)
	begin
	s=(a-b)+3; 
	//s
================================================================
example-41: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// First add the 2's complement of the negative numbers
// ( result of tausworthe algorithm )

adder_2c add1(.a(a), .b(~b), .s(s1), .c(c1));
// Now add the two numbers, s1 = s + a)
adder_2c add2(.a(s1), .b(a), .s(s), .c(c2));
// assign the final result of the operation to s
assign s = s1 ^ c1 ^ c2;

assign overflow = c1 ^ c2;


================================================================
example-42: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = signed_add(a,b);
assign overflow = a[7] ^ b[7]; // the overwolf is the xor of a and b

// The signed addition function

function signed [7:0] signed_add;
input [7:0]a;
input [7:0] b;
begin
	signed_add = a+b;
	if ((a[7]==b[7])&&(signed_add[7]!=a[7]))
	// if a and b have opposite signedness then we have to consider the carry generated by the addition operation
	begin
	// If a and b have opposite signedness the carry is generated by the first bit of the sum
	// i.e. signed_add[0]. If this bit is high then we have a signed overflow.
	// We define a signed overflow to be
================================================================
example-43: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// add a high to a low and keep the carry in the same spot 

xor(carry, a[7], b[7]);
fulladder fa00(a[0], b[0], 1'b0, s[0], t[0]);
fulladder fa0x1(a[1], b[1], t[0], s[1], t[1]);
fulladder fa02(a[2], b[2], t[1], s[2], t[2]);
fulladder fa0n1(a[3], b[3], t[2], s[3], t[3]);
fulladder fa03(a[4], b[4], t[3], s[4], t[4]);
fulladder fa05(a[5], b[5], t[4], s[5], t[5]);
fulladder fa06(a
================================================================
example-44: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [(8 - 1):0, b[7:0]]=b;	 // make b [(8-1):0] in order to use the unsigned adder
wire [(8 - 1):0,a[7:0]] =a;	 // same a[7:(8-1)]


assign overflow = ((a[7] & ~b[7]) | (b[7] & a[7])); // Or if the highest bit of a is high then the adder should return a signed overflow

wire w1a = a[7] ^ b[7]; // a xor b //w1 is the a output with highest bit equal to high 
wire w1b = a[7] ^ b[7]; // b xor a 
wire w2a = w1a & a[6]; //intermediate a output (all less significant bits than a[7])
================================================================
example-45: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [8:0] r;

// 8-bit RCA (reduce adder)
fulladder f1(a[0], b[0], 1'b0, s[0], r[0]);
fulladder f2(a[1], b[1], r[0], s[1], r[1]);
fulladder f3(a[2], b[2], r[1], s[2], r[2]);
fulladder f4(a[3], b[3], r[2], s[3], r[3]);
fulladder f5(a[4], b[4], r[3], s[4], r[4]);
fulladder f6(a[5], b[5], r[4], s[5], r[5]);
fulladder f7(a[6], b[6], r[5], s
================================================================
example-46: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = a[7]&b[7] | a[7]&s[6] | b[7]&s[6];

// N is the most significant bit of a and b. The most significant bit of the output (s) is the least significant bit.
assign N = s[7];

assign zeros = 9'd000; //this is 6 bits
//The output is the least significant bit of the output is the most significant.
assign s = s[0]^N; 

================================================================
example-47: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 
// If the result s is to be a signed 2's complement
always@(*)
if (s[0] == 1'b1) 
begin
	s = ~s + i; // 2s complement
end
// check if the overflow flag is set high
assign overflow = s[7];//it is set high if the most significant bit is high




================================================================
example-48: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



================================================================
example-49: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s[0] = (a[0]^b[0])+(a[1]^b[1])+(a[2]^b[2])+(a[3]^b[3])+(a[4]^b[4])+(a[5]^b[5])+(a[6]^b[6])+(a[7]^b[7]); 
assign overflow=(s[7]^a[7])*(s[7]^b[7]);


================================================================
