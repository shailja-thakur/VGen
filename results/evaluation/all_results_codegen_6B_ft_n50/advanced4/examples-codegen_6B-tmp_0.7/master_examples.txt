example-0: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)
	q <= data;
	else if (ena)
	q <= {q[62:0], 1'b0};
	end

================================================================
example-1: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if (load)
	q<=data;
	else if (ena) begin
	case(amount)
	2'b00:
	q<={q[62:0],1'b0};
	2'b01:
	q<={q[55:0],8'b0};
	2'b10:
	q<={q[63],q[63:1]};
	2'b11:
	q<={q[63:8],q[63:9]};
	endcase
	end
	

================================================================
example-2: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk) begin
	if (load) q<=data[63:0];
	else if (ena) q<={q[62:0],1'b0};
	end

================================================================
example-3: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)

if (load)
	q <= data;
else if (ena)
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],8'b0};
	2'b10:	q <= {1'b0,q[63:1]};
	2'b11:	q <= {8'b0,q[63:8]};
	endcase

================================================================
example-4: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)
	begin
	q <= data;
	end
	else if (ena)
	begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,q[63]};
	2'b10:	q <= {q[56:0],q[63:1]};
	2'b11:	q <= {q[57:0],q[63:2]};
	endcase
	end
	end

================================================================
example-5: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if (load)
	begin
	q<=data;
	end
	else if (ena)
	begin
	case(amount)
	2'b00:	q<={q[62:0],1'b0};
	2'b01:	q<={q[55:0],8'b0};
	2'b10:	q<={q[63],q[63:1]};
	2'b11:	q<={q[63:8],q[63:8]};
	endcase
	end
	else
	q<=q;
end

================================================================
example-6: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always@(posedge clk)
	begin
	if (load)
	begin
	q<=data;
	end
	if (ena)
	begin
	case(amount)
	2'b00:
	begin
	q<={q[62:0], 1'b0};
	end
	2'b01:
	begin
	q<={q[55:0], 8'b0, 1'b0};
	end
	2'b10:
	begin
	q<={q[63], q[63:1]};
	end
	2'b11:
	begin
	q<={q[0], q[63:8]};
	end
	endcase
	end

================================================================
example-7: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if(load)
	q <= data;
	else if(ena)
	case(amount)
	2'b00:
	q <= {q[62:0],1'b0};
	2'b01:
	q <= {q[55:0],8'b0};
	2'b10:
	q <= {q[63],q[63:1]};
	2'b11:
	q <= {q[63],q[63:8]};
	endcase
	end

================================================================
example-8: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
begin
if(load)
q<=data;
else if(ena)
begin
case(amount)
2'b00:
q<=q<<1;
2'b01:
q<=q<<8;
2'b10:
q<=q>>1;
2'b11:
q<=q>>8;
endcase
end
end

================================================================
example-9: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
	if(load)
	begin
	q<=data;
	end
	else if(ena)
	begin
	case(amount)
	2'b00:	q<={q[62:0],1'b0};
	2'b01:	q<={q[55:0],8'b0};
	2'b10:	q<={q[63],q[63:1]};
	2'b11:	q<={q[0],q[63:8]};
	endcase
	end
	else
	begin
	q<=q;
	end
end

================================================================
example-10: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if(load)
	q <= data;
	else if(ena)
	begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55 : 0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};
	2'b10:	q <= {q[63],q[63:1]};
	2'b11:	q <= {q[63],q[63],q[63],q[63],q[63],q[63],q[63],q[63],q[62:8]};
	default:	q <= q;
================================================================
example-11: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load)
	q <= data;
	else if (ena)
	q <= q << amount;
	end

================================================================
example-12: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if (load)
	begin
	q <= data;
	end 
	else if (ena)
	begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],8'b0};
	2'b10:	q <= {q[63],q[63:1]};
	2'b11:	q <= {q[56:0],8'b0};
	endcase
	end
	else
	begin
	q <= q;
	end
end

================================================================
example-13: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load)
	begin
	case(amount)
	2'b00 : q <= {q[62:0],1'b0};
	2'b01 : q <= {q[55 : 0],data[63]};
	2'b10 : q <= {data[63],q[63:1]};
	2'b11 : q <= data;
	endcase
	end
	else if(ena)
	begin
	case(amount)
	2'b00 : q <= {q[62:0],1'b0};
	2'b01 : q <= {q[55 : 0],data[63]};
	2'b10 : q <= {data[63],q[63:1]};
	2'b11 : q <= data;
	end
================================================================
example-14: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
	begin
	if(load)
	q<=data;
	else if(ena)
	begin
	case(amount)
	2'b00:
	q<={q[60:0],1'b0};
	2'b01:
	q<={q[55:0],8'b0};
	2'b10:
	q<={q[63],q[63:1]};
	2'b11:
	q<={q[63:8],q[63:8]};
	endcase
	end
	end

================================================================
example-15: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load)
	q <= data;
	else if (ena)
	q <= q << amount;
	end

================================================================
example-16: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if (load)
	q <= data;
	else if (ena)
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],8'b0};
	2'b10:	q <= {1'b0,q[63:1]};
	2'b11:	q <= {8'b0,q[63:9]};
	endcase
	end

================================================================
example-17: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
	begin
	if(load)
	q <= data;
	else if(ena)
	q <= q << amount;
	end

================================================================
example-18: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)
	q <= data; 
	else if (ena)
	q <= {q[62:0],data[63]}; 
	end

================================================================
example-19: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if(load)
q <= data;
else if(ena)
begin
case(amount)
2'b00:	q <= {q[62:0],1'b0};
2'b01:	q <= {q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,q[63:1]};
2'b10:	q <= {q[54:0],q[63:1]};
2'b11:	q <= {q[51:0],q[63:2]};
endcase
	end
end

================================================================
example-20: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load)
	begin
	q<=data;
	end
	if(ena)
	begin
	case(amount)
	2'b00:q<={q[62:0],1'b0};
	2'b01:q<={q[55:0],8'b0};
	2'b10:q<={1'b0,q[63:1]};
	2'b11:q<={8'b0,q[63:9]};
	endcase
	end
end

================================================================
example-21: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(*) begin
	case(amount)
	2'b00: 
	begin 
	if(load) q<=data;
	else if (ena) q<={q[62:0],1'b0};
	end
	2'b01:
	begin
	if(load) q<={q[55:0],data[63:1]};
	else if (ena) q<={q[63],q[63:1]};
	end
	2'b10:
	begin
	if(load) q<={data[63:1],q[55:0]};
	else if (ena) q<={data[63:1],q[63:2]};
	end
	2'b11:
	begin
	if(load) q<={q[63:8],data[
================================================================
example-22: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if(load)
	q<=data;	
	else if(ena)
	begin
	case(amount)
	2'b00: q<={q[62:0],1'b0}; // shift left by 1 bit.
	2'b01: q<={q[55:0],8'b0}; //shift left by 8 bits.
	2'b10: q<={1'b0,q[63:1]}; // shift right by 1 bit.
	2'b11: q<={8'b0,q[63:8]}; // shift right by 8 bits.
	endcase
	end
	end

================================================================
example-23: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
	if (load) begin
	q <= data;
	end
	else if (ena) begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],1'b0,1'b0};
	2'b10:	q <= {1'b0,q[63:1]};
	2'b11:	q <= {1'b0,q[63:8]};
	endcase
	end
	else
	q <= q;
end

================================================================
example-24: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @(posedge clk)
begin
if(load)begin
q<=data;
end
else if(ena)begin
q<={1'b0,q[62:1]};
end
end

================================================================
example-25: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin 
if(load)
q<=data;
else if (ena)
begin
case(amount)
2'b00:begin 
q<={q[62:0],1'b0}; //shift left
end
2'b01:begin 
q<={q[55:0],8'b0}; //shift left
end
2'b10:begin 
q<={q[63],q[63:1]}; //shift right
end
2'b11:begin 
q<={q[0],q[63:8]}; //shift right
end
endcase
end

================================================================
example-26: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(*) begin
	if(load) q<=data; 
	if(ena) q<={q[62:0],1'b0}; // Since amount is 1 or 8, we use tri-state
end

================================================================
example-27: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if(load)
	q <= data;
else if(ena)
	begin
	case(amount)
	2'b00:
	begin
	q <= {q[62:0],1'b0};//shift left
	end
	2'b01:
	begin
	q <= {q[55:0],8'b0};//shift left
	end
	2'b10:
	begin
	q <= {1'b0,q[63:1]};//shift right
	end
	2'b11:
	begin
	q <= {8'b0,q[63:8]};//shift right
	end
	endcase
	end
	
================================================================
example-28: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin	
	if(load)
	begin
//	if(amount==2'b00)
	q <= {q[62:0],data[63]};
	end
	else if(ena)
	begin
//	if(amount==2'b00)
	q <= {q[55:0],q[63]};
	end
	end

================================================================
example-29: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
	begin
	if (load) q<=data;
	else if (ena) begin
	case(amount)
	2'b00: q<={q[62:0], 1'b0};
	2'b01: q<={q[55:0], 8'b0};
	2'b10: q<={1'b0, q[63:2]};
	2'b11: q<={8'b0, q[63:9]};
	endcase
	end
	end

================================================================
example-30: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
if(load) q<=data;
else if(ena) begin
case(amount)
2'b00:	q<={q[62:0],1'b0};
2'b01:	q<={q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};
2'b10:	q<={1'b0,q[63:1]};
2'b11:	q<={1'b0,q[63:8]};
endcase
	end
	end

================================================================
example-31: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
if (load)
	q <= data;
else if (ena)
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],8'b0};
	2'b10:	q <= {1'b0,q[63:56]};
	2'b11:	q <= {8'b0,q[63:56]};
	endcase

================================================================
example-32: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
if(load)
q<=data;
else if(ena)
q<={1'b0,q[62:1]};

================================================================
example-33: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if(load)
	q<=data;
	else if(ena)
	q<={q[62:0],1'b0};
	end

================================================================
example-34: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load)
	q = data;
	else if (ena)
	q = q << amount;
end

================================================================
example-35: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)// on positive clock edge
	begin
	if (load)// if load is high, retain previous value
	q<=data;
	else if (ena) // if enabled, perform shift
	case(amount)
	2'b00: q<={q[62:0],1'b0};
	2'b01: q<={q[55:0],8'b0};
	2'b10: q<={q[63],q[63:1]};
	2'b11: q<={q[0],q[63:8]};
	endcase
	end // close always posedge
	

================================================================
example-36: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin 
	if (ena) begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};
	2'b10:	q <= {q[63],q[63:1]};
	2'b11:	q <= {q[63],q[63:8]};
	endcase
	end
	else
	begin
	case(
================================================================
example-37: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load)
	q <= data[63:0];
	else if (ena)
	begin
	case(amount)
	2'b00: q <= {q[62:0],1'b0};
	2'b01: q <= {q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0
================================================================
example-38: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)
 	q <= data; 
	else if (ena)
	begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0,1'b0};
	2'b10:	q <= {q[63],q[63:1]};
	2'b11:	q <= {q[63],q[63:8]};
	endcase
	end
	end

================================================================
example-39: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load)
	q <= data;
	else if (ena)
	begin
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],8'b0};
	2'b10:	q <= {1'b0,q[63:1]};
	2'b11:	q <= {8'b0,q[63:9]};
	endcase
	end
	end

================================================================
example-40: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if(~load)
	begin 
	case(amount)
	2'b00:	q <= {q[62:0],1'b0};
	2'b01:	q <= {q[55:0],data[63]};
	2'b10:	q <= {data[62:0],q[63]};
	2'b11:	q <= data;
	endcase
	end
	if(ena)
	begin
	case(amount)
	2'b00:	q <= {q[55:0],1'b0};
	2'b01:	q <= {q[62:0],data[63]};
	2'b10:	q <= {data[63],q[63:1]};
	2'b11
================================================================
example-41: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if (load)
	begin	
	q <= data;
	end
	if (ena)
	begin
	case(amount)
	2'b00:
	begin
	q[63:1] = q[62:0];
	q[0] = 0;
	end
	2'b01:
	begin
	q[63:8] = q[56:0];
	q[7:0] = 0;
	end
	2'b10:
	begin
	q[63:0] = q[55:0];
	q[63] = 0;
	end
	2'b11:
	begin
	q[63:8] = q[55:0];
	q[7:0] = 0;
	end
	
================================================================
example-42: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	begin
	if (load) q <= data[63:0];
	else if (ena) begin
	case(amount)
	2'b00: q <= {q[62:0],1'b0};
	2'b01: q <= {q[55:0],8'b0};
	2'b10: q <= {1'b0,q[63:1]};
	2'b11: q <= {8'b0,q[63:9]};
	endcase
	end
	end

================================================================
example-43: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if(load)
	begin
	q<=data;
	end
	else if(ena)
	begin
	q<={q[62:0],1'b0};
	end
	end

================================================================
example-44: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
if(load)
q<=data;
else if(ena)
q<={1'b0,q[63:1]};

================================================================
example-45: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if (load)
	q<=data;
	else if (ena)
	begin
	case(amount)
	2'b00: q<={q[62:0],1'b0}; 	// shift left by 1 bit.
	2'b01: q<={q[55:0],8'b0};	// shift left by 8 bits.
	2'b10: q<={1'b0,q[63:1]};	// shift right by 1 bit.
	2'b11: q<={8'b0,q[63:8]};	// shift right by 8 bits.
	endcase
	end
	end

================================================================
example-46: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
	begin
	if (load)
	q <= data[63:0];
	else if (ena)
	q <= {q[62:0], 1'b0};
	end

================================================================
example-47: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	begin
	if(load)
	q<=data;
	else if(ena)
	begin
	case(amount)
	2'b00: q<={q[62:0],1'b0};
	2'b01: q<={q[55:0],8'b0};
	2'b10: q<={1'b0,q[63:1]};
	2'b11: q<={8'b0,q[63:9]};
	endcase
	end
	end

================================================================
example-48: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
 if(load)
	q<=data;
else if(ena)
	case(amount)
	2'b00:	q<={q[62:0],1'b0};
	2'b01:	q<={q[55:0],8'b0};
	2'b10:	q<={1'b0,q[63:1]};
	2'b11:	q<={8'b0,q[63:8]};
	endcase

================================================================
example-49: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
//	if (load)
//	begin
	if (load)
	begin
	q <= data;
	end
	if (ena)
	begin
	case(amount)
	2'b00:; // no change
	2'b01:	q <= {q[62:0],1'b0}; //shift left
	2'b10:	q <= {1'b0,q[63:1]}; // shift right
	2'b11:	q <= {q[55:0],1'b0}; // shift right
	endcase
	end
	end

================================================================
