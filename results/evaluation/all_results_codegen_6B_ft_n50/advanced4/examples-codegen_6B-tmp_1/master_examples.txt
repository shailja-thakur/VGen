example-0: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)begin

if(load)
q<=data;
else if(ena)
	case(amount)
	2'b00:	q<=q<<1'b1;
	2'b01:	q<=q<<8'b1;
	2'b10:	q<=q>>1'b1;
	2'b11:	q<=q>>8'b1;
	endcase
end

================================================================
example-1: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	begin
	if(load)
	q<=data;
	end
	else if(ena) begin
	case(amount)
	2'b00:
	q<={q[62:0],1'b0};
	2'b01:
	q<={q[55:0],8'b0};
	2'b10:
	q<={q[63],q[62:1]};
	2'b11:
	q<={q[63],q[52:1]};
	// 0000 shift left
	// 0001 shift left
	// 0010 shift right
	// 0011 shift right
	endcase
	end


================================================================
example-2: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if(load)
	begin
	q=data;
	end
	else if(ena)
	begin
	q={q[62:0],1'b0};
	case(amount)
	2'b00: ;
	2'b01: q=q<<1'b1;
	2'b10: q=q>>1'b1;
	2'b11: q=q>>8'b1;
	endcase
	end

================================================================
example-3: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @ (posedge clk)
	if(load & ena)	
begin
	if(amount==2'b00)	
begin 
	q=data;
end
	else if(amount==2'b01)	
begin 
	q={q[62:0],1'b0};
end
	else if(amount==2'b10)	
begin 
	q={1'b0,q[63:1]};
end
	else if(amount==2'b11)	
begin 
	q={q[60:0],1'b0};
end
end

================================================================
example-4: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	if(load)
	begin 
 //PC sends this message to itself and loads register
 
	if(ena)
	q<=data;
	
end
 

================================================================
example-5: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(*) 
	begin: Shift
	if (load) //redo the signetion of data so that e.g. vlaue is y and vpredict is x.
	<= #(ena ? 0 : amount[1]) data[63:0];
	//if(load) q<=data;
	else if ((ena ? amount[1]: 0) != 0) begin
	q <= #amount q >> 1; //number based on how you instantiate advshift.
	//	q<={q[62:0], 1'b0}; //number based on how you instantiate advshift.
	end
	end;

================================================================
example-6: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)	
	begin
	
	if(!data[63])
	begin
	
	if(load) q<=data[63:0];
	
	else if(ena)
	case(amount)
	
	2'b01: q<={q[62:0],data[63]};
	2'b10: q<={data[63],q[63:1]};
	2'b11: q<={data[63],q[63:8]};
	
	endcase
	
	else q<=q;
	
	end
	
	
	
================================================================
example-7: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)
	begin
	q = data;
	end
	if (ena)
	begin
	case(amount)
	2'b00: 
begin
q=q<<1'b1;
end
2'b01:
begin 
q=q<<'d8;
end
2'b10:
begin
q=q>>1'b1;
end
2'b11:
begin
q=q>>'d8;
end
endcase
end
end

================================================================
example-8: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @(posedge clk)
 
if (load)
	q <= data;
else if (ena)
	begin
	case(amount)
	2'b00:begin 	q<=q<<1;	end
	2'b01:begin 	q<=q<<8;	end
	2'b10:begin 	q<=q>>1;	end
	2'b11:begin 	q<=q>>8;	end
	endcase
	end

================================================================
example-9: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
begin
 if(load)
 q <= data;
 else 
 begin
 if (ena)
	begin
	case(amount)
	 // Amount == 0: reference stays the same.
	 2'b00:
	 	q <= q;
	 2'b01:
	 	q <= q << 1;
	 2'b10:
	 	q <= q << 1;
	 2'b11:
	 	q <= {q[54:0],1'b0};
	 endcase
	end
end

================================================================
example-10: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	q <= data;
	if (load) // what should this be??? is this correct?
	q <= {32'b0,data[63:1]}; 
	else if (ena) //Shift by 1,2,4,8,16,32,64,128 
	 q <= q << (amount[2:0]); //Sends a signal to latch what direction and how far to shift.
	end

================================================================
example-11: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)begin 
	if (load) q = data;	
	else if (ena) begin
	case(amount)
	//2'b00:
	2'b01:
	2'b10:
	//2'b11:
	2'b11:q = q>>1;
	default:q = q;
	endcase
	end 
	end

================================================================
example-12: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	if(load)
	begin
	q = data;
	end
	else if(ena)
	begin
	q = q >> amount;
	end
 

================================================================
example-13: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
//always @(posedge clk or posedge nrst) //a or b, not sure which one to use.
	case(amount)
//	2'b00: 
//	begin	
//	 q <= {q[62:0],data[63]};
//	end
	2'b01: 
	begin	
	 q <= {q[55:0],data[63:56]};
	end
	2'b10: 
	begin	
	 q <= {data[63:56],q[63:1]};
	end
	2'b11: 
	begin	
	 q <= {q[63],data[63:1]};
	end
	endcase

================================================================
example-14: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (clk)
	begin
	if (load)
	begin
	q <= data;
end	
	else if (ena)
	begin
	q <<= amount;
	//$display("Amount: %d Data: %h", amount,data);
end
	end

================================================================
example-15: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
	begin
	 if(load)
	 q<=data;
	 else if(ena)
	 begin
	 case(amount)
	 	2'b00:	q<={q[62:0], 1'b0};
	 	2'b01:	q<={q[47:0], 8'b0};
	 	2'b10:	q<={q[55:0], 2'b0};
	 	2'b11:	q<={q[63:0], 3'b0};
	 endcase
	end
	end

================================================================
example-16: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
	if(load)
	begin
	q<=data;
	end
	else if(ena)
	begin
	case(amount)
	2'b00: q<= {q[60:0],1'b0};
	2'b01: q<={q[55:0],1'b0,1'b0,1'b0};
	2'b10: q<={1'b0,q[63:1]};
	2'b11: q<={1'b0,q[63:8]};
	endcase
	end
	else
	q<=q;

================================================================
example-17: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @(posedge clk) 
	begin
	if(load) 
q<=data;
	else 
	case(amount)
	2'b11:	q<={q[62:0],1'b0};;
	2'b10:	q<={q[55:0],8'b0,1'b0};;
	2'b01:	q<={q[63:0],1'b0,q[63:1]};
	2'b00:	q<={q[63:0],q[63:1]};
	endcase
	end

================================================================
example-18: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
//	if (load)	
//	begin
	if (load)
	begin
	q <= data;
//	end
	end
	always @ (ena)
	begin 
	if (ena)
//	begin	
	begin
	case (amount)
	2'b00: ;
	2'b01: q = q << 1;
	2'b10: q = q >> 1;
	2'b11: q = q >> 1;
	endcase
	end
	end	

================================================================
example-19: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @(posedge clk)
if (load)
q<=data[63:0]; 
else if (ena)
begin
case(amount)
2'b00: q<={q[62:0],1'b0};
2'b01: q<={q[55:0],8'b0};
2'b10: q<={1'b0,q[63:1]};
2'b11: q<={8'b0,q[63:8]};
endcase
end

================================================================
example-20: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
begin	
	if (load)
	begin
	q <= data[63:0]; // Asynchronous load, shifts in the data.
	//$display($time," Loading: %d",q[0]);
	end
	else if (ena)
	begin	
	case(amount) // Do shift in the amount specified.
	2'b00: q <= q<<1;
	2'b01: q <= q<<8;
	2'b10: q <= q>>1;
	2'b11: q <= q>>8;
	//$display($time," Shifting: %d",q[0]);
	endcase
	end
	else 
	begin	
	//$display($time," Nothing");
	q <= q;
	end
end

================================================================
example-21: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if(load)
q <= data;
else if(ena)
begin
case(amount)
2'b00:
q <= {q[62:0],1'b0};
2'b01:
q <= {q[55:0],8'b0};
2'b10:
q <= {1'b0,q[63:1]};
2'b11:
q <= {8'b0,q[63:9]};
endcase
end

================================================================
example-22: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always@(posedge(clk) ) 
begin
	if(load)
	begin
	q<=data;
	end
	else if(ena)
	begin
	$display("ena");
	q<={q[62:0],1'b0};
	end
	
end

================================================================
example-23: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
begin
if (load)
q<=data;

else if (ena)
case (amount) //amount is selecting which direction to shift and how far
2'b00 : //Shift left by 1
begin
	q<={1'b0,q[62:1]}; // shift left by 1 bit
end
2'b01 : //Shift left by 8
begin
	q<={q[55:0],1'b0}; // Shift left by 8 bits
end
2'b10 : //Shift right by 1
begin
	q<={q[63],q[63:1]}; // Shift right by 1 bit
end
2'b11 : //Shift right by 8
begin
	q<={1'b0,q[63:8]}; // Shift right by 8 bits
end
endcase

================================================================
example-24: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if (load) // only do operation if load is high.
	begin
	case (amount) // tell how much to shift
	2'b00: // shift left by 1 bit.
	begin 
	q = {q[62:0],1'b0}; // assign the last bit to 0.
	end
	2'b01: // shift left by 8 bits.
	begin 
	q = {q[55:0],8'b0}; // assign the last 8 bits to 0.
	end
	2'b10: // shift right by 1 bit
	begin 
	q = {1'b0,q[63:1]}; // assign the first bit to 0.
	end
	2'b11: // shift right by 8 bits
	begin 
	q = {8
================================================================
example-25: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
 
	if (load)
 	q <= data;
	else if (ena)
 	q<= {q[62:0],1'b0}; // since q<={q[5],q[4],q[3],q[2],q[1]};
	end
 
 

================================================================
example-26: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge (clk))
	begin
	if (load)
	q <= data[63:0];
	else if (ena)
	case(amount) // amount is only 1 or 8.
	 2'b00: q <= q << 1;
	 2'b01: q <= {q[62:0],1'b0};
	 2'b10: q <= {1'b0,q[63:1]};
	 2'b11: q <= {q[0],q[63:1]};
	endcase
end

================================================================
example-27: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
	begin
	if (load)
	begin
	q<=data[63:0];
	end 
	else if (ena)
	begin
	case(amount) // case for direction and size of shift
	//amount<= 0: Left shift.
	//amount<= 1: Right shift.
	//amount<= 2: Invert the bits.
	//amount<= 3: No change.
	1'b0, 1'b1, 1'b2:
	begin
	if(amount==1'b0) // amount 0 or 1, Perform Left shift.
	begin
	q[63:1]=q[62:0];
	q[0]=0;
	end
	if(amount==1'b1) // amount 0 or 1, Perform Right shift.
	begin
================================================================
example-28: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) 
	begin 
if (load)	
q<=data;
	else if (ena)	
	begin
	case(amount)	
	2'b00:begin 
end
2'b01: begin 
	q<={q[62:0],1'b0};
end
2'b10: begin 
	q<={1'b0,q[63:1]};
end
2'b11: begin 
	q<={q[63],q[63:1]};
end
endcase	
	end
	
================================================================
example-29: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @(posedge clk)
begin	
	if(load)//reg
	begin
 	q<=data;
	end
	if(ena)//shift
	begin
	case(amount)
	2'b00://shift left by 1 bit
	begin
	q[63:1]<={q[62:0],1'b0};//shift left
	q[0]<=q[63];//low bits become first bit
	end
	2'b01://shift left by 8 bits
	begin
	q<={q[56:0],1'b0};//shift left
	end
	2'b10://shift right by 1 bit
	begin
	q<={1'b0,q[63:1]};//shift right
	q[0]<=1'b0;
================================================================
example-30: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	 q[63:0] = ({64{load}} & data[63:0]) | ({64{ena}} & {q[63:0], amount}); //amount bit for direction
	end 

================================================================
example-31: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load)q<=data;
	else if(ena)begin
	case(amount)
	2'b0:	q<={q[62:0], 1'b0};
	2'b1:	q<={q[55:0], 8'b0, 1'b0};
	2'b10:q<={q[63], q[63:1]};
	2'b11:q<={q[55:0], 8'b0, q[63:8]};
	endcase
	end
end

================================================================
example-32: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	
always @(posedge clk)
begin
	if (load)
 	begin
 	q <= data; //load the D Flip Flop into shift register.
 	end
 	if (ena) //if shift is enapled
 	begin
 	case(amount) //amount should be equal to switchs used to implement amount, {ls{1'b1}, rs{1'b1}}.
 	2'b00: /*amount == 2'b00*/ q <= q; //no change
 	2'b01: /*amount == 2'b01*/ q <= {q[62:0],1'b0}; //shift left, adds 0.
 	2'b10: /*amount == 2'b10*/ q <= {q[63],q[63:1]}; //shift right, adds 1.
 	2'
================================================================
example-33: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk) begin
	 if (load) q<=data;
	 else if (ena) q<={q[61:0],1'b0};
end

================================================================
example-34: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(data)
case(amount)
2'b00 : q<=data;
2'b01 : q<={data[56:0],32'd1}; // number 2
2'b10 : q<={q[56:1],data[63:57]}; //number 0
2'b11 : q<={q[60:0],data[63:61]}; //number 1

endcase

================================================================
example-35: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if (load)	
	q <= data;
	else if (ena)
	begin
	case(amount)
	2'b00: q <= q << 1;
	2'b01: q <= q << 8;
	2'b10: q <= q >> 1;
	2'b11: q <= q >> 8;
	endcase
	end
	end

================================================================
example-36: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
	begin
	if(load)	
	q = data;
	else if(ena)
	begin
	case(amount)
	2'b11:	q = {q[62:0],1'b0};
	2'b10:	q = {q[55:0],2'b0};	
	2'b01:	q = {q[48:0],4'b0};	
	2'b00:	q = {q[42:0],6'b0};
	endcase
	end
	end

================================================================
example-37: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	if(load | ena)
	begin
// If amount is four bits, then there are four cases:
// if direction is left shift, perform: {{16{q[63]}}, q[63:16]};
// if direction is right shift, perform: {{48{q[15]}}, q[63:48]};
// if direction is LR support, perform: {{16{q[63]}}, q[63:16]};
// if direction is LR support, perform: {{48{q[23]}}, q[63:48]};
	if(amount==2'b00)
	begin
	q<={q[62:0],data[63]};
	end
	if(amount==2'b01)
	begin
	q<={q[55:0],data[63]};
	
================================================================
example-38: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if (load)
	begin
	q <= data;
	end
	else if (ena)
 	q <= {q[62:0],1'b0,1'b0};
end

================================================================
example-39: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin 	
	if (load)
	begin
	q<=data;
	end
	else if (ena)
	begin
	q<={~q[62:0],1'b0};
	end
	end

================================================================
example-40: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
if (load)
q <= data; 
if (ena)
	begin
	case(amount)
	2'b00: /* no change */
	begin
end
	2'b01: 
	begin
	q={q[62:0],1'b0};
end
	2'b10: /* no change */
	begin
end
	2'b11:
	 begin
	q={1'b0,q[63:1]};
end
	 /*
	// insert comment to verify output
	always@(q)
	begin 
	//	if (q[3'd1]==2'b00)
	//	q[3'd1]=2'b01;
	//	else if (q[3'd1]==2'b01)
	
================================================================
example-41: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	 always @ (posedge clk) 
	 begin
	 if (load)
	 q <= data; 
	 else if (ena) 
	 q <= {q[62:0],1'b0}; 
	 end

================================================================
example-42: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk) begin
	if(load) q<=data;
	else if(ena) q<={q[62:0],1'b0};
end

================================================================
example-43: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk) begin
	if(load || ena) begin
	q=data;
	end
	if(ena)begin
	case(amount)
	2'b00:begin
	q={q[62:0],1'b0};
	end
	2'b01:begin
	q={q[50:0],q[63:1]};
	end
	2'b10:begin
	q={q[40:0],q[63:41]};
	end
	2'b11:begin
	q={q[30:0],q[63:31]};
	end
	endcase
	end

================================================================
example-44: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
begin 
	if (load) // only consider the case of shift based upon load
	begin 
 	 	if (ena) // only shift when ena is high 
 	 	begin 
 	 	case(amount) // amount of shift to be done based on no
	 	2'b00:begin // shift left by 1 bit
 	 	 	if(q[63]) // if q[63] is 1 then only shift left by 1
 	 	 	begin 
 	 	 	

 	 	 	 	q <= {q[62:0],data[63]}; //else shift left by 1

 	 	 	 	end
 	 	 	else
 	 	 	begin 
 	 	 	

 
================================================================
example-45: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) // always because this happens on posedge
begin
if(load) // if load is high, output that data
	q <= data; 
else 
if(ena) // if ena is high, shift based on amount
begin
case(amount) // how is it shifted?
2'b00: q <= {q[58:0],1'b0}; // shift left 
2'b01: q <= {1'b0,q[59:1]}; // shift left 
2'b10: q <= {q[40:0],q[63:41]}; // shift right 
2'b11: q <= {q[39:0],1'b0}; // shift right 
endcase
end // if
end // always

================================================================
example-46: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	case(amount)
	2'b00:
	begin
	q[63:1]=q[62:0];	// shift left by 1 bit
	q[0]=0;
	end
	2'b01:
	begin
	q[63:8]=q[57:0];	// shift left by 8 bits
	q[7:0]=0;
	end
	2'b10:
	begin
	q[0]=0;
	q[63:1]=q[62:0];	// shift right by 1 bit
	end
	2'b11:
	begin
	q[63:8]=q[55:0];	// shift right by 8 bits
	q[71:8]=0;
	end
	endcase	
end

================================================================
example-47: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk) // for each clock cycle, perform shift on load
	begin
	if ((load) & (ena)) // rshift
	q <= {q[62:0], 1'b0};
	else if ((amount == 2'b11) & (ena)) // lshift
	q <= {1'b0, q[63:1]};
	else if ((amount == 2'b00) & (ena)) // lsrot
	q <= {q[63], q[63:1]};
	else if ((amount == 2'b01) & (ena)) // rsrot
	q <= {q[1], q[63:2]};
	end

================================================================
example-48: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk) begin
	if (load) q = data; 
	else if (ena) 
	begin
	case(amount)
	2'b00: q = q << 1; //if amount is 00, perform left shift
	2'b01: q = q << 8; //if amount is 01, perform left shift
	2'b10: q = q >> 1; //if amount is 10, perform right shift
	2'b11: q = q >> 8; //if amount is 11, perform right shift
	default: q = q; // amounts 00 and 01 are left shifts, 02 and 03 are right shifts
	endcase
	end
	end

================================================================
example-49: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
	begin
	if (load) // if load is high, data is written into shift register q.
	q <= data; 
	else if(ena) // if shift is enabled, q is shifted. //ONLY enabled when ena is high.
	begin
	if(amount==2'b00) // the leftmost bit is shifted out.
	q <= {q[62:0], 1'b0}; 
	else if(amount==2'b01) // shifts 8 bits to the right.
	q <= {q[55:0], 8'b0};
	else if(amount==2'b10) // shifts the rightmost bit out.
	q <= {q[63], q[63:1]}; 
	else // shifts 8 bits to the left.
	q <= {q[56:0
================================================================
