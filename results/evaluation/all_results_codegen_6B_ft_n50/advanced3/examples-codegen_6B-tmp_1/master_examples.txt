example-0: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @(present_state) 
	case(present_state)
	IDLE: next_state=x ? S1 : IDLE;
	S1: next_state = x ? S10: IDLE;
	S10: next_state = x ? S101: IDLE;
	S101: next_state = x ? S1 : IDLE;
	default: next_state = IDLE;
	endcase
	// output logic
	always@(present_state)
	case(present_state)
	IDLE:begin
	z=0;
	end
	S1:begin 
	z=0;
	end
	S10:begin 
	z=0;
	end
	
	S101:begin 
	z=1;
	end
	endcase
	
	always@(posed
================================================================
example-1: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk ) 
begin 
if (reset)
present_state<=IDLE;
else 
present_state<=next_state;
end 



always @(present_state,x) 
case (present_state) 
 	IDLE: 	if (x) 
	next_state<=S1;
	else 
	next_state<=IDLE;
	S1: 	if (x) 
	next_state<=S2;
	else 
	next_state<=IDLE;
	
	S2: 	if (x) 
	next_state<=S2;
	else 
	next_state<=S1;
	
	
	S10: 	if (x) 
	next_state<=S101
================================================================
example-2: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @(posedge clk, posedge reset) 
begin 
	if (reset) 
	present_state <= IDLE;
	else 
	present_state <= next_state;
end 
 
 
assign next_state = (S1==present_state) ? S1 : ((S1==S10) ? S1 :((S101==present_state) ? S101 : IDLE));
assign z = (present_state == S101) ? 1:0; 

================================================================
example-3: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(*) 
	begin: state_table 
	case(present_state)
	IDLE: 
	if (reset) next_state = S1; 
	else next_state = IDLE; 
	S1: 
	if (x) next_state = S10; 
	else next_state = IDLE; 
	S10: 
	if (x) next_state = S101; 
	else next_state = IDLE;
	S101: 
	if (x) next_state = S1; 
	else next_state = IDLE;
	default: next_state = IDLE;
	endcase
	end // state_table

	always @(posedge clk)
	begin: state_FFs
	if(reset)
	present_state <= IDLE; 
================================================================
example-4: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 
always @(x, present_state)
case(present_state)
IDLE: if(x) 
	begin
	next_state= S1;
	end
	else
	begin
	next_state=IDLE;
	end
	
S1: if(x) 
	begin
	next_state= S10;
	end
	else
	begin
	next_state = IDLE;
	end

S10: if(x) 
	begin
	next_state = S101;
	end
	else
	begin
	next_state= S10;
	end



S101:if(x) 
	begin
	next_state=S1;
	end
	else
	begin
	next_state=IDLE;
	end

endcase


always @(
================================================================
example-5: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(*)
begin 
case(present_state) 
 IDLE: 	if (x) next_state=S1;
	else next_state = IDLE;
	
 S1: 	 if (x) next_state = S10;
	else next_state = IDLE;
	 
 S10: if (x) next_state = S101;
	else next_state = IDLE;
	 
 S101: if (x) next_state = IDLE;
	else next_state = S1;
	endcase
end
/*

 present_state = next_state;

end

 */


always @(posedge clk)
begin
if (reset) 
present_state <= IDLE;
else 
present_state <= next_state;
end

assign z = ((present_state
================================================================
example-6: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


	assign v=present_state[1];
	
//Update state trace

/*
reg [1:0] present_state,next_state;
parameter IDLE=0, S1=1;
assign v =present_state[1];
always @(posedge clk) 
	present_state <= next_state;

always @(present_state or x)
begin 
	case(present_state)
	0: beginif(x==1'b1) match=1;else match=0;end 
	1:beginif(x==1'b1)match=1;else match=0;end 
	2:if( x==1'b1) next_state=S1;else force back to idle 
	3:if( x==1'b1)next_state=S1;
================================================================
example-7: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 
always @(posedge clk) 
begin 
	if(reset)
	present_state <= IDLE; 
	else 
	present_state <= next_state; 
end 
	
assign output1 = (present_state == S101);


================================================================
example-8: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(*)begin 
	if (rst) present_state=IDLE; 	/*reset asserted*/ 
	else	present_state=next_state;
	case (present_state)
	IDLE: if (x) next_state=S1;
	S1: if (x) next_state=S10; 
	S10: if (x) next_state=S1; 
	S101: if (x) next_state=IDLE; 
	default: next_state=IDLE;
	endcase
	/*code for z*/
	case(present_state)
	IDLE:if(rset)z=1;
	S1:if(rset)z=0;
	S10:if(rset)z=0;
	S101:if(rset)z=0
================================================================
example-9: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(posedge clk or posedge reset)
if(present_state == S101) 
z = 1; 
else 
z = 0; 

always@(posedge clk or posedge reset)
present_state = next_state; 
// always determine the next state using a case statement or



always@(present_state or x) 
 
case(present_state) 

IDLE:if(x) 
next_state=S1; 
else 
next_state=IDLE;
S1:if(x) 
next_state=S10; 
else 
next_state=S1; 
S10: if(x) 
next_state=S101; 
else 
next_state=S10; 
S101:if(x) 
next_
================================================================
example-10: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @()
begin 
case(present_state) 
	IDLE: if(x) next_state = S1; 
	else next_state = IDLE;
	S1: if (x) next_state = S10; 
	else next_state = IDLE;	
	S10: if (x) next_state = S101; 
	else next_state = IDLE;	
	S101: if (x) next_state = S1; 
	else next_state = IDLE;	
	default: next_state = IDLE;
endcase
 end

always @(posedge clk or posedge reset) // for viewing and block execution of non blocking statements
begin 
	if (reset) // if reset is high
	present_state = IDLE; // execution happens within the current state cycle
	
================================================================
example-11: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	
always @(posedge clk, posedge reset) 
	begin 
	if(reset) 
	present_state <= IDLE; 
	else 
	present_state <= next_state; 
	end 
	
	
	always @(**) 
	next_state = present_state; 
	
	assign z = (present_state == S101) ? 1:0; 
	//z is the output of the FSM which is sent to output ports 
	
	

================================================================
example-12: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk)
begin
if(reset) 
present_state = #1 IDLE; 
else
present_state = #1 next_state;
end

always @ (x,present_state) //next state is assigned next state present_state.x 
begin
case(present_state)
	IDLE:
	if(x) next_state = S1; 
	else next_state = IDLE; //to illustrate procedural present state
	S1: 
	if(!x) next_state = IDLE; 
	else next_state = S10;
	S10: 
	if(!x) next_state = S1; 
	else next_state = S10;
	S101: 
	if(!x) next_state = S2; 
	else next_state
================================================================
example-13: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always@(present_state,x)
	begin 
	case(present_state)
	IDLE: if(x) next_state=S1;
	else next_state=IDLE;
	S1: if(x) next_state=S10;
	else next_state=IDLE;
	S10: if(x) next_state=S101;
	else next_state=IDLE;
	S101: if(x) next_state=S1;
	else next_state=IDLE;
	default: next_state=IDLE;
	endcase
	end
assign z = (present_state==S101); 


================================================================
example-14: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk or posedge reset) //define the state machine
begin 
if (reset) //if rest is true
present_state = IDLE; 
else 
present_state = next_state; //else set it bipassing
end 

assign z = (present_state==S101); //set the output

//the next stat will be set on the next clock cycle when both the current state and the input are equal to eachother
always @ (posedge clk or posedge reset) // define the next state
begin 
if (reset) //if rest is true
next_state = IDLE; 
else 
case(present_state) 
IDLE: if(~x) 
next_state = S1; 
else 
next_state = IDLE; 
S1: if(x) 
next_
================================================================
example-15: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or posedge reset) 
	begin 	
	if(reset==1'b1) 
	present_state<=IDLE; 
	else 
	present_state<=next_state; 
	end 
	
always @(posedge clk or posedge reset) 
	begin 	
	if(reset==1'b1) 
	next_state<=IDLE; 
	else 
	case(present_state) 
	IDLE: 
	casex(x) 
	1'b0: next_state<=S1; 
	1'b1: next_state<=S10; 
	endcase 
	endcase
	
================================================================
example-16: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


// if signs are equal, MC is not neccessary

always@(posedge clk )
present_state<= next_state;
always@(*)
begin 

case(present_state) 
IDLE: if(x) next_state<= S1; else next_state<=IDLE;
S1: if(x) next_state<= S10; else next_state<=IDLE;
S10: if(x) next_state<= S101; else next_state<=IDLE;
S101: if(x) next_state<= S1; else next_state<=IDLE;

//default:next_state = IDLE;
endcase
end 

reg MC; // starts logic of Moore-Cascading
always@(posedge clk )
begin 
MC = 1; 
================================================================
example-17: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk) 
begin
	if (reset) 
	 present_state <= IDLE; 
	else 
	 present_state <= next_state;
end
always @ ( present_state or x ) 
begin 
case(present_state)
	IDLE: 
	 if ( x ) 
	 next_state = S1;
	else 
	 next_state = IDLE;
	 S1: 
	 if ( x ) 
	 next_state = S10;
	else 
	 next_state = IDLE;
	 S10: 
	 if ( x ) 
	 next_state = S101;
	else 
	 next_state = IDLE;
	 S101: 
	 if ( x ) 
	 next_state = S1;
	else 
	 next
================================================================
example-18: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 assign z = (present_state==S101); 
 
always @(posedge clk) 
if (reset) 
	present_state <= IDLE; 
else 
	present_state <= next_state; 

================================================================
example-19: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(x, present_state)
begin
	case(present_state)
	 IDLE: if(x)
next_state=S1; // S0 -> S1 transition when set is asserted 
	 S1: if(x)
next_state=S10; // S1 -> S10 transition if set is high 
	 S10: if(x)
next_state=S100; // S10 -> S100 transition if set is high
	 S100: if(x)
next_state=IDLE; // Exiting the system. Corresponds to a reset 
	default:next_state=IDLE; // prevents undefined output
	endcase
end

// output logic
always@(posedge clk) 
begin 
	case(present_state)
	 IDLE: if(x)
	z=1; // High if
================================================================
example-20: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk ) 
begin //counts when the clock is positive edge triggered 
 if(reset) 
	present_state <= IDLE; 
 else //if(rst) 
	present_state <= IDLE; 
	
if (present_state == S101)
begin 
z = 1; 
if (x == 0) 
	next_state <= S1; 
else 
	next_state <= S10; 
end 
	 
else if (x == 1) 
	next_state <= S101; 
	 
else 
	next_state <= IDLE;
	 
case(present_state) 
IDLE: if (x) 
	next_state <= S1; 
	if(~x) 
	next_state <= S10; 
	
================================================================
example-21: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk) 
begin
if(~reset) 
present_state = 0; 
else 
present_state = next_state;
end 
 
always @ (posedge clk) 
begin 
if(~reset) 
next_state = 0; 
else 
begin 
case(present_state) 
 //IDLE:begin
 
 //if (x) 
 //next_state = S1; 
 if(x) 
 next_state = S1; 
 else 
 next_state = S10; 
 //end 
 //S1:begin 
 if (x) 
 next_state = S101; 
 else 
 next_state = S10; 
 //end
 /* S10:begin 
 if (x) 
 next_state = S101
================================================================
example-22: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 
always @(posedge clk, posedge reset)
 	begin
 	if(~reset)
 	present_state <= IDLE;
 	else
 	present_state <= next_state;
 	end

always @(present_state,x)
 	case(present_state)
 	IDLE: if(~x)
 	 next_state = S1;
 	S1: if(x)
 	 next_state = S10;
 	S10: if(~x)
 	 next_state = S101;
 	S101: if(x)
 	 next_state = IDLE;
 	default: next_state = IDLE;
 	endcase
 // $display($time,"ns:state=%b",present_state);
 // $display($time,"ns
================================================================
example-23: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or posedge reset)
	if(reset) 
	present_state <= IDLE ;
	else 
	present_state <= next_state ;
	
// next_state should not be declared as a reg because it can change 
// and // next_state = curr_state ; is not sufficient

always @(present_state,x)
begin
case(present_state)
IDLE: if(x) 
next_state <= S1 ;
else 
next_state <= IDLE ;
S1: if(x) 
next_state <= S10 ;
else 
next_state <= IDLE ;
S10: if(x) 
next_state <= S101 ;
else 
next_state <= IDLE ;
S101: if(x) 
next_state <= S10 ;

================================================================
example-24: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 

begin
case(present_state)
IO: begin 
if(rst) 
next_state = IDLE; 
else if(x)
next_state = S1; 
else 
next_state = IO; 
z = 1'b0; 
end 
 
S1: begin 
if(!x) 
next_state = S1; 
else 
next_state = S10; 
z = 1'b0; 
end 

S10: begin 
if(!x) 
next_state = IO; 
else 
next_state = S101; 
z = 1'b0;
 end 
 
S101: begin 
if(!x) 
next_state = IO; 
else 
next_state = S1; 
z
================================================================
example-25: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 
always @(*) begin 
if (present_state == S1) 
case(x)
1:next_state = S1;
0:next_state = IDLE;
endcase
else if(present_state == S10) 
case(x)
1:next_state = S1;
0:next_state = S10;
endcase
else if(present_state == S101) 
case(x)
1:next_state = S1;
0:next_state = S10;
endcase
else 
case(x)
1:next_state = S1;
0:next_state = S101;
endcase
endcase

always @(posedge clk, posedge reset) begin
	if(reset) 
present_state <= IDLE;
	else
present_state <= next
================================================================
example-26: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(present_state,x) 
case(present_state)
IDLE: 
if(x) 
	next_state=S1;
else 
	next_state=IDLE;

S1: 
if(x) 
	next_state=S10;
	else 
	next_state=IDLE;
	

S10:
if(x) 
	next_state=S101;
	else 
	next_state=IDLE;

S101:
if(x) 
	next_state=S1;
	else 
	next_state=IDLE;
	
default:
next_state=IDLE;
endcase

//reset logic here

assign z = (present_state==IDLE)&(~reset);
always@(posedge cl
================================================================
example-27: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk or posedge reset)
begin 
 if (reset) 
	present_state <= IDLE; 
else 
	present_state <= next_state ; 
end 

always @ (x or present_state)
begin 
case(present_state) 
IDLE : begin 
	if (x==1) 
	next_state= S1;
	else 
	next_state=IDLE ; 
	end 
S1:begin 
	if (x==0) 
	next_state=S10;
	else 
	next_state=IDLE ;
	end
S10:begin 
	if (x)
	next_state = S101;
	else 
	next_state = S10 ;
	end 

S101: begin 
	
================================================================
example-28: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk) 
begin 
 if (reset) 
	present_state <= IDLE; 
else 
	present_state <= next_state; 
end 
 
always @ (present_state or x) 
begin 
 if (x==1) 
 begin 
next_state = S1; 


 end 
 else if (x == 0) 
	 next_state = IDLE; 
	 else 
	 next_state = S1; 
	end 
	 
assign z=(present_state == S101) ? 1:0; 

================================================================
example-29: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk) 
	present_state <= next_state;

always @(x)
begin
	case(present_state)
	IDLE: 
	 	begin
	 	if(reset) 
	 	next_state=S1;
	 	else
	 	next_state=IDLE;
	 	end
	S1:
	 	 begin
	 	if(x)
	 	next_state=S10;
	 	else
	 	next_state=S1;
	 	end
	S10:
	 	begin
	 	if(x)
	 	next_state=S101;
	 	else
	 	next_state=S1;
	 	end
	S101:
	 	next_
================================================================
example-30: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(posedge clk)
begin
if (z);
	case(present_state)
	IDLE: if(x);
	S1: if(!x);
	S10: if(x);
	S101: if(!x);
	endcase
	else;
	
	always @(*)
	{pres,nexts}={present_state,next_state};
	end

================================================================
example-31: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk)
if (reset) present_state <= IDLE; 
else present_state <= next_state;

// next_state is a 3 bit bus
always @ (*) 
case(present_state) 
IDLE: if (x) next_state <= S1; 
else next_state <= IDLE;

S1: if (x) next_state <= S10; 
else next_state <= S1;

S10: if (x) next_state <= S101; 
else snext_state <= S1;

S101: if (x) next_state <= S1; 
else next_state <= S10;

default next_state <= IDLE;
endcase

always @ (*)
case(present_state) 
IDLE: z= 0; 
S1
================================================================
example-32: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or posedge reset)
 if(present_state==IDLE) 
	next_state <= S1;
 else 
	next_state <= present_state;

assign z=(present_state==S101)&(x);

always @(posedge clk ) // to keep it in just for the giver of the question, make it outside if
	if (reset||next_state==System.IDLE ) 	
	//iao dian
	begin 
	present_state<=IDLE;
	end 
	else 
	//chen xinh, dung de la zo
	present_state<=next_state; 

================================================================
example-33: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(posedge clk or posedge reset)
	begin
	if (reset) //highs the current state to state IDLE
	present_state = IDLE;
	else //set's the output to 1 if in state S101 a high transition is detected
	begin
	if (present_state == S101) z = 1;
	else z = 0;
	//if at posedge clk, sets a new output value
	if (posedge clk)
	begin
	case (present_state)
	IDLE: //state IDLE has no transitions
	begin
	if (~x) 
	begin 
	next_state = S1;
	z = 0;
	end
	else 
	begin 
	next_state = IDLE;
	z = 0;
	end
	end
	S1: //
================================================================
example-34: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 always @(posedge clk or posedge reset)
	if(reset)
 	present_state<= IDLE; 
 	
	else 
	present_state<=next_state;
	
// state transfers
always @(*)
begin: state_table

case(present_state) 
IDLE: next_state= x? S1:IDLE;
S1: next_state=S10;
S10: next_state=x? S1: S10;
S101: next_state=x? S1: S10;
default: next_state=IDLE;
endcase
end


always @(posedge clk or posedge reset)
begin 
if(present_state==S101)
z=1;
else 
z=0; 	
end


================================================================
example-35: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk) 
present_state <= next_state; 

always @(posedge clk) 
if (reset) next_state = IDLE; 
else begin 
z = 1'd0; 
case (present_state)
IDLE: 
if ( x ) next_state = S1; 
else next_state = IDLE; 
S1: 
if ( x ) next_state = S10; 
else next_state = IDLE; 
S10: 
if ( x ) next_state = S101; 
else next_state = IDLE; 
S101: 
if ( x ) next_state = S1; 
else next_state = IDLE; 
default: 
next_state = IDLE; 
endcase
end 

================================================================
example-36: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

 

always@(posedge clk, posedge reset)
if (reset) present_state<=IDLE;
else case({present_state,x}) 
	{IDLE,1'b1}:	next_state<= S1; 
	{S1,1'b1}:	next_state<=S2; 
	{S1,1'b0}:	next_state<= S1; 
	{S2,1'b1}:	next_state<=C1; 
	{C1,1'b1}:	next_state <= S10; 
	{S10,1'b1}:	next_state<=C10; 
	{C10,1'b1}:	next_state <= S101; 
	{S101,1'b1}:next_state<=
================================================================
example-37: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(*) begin 
	if (reset) 
	present_state <= IDLE; 
	else 
	present_state <= next_state; 
end 

always@(x,present_state) begin 
	case(present_state) 
	IDLE: 
	case (x) 
	1'b1: next_state = S1; 
	default: next_state = IDLE; 
endcase
	S1: 
	case (x)
	1'b1: next_state = S10; 
	default: next_state = IDLE; 
endcase
	S10: 
	case (x) 
	1'b1: next_state = S101; 
	default: next_state = IDLE; 
endcase
	S101: 
	
================================================================
example-38: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @(posedge clk, posedge reset) 
if(reset) 
present_state <= IDLE; 
else 
present_state <= next_state;

assign z = (present_state == S101) ? 1 : 0; 

always@(posedge clk, posedge reset) 
if(reset) 
next_state = IDLE; 
else 
case(present_state) 
IDLE: 
begin 
next_state = x ? S1 : IDLE; 
end 
S1: 
begin 
next_state = x ? S1 : S10; 
end 
S10: 
begin 
next_state = x ? S101 : S1; 
end 
S101: 
begin 
next_state = x ? S1 : IDLE; 
================================================================
example-39: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk)
begin
if( reset ) 
present_state <= IDLE;
else 
present_state <= next_state;
end
assign next_state = x ? S1: SET0; 
assign z =(present_state == S101);

================================================================
example-40: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(*)
begin 	case(present_state)
	IDLE: 	begin 
	if(reset) next_state=S1; 
	else next_state=x?S1:IDLE;
	end	

	S1: 	begin
	if(reset) next_state=S1; 
	else next_state=x?S10:IDLE;
	end

	S10: 	begin 
	if(reset) next_state=S101; 
	else next_state=x?S10:IDLE;
	end
	
	S101: 	begin 
	if(reset) next_state=S101; 
	else next_state=x?S1:IDLE;
	end

	default: next_state= IDLE;
	endcase 
end

================================================================
example-41: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(reset or posedge clk) if (reset) 
	present_state<=IDLE; 
else 
	present_state<= next_state;

// if S1 and x=1, then next_state = S10 else next_state = currentState ;
always @(present_state or x) 
	if(present_state==S1 && x) 
	next_state = S10; 
	else if(present_state==S10 && x) 
	next_state = S101; 
	else if(present_state==S101 && x) 
	next_state = IDLE; 
	else 
	next_state = IDLE;

always @(posedge clk) 
	if(present_state==S1 && x) 
	z=0; 
	else
================================================================
example-42: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk) 
	begin
	if(reset) 
	present_state <= IDLE; 
	else 
	present_state <= next_state;
	end

// The above procedural block compiles but is not correct. An if else inside a procedural block does not work 
// when the brackets are their own statement. 

always @(present_state, x) 
	begin
	case(present_state) 
	IDLE: 
	case(x) 
	1'b1: next_state = S1; 
	default next_state = IDLE; 
	endcase
	S1: next_state = S10; 
	endcase
	
	S10: next_state = S101; 
	endcase 
	S101: next_state = IDLE; 
================================================================
example-43: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (present_state or x) 
	begin	
	if (reset) 
	case (present_state)
	IDLE: if (x) next_state = S1; else next_state = IDLE;
	S1: if (x) next_state = S10; else next_state = IDLE;
	S10: if (x) next_state = S101; else next_state = IDLE;
	S101: if (x) next_state = S1; else next_state = IDLE;
	default next_state = IDLE;
	endcase
else next_state = IDLE;


assign z = (present_state == S101) ? 1b1:1b0;
//assign vert = next_state != IDLE;

width_counter w1(clk,
================================================================
example-44: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or posedge reset) // stimulus block for present_state 
if (reset) 
	present_state <= IDLE; 
else 
	present_state <= next_state ; 
 //next_state can change immediately to IDLE for reset, but not other way
 //can't change during 0.23 seconds
always @(posedge clk or posedge reset) // stimulus block for z 
if (reset) 
	z <= 0; 
else if (present_state == S101) 
	z <= 1; 
else 
	z <= 0; 
initial //second half of forever loop
begin: flip_flop_init
	if (reset)
	begin 
	next_state = IDLE ; //Sets the initial state to be the IDLE 
	end 
	else if (present_state
================================================================
example-45: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( )
begin: state_table 
present_state = IDLE;
case( insert )
IDLE: 
	case(x)
	0: next_state = S1;
	1: next_state = S10;
endcase
S1: 
	case(x)
	0: next_state = S2;
	1: next_state = S10;
	endcase
S2: 
	case(x)
	0: next_state = regular_no;
	1: next_state = S101;
	endcase
S101: 
	case(x)
	0: next_state = S1;
	1: next_state = S10;
	endcase
default: next_state = IDLE ;
endcase
end 
always @(posedge clk)
begin
================================================================
example-46: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( 
present_state, x ) begin
case( present_state )
IDLE : begin 
	if (x==1) next_state = S1; 
	else next_state = IDLE;
	end
 S1 : begin 
	if (x==1) next_state = S10; 
	else next_state = IDLE;
	end
 S10 : begin 
	if (x==1) next_state = S101; 
	else next_state = IDLE;
	end	
 S101 : begin 
	if (x==1) next_state = S1; 
	else next_state = IDLE;
	end	
default : next_state = IDLE;

endcase
	end

assign z = (present_state == S101) ? 1'b1: 1
================================================================
example-47: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



//elseif 
always @(posedge clk or posedge x) 
begin 	 	 
//case(present_state) //stract state machine here 	 
	case(present_state) 
	IDLE: if(x) next_state = S1; 
	else next_state = IDLE;
	S1: if(x) next_state = S10; 
	else next_state = S1;
	S10: if(x) next_state = S101; 
	else next_state = S10;
	S101: if(x) next_state = S1; 
	else next_state = S101;
	endcase 
end
// output logic 
always @ (present_state) //abstetiate state machine 
begin 
	case(present_state) 
================================================================
example-48: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk, posedge reset)
begin 
 if(reset) 
present_state<=IDLE ;
else 
present_state<=next_state ;
end 

always @(present_state, x)
begin
case(present_state)
IDLE: if(x) 
next_state=S1 ; 


else 
next_state=IDLE ;

S1: if(x) 
next_state=S1;
next_state=S10;

S10: if(x) 
next_state=S101;

else 
next_state<=S10;

S101: if(x) 
next_state<=S1;
next_state<=S10;

endcase
end 

assign z = 0; 


================================================================
example-49: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(*)
begin 
 next_state=IDLE;
 case(present_state)
IDLE:begin
	if(reset)
	begin
	next_state=S1;
	end
	else 
	next_state=IDLE; 
end
S1:begin
	if(x)
	begin
	next_state=S10;
	end
	else
	begin
	next_state=S1;
	end
end

S10:begin
	if(x)
	begin
	next_state=S101;
	end
	else 
	begin
	next_state<=S10; 
	end
end 

S101:begin
	if(x)
	begin
	next_state<=S1;
	end
	else 
	begin
	next
================================================================
