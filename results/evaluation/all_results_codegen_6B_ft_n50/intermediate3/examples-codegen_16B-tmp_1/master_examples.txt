example-0: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign the value of r_next to r_reg
// mod the value of r_reg based on whether clk has ticked

always @(negedge clk)
begin
if (reset)
begin
r_reg <= 5'b01110;
end
else
begin
r_reg <= r_next;
end
end 

assign feedback_value = (r_reg[4] ^ r_reg[2]); 
assign r_next = {r_reg[4:0], feedback_value};
assign q = r_reg; 


================================================================
example-1: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = {q[0], q[1] ^ r_reg[3] ^ q[3] ^ q[4], q[2] ^ r_reg[4], q[2:3] ^ r_reg[3:2]};
// attempt 1 - assign feedback_value to q[4]..q[1] and keep feedback value as q_reg[2:4]
// assign d = (r_reg[4] ^ r_reg[2]) & q_reg[2] ^ r_reg[3] & r_reg[0];
// assign q_next = {r_reg[0], r_reg[1] ^ d};
// ...don't use q[2:1] and q[3]
reg [5:0] d;
reg [3:0] q_reg;
assign feedback_value = q[
================================================================
example-2: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// determine the feedback values for each xor
assign feedback_value = r_reg[2] ^ r_reg[4];
// create gatelevel circuit; counts from 0 to 32 when clk=1
always @ (posedge clk)
begin
if(reset) //if reset is high go to step 1
begin
r_reg <= 5'b01100;
end //end reset high
else //if reset is low go directly to step 2
begin
r_reg <= r_next;
end //end reset low
end //end always
//notice, feedback_vector is an output of the xor gates
assign r_next = (r_reg << 1) ^ {r_reg[4], r_reg[3] ^ feedback_value};

================================================================
example-3: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = (reset==1) ? 5'h1f : ( (r_reg[4] ^ r_reg[4]) ^ {r_reg[4],feedback_value}); 
always @(posedge clk) begin
counter=counter+1;
if(counter>16'd1024) 
begin 
counter=0;
r_reg<= 0;
r_next<=0;
end 
else begin 
r_reg<=r_next;
end 
end
assign q = (reset==1)?l:r_reg; 


================================================================
example-4: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = r_reg ^ {feedback_value, 2'b00, r_reg[3:2]};
always@(posedge clk, reset)
begin
	if(reset)
	begin
	// upon write to reset r_reg to 1
	// "once at the begining of time r_reg = 5'b00011
	r_reg <= 5'b00011;
	end
	else
	r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-5: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = ((r_reg[2] ^ r_reg[4]) ? 
feedback_value : r_reg[4]);
assign q = r_reg;
//initial state
always @(posedge clk or posedge reset)
if (reset)
r_reg <= 5'd1;
//tap values. The values of j,j-1, j-2, and j-3 are used as a parameter for
//the xor gates that generate the feedback value.
//j-3 has no tap value because it is generated by previous tap values.
else
 begin 
//generate feedback value 
r_reg <= r_next; 
end 

================================================================
example-6: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (clk or reset)
begin
	if(reset)
	begin
	r_reg <= 5'b1;
	end
	else
	begin
	//feedback assign connections
	feedback_value = r_reg[2] ^ r_reg[4];
	r_next = {r_reg[4], feedback_value};
	end
	q = r_reg;
end

================================================================
example-7: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = q[2] ^ q[4];
always @(posedge reset or posedge clk)
begin
if (reset == 1)
r_reg <= 5'b1;
else
r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-8: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = clk ? {r_reg[4], r_reg} : {q[4], r_reg};
assign feedback_value = r_reg[2] ^ r_reg[4];
assign q[0] = r_reg[0];
assign q[1] = r_reg[1];
assign q[2] = r_reg[2];
assign q[3] = r_reg[3];
assign q[4] = r_reg[4];
always @(posedge clk) 
begin
	if (reset)
	begin
	r_reg <= 5'b00001;
	end
	else
	begin
	r_reg <= r_next;
	end
end

================================================================
example-9: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (r_reg & q[4]) | (r_reg & ~r_reg[4]);
always @(posedge clk, posedge reset)
begin
if (reset) r_reg <= 5'b00001;
else
begin
// make changes to r_reg
r_reg <= r_next;
end
// convert feedback to Gray's Code and send to q
q[0:4] <= {q[4:0],~feedback_value};
end

================================================================
example-10: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@( negedge clk, negedge reset)
begin
	if (~reset) // if reset
	begin
	r_reg <= 1;
	end // end if
	else // if not reset
	begin
	r_next <= r_reg; // assign r_next to r_reg
	// ^^ this is the feedback value : vector bit
	if (r_reg[2] && r_reg[4])
	begin
	q <= r_reg ^ 8'h18; //concatenate bit positions 2 and 4 of r_reg along with the feedback value and assign to output
	end // inner if
	else
	begin
	q <= r_reg; // assign to output
	end // otherwise
	end //ï¿½ denoting else
end //always

================================================================
example-11: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = feedback_value ^ r_reg;
assign q = r_reg.C;
always @(posedge clk)
if(reset) begin
	r_reg <= 'h1;
end else begin
	r_reg <= r_next;
end

================================================================
example-12: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r = ~(r_reg|clk)&reset; 
assign feedback_value = r_reg[2] ^ r_reg[4];
assign q = r_reg ^ feedback_value; 
always @ (negedge clk or posedge reset) //new circuit to reset the register
begin
if (reset)
begin
r_reg <= 4'b1001; //xor of r_reg and a 5 bit vector of 1000s
#3 r_reg <= 4'b0000; //assign r_next to input as a reset
end
else
begin
r_reg <= r_next; //always take the next value of r_reg for our function
end
end

================================================================
example-13: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk or posedge reset)
begin
	if (reset)
	r_reg <= 15'b0000000000001;
	else
	begin
//#2
//#3
r_reg[4] <= r_reg[3];
r_reg[3] <= r_reg[2];
r_reg[2] <= r_reg[1];
r_reg[1] <= r_reg[0];
r_reg[0] <= ~q[4] ^ q[0];
	end
end
//assign r_next = (r_reg[2:0] ^ r_reg[4:1] ^ r_reg[3]);
assign feedback_value = r_reg[5] ^ r_reg[2];
assign r_next[4:0] = r_reg[2:0] ^
================================================================
example-14: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = ^ { r_reg[2], r_reg[4] };
always @(posedge clk)
begin
if(reset)
r_reg <= 5'b10000;
else
begin
r_reg[4:1] <= { feedback_value, r_reg[4:1]};
r_reg[0] <= r_reg[4];
end
end

================================================================
example-15: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// reset the current state to give the state that r_reg already had before a reset was performed
// xor of bit 0 and bit 3 in r_reg since the LFSR should be >= 0
assign r_next=~r_reg;
assign feedback_value=~(r_reg[3] ^ r_reg[4]);
assign q=r_reg;
assign r_reg=reset ? 5'h1 : (r_next|5'h4c);

================================================================
example-16: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = ^{r_reg[2:0], r_reg[4]};
assign r_next = r_reg | ( feedback_value & {r_reg[3:0], r_reg[4]});
always @ (posedge clk, posedge reset ) 
begin
if ( reset )	
begin
	 r_reg = 5'b00001;
end
else	
	begin
	 r_reg = r_next;
	 end
end

================================================================
example-17: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
reg[4:0] r_next;

assign feedback_value = r_reg[2] ^ r_reg[4]; //XOR the bits to create the feedback 
always @(posedge clk or posedge reset) // generate lfsr sequence to bit positions 5 and 3 
if (reset) begin r_reg <= 5'h1; end

else begin
r_reg <= r_next;
end

================================================================
example-18: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @(posedge clk, posedge reset)
begin
if(reset)
begin
r_reg <= 5'b00001;
end
else
begin
r_reg <= r_next;
end
end
assign feedback_value = r_reg ^ {r_reg[2], r_reg[4]};
assign r_next = r_reg >> 1;
assign r_next[4] = feedback_value;

================================================================
example-19: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
en #100 feedback_value= q[2] ^ q[4];
always @(posedge clk, posedge reset)
begin
	if (reset)
	begin
 
// corner case: if the input is equal to the feedback value,
// the output should be identical to r_reg
// therefore need to hold the output at that number 
 
// hold the output of the first cycle to 0 to prevent
// large encoding errors
q <= 0;
 
// reload r_reg to be 1 to prevent a sequence described in the next Outline
// intended as debug view
r_reg <= 13;
end
else
begin
q <= r_next;
r_reg <= r_next;
end
end
assign r_next = r_reg^feedback_value;

================================================================
example-20: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @ (posedge clk) begin
	if (reset == 1'b1) begin 
	r_reg = 4'b0111;
	 end
	else begin 
	r_reg = r_next;
	 end
	end

 // compute r_next
assign r_next = (feedback_value == 1'b0) ? r_reg >> 1 : r_reg ^ r_reg >> 2;

assign q = r_reg[4:0];

// This version doesn't work because we can't take arithmetic practice ISIM model 
// assign q = (feedback_value == 1'b0) ? r_reg>>1 : r_reg ^ ((r_reg>>2) & (r_reg>>4));


================================================================
example-21: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_next;
always@(posedge clk)
begin
if(reset)
r_reg <= 1;
else
begin
	r_next = r_reg;
	feedback_value = r_reg << 10;
	r_next[4] = r_reg[4] ^ feedback_value[4];
	r_next[3] = r_reg[3] ^ feedback_value[3];
	r_next[2] = r_reg[2] ^ feedback_value[2];
	r_next[1] = r_reg[1] ^ feedback_value[1];
	r_next[0] = r_reg[0] ^ feedback_value[0];
	end
end

================================================================
example-22: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = (r_reg[2] ^ r_reg[4]);
assign r_next = r_reg[0] ^ r_reg[4]; // zero terminates sequence
always @(posedge clk, posedge reset ) begin
 if (reset)
 r_reg <= 5'b00101; //r_reg at 0
 else 
 r_reg <= r_next;
 end
 assign q = r_reg;

================================================================
example-23: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@(posedge clk, leavreset)
if(leavreset) r_reg <= 5'b10000;
else r_reg <= r_next;
assign feedback_value = ^{r_reg[2], r_reg[4]};
assign r_next = r_reg >> 1;
assign q = r_reg << 1;

================================================================
example-24: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = r_reg ^ (r_reg[2] ^ r_reg[4]);

always @(posedge clk) 
begin
if(reset)
begin r_reg <= 0;
end
else
begin
// if counter first reaches max, revert bits to zero
// otherwise increment
if(r_reg == 15'b 11111111111111111) r_reg <= 0;
else
begin
r_reg <= r_next;
end
end
end 
assign q = r_reg; 

================================================================
example-25: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = ( reset ) ? {1'd1,1'd1,1'd0,1'd0,1'd1} :
//assign r_next[4] = r_next[2] ^ r_next[4];
assign feedback_value = r_reg[4] ^ r_reg[5];
assign r_next[4] = r_reg[2] ^ r_reg[4];
assign q = r_reg;
always @(posedge clk) begin
r_reg <= r_next;
// q <= r_next; # may not be neccessary
end

================================================================
example-26: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(*) begin
	if(reset) begin
	r_reg = {5'b1 , 1'b0};
	end
	else if (!reset) begin 
	//r_reg = 5'b0;
	r_reg = r_next;
	end
end
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = feedback_value? (r_reg + 5'b01100) : r_reg;

================================================================
example-27: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
reset_dip reset
// even with 'r_reg' is instanciated before any of the gates, it is not initialized
// 'feedback' will never be used uninitialized because the output of the gate will throw an error
assign feedback = xor2(r_reg[2],r_reg[4]);
// NOTE: logic used in feedback leads to undefined value
assign r_next = r_reg ^ (feedback ^ xor2(r_reg[3], r_reg[0])); //display logic diagram of lfsr
always @(posedge clk) begin
	if (reset) begin
	r_reg <= 5'b10111;
	end // end if
	else begin
	r_reg <= r_next;
	end // end else
end // end always

// NOTE: feedback value
================================================================
example-28: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg ^ ( (r_reg & r_next) >> 1 );
always@ ( posedge clk, posedge reset ) begin
	if( reset ) begin
// default value of r
r_reg <= 1 << 5;
	end else begin
// next value
r_reg <= r_next;
// assign value of this term to a temporary register
// and multiply value assignment with coefficient value of 2, as in
// r_reg = feedback_value
"p = " & r_reg.as_text
// after utilizing last X bits, replace with the value
r_next <= (lfsr_terms >> x + clk);
// concatenation to be indexed
lfsr_terms[x] <= feedback_value;
	end
end
// instantiate the Galois LFSR term
// of the number of bits specified by the user, with
================================================================
example-29: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset)
begin
	if (reset) r_reg <= q_zero;
	else 
	begin
// assign r_next = r_reg
	r_reg<=r_next;
	end
end
// for the 05-bit LFSR, shift
// feedback value for adding to self
assign q = {feedback_value[4],
feedback_value[2]^feedback_value[3]};
// assign the feedback value to the self variable
assign feedback_value = {r_reg[3], r_reg[4]};
// assign the bit positions 2 and 4 of the register to the feedbackI
// unused bits 0,1,2,5,6 considered as things of unknow)

================================================================
example-30: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset == 1) ? r_reg : (feedback_value ^ r_reg);
assign q = r_reg;

================================================================
example-31: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q=r_next;
always @(posedge clk)
begin
if (reset)
r_reg <= 5'b0101;
else
begin
feedback_value=r_reg[2] ^ r_reg[4];
r_reg= r_reg << 1
abdut
end
end

================================================================
example-32: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = ^(r_reg [2:4]);
assign r_next = r_reg[4] ^ (r_reg[4] ^ feedback_value) ^ (r_reg[4] ^ r_reg[0]);
assign q=r_reg;
always @(posedge clk, posedge reset)
begin
if (reset)
r_reg <= 5'b1;
else
begin
r_reg <= r_next;
end
end

================================================================
example-33: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// create lfsr instance called r_reg
assign r_next = (r_reg && feedback_value) || ( (r_reg[4] && r_reg[0]) && r_reg[1] );
// create 6 out of feed-back logic
assign feedback_value = 
(
 r_reg[2] ^ r_reg[3] ^ r_reg[4]
);
// assign r_next to r_reg
always @(posedge clk)
begin 
// if the reset is asserted, assign all values to 1
if (reset)
r_reg <= 5'b1;
// otherwise, assign stored result to r_reg
else
r_reg <= r_next;
end

================================================================
example-34: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_reg[0] = reset?1:0;
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = r_reg[4] ^ feedback_value;
assign q = r_reg;
always @ (posedge clk) 
begin
	if (reset) r_reg <= 1;
	else r_reg <= r_next;
end

================================================================
example-35: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk or posedge reset) begin
	if(reset) begin
	r_reg <= 2'b11;
	end
else
r_reg <= r_next;
// here i will combine the next three gates into one
assign feedback_value = r_reg[2] ^ r_reg[4];
end
// logic to form a 5 bit opcode to match your testbench output
assign r_next = r_reg^{3'b110, r_reg[4:1] ^ r_reg[4]};
assign q = r_reg;

================================================================
example-36: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always@(posedge clk, negedge reset)
begin
if(reset) r_reg <= 1;
else begin
r_reg <= r_next;
end
end
assign r_next = feedback_value ^ r_reg;

================================================================
example-37: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;	//assign the output q to the current state of the circuit
assign r_next = {feedback,r_reg[4:1]};
assign feedback_value = r_reg[2]^r_reg[4];
// Feed the input feedback back to the next value to yet again in the next loop	
	always @(posedge clk)	
	begin
	r_reg <= r_next;
end

================================================================
example-38: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// initialize the value of r_reg
assign r_next = (r_reg[4:0] ^ r_reg[2:0]) ^ feedback_value;

//always block, trigger on clock edge
always @(posedge clk)
begin
	if (reset) 
	begin 
	// set r_reg to 0 and q to 1
	r_reg <= 4'b0000;
	q <= 5'b10000;
	end
	else
	begin
	// set r_reg to r_next (using only the output bits from r_next)
	r_reg <= r_next;
	// set q to bit position 2 of the output (concatenation of r_reg and feedback_value)
	q <= {r_reg,feedback_value} + 5'b00001; //adding 5'b00001 onto values
================================================================
example-39: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (r_reg[4] ^ r_reg[2]) ? {r_reg[3],r_reg[0]|feedback_value} : r_reg;
assign q = r_reg;
always @ (posedge clk) begin
if (reset)
r_reg <= 9;
else begin
r_reg <= r_next;
end
end

================================================================
example-40: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q= (r_reg)^(r_reg >> 1)^(r_reg >> 2)^(r_reg >> 3);
always @(*)
begin
if (reset)
begin
r_reg <= 5'b1;
end
else
begin
r_reg <= r_next;
end
end
assign feedback_value = (r_reg >> 2) ^ (r_reg >> 4);

================================================================
example-41: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = (~r_reg[4]) | (r_reg[2] & ~r_reg[3]);
always @(posedge clk) begin 
if(reset) 
r_reg <= 2'b1; 
else 
r_reg <= r_next; 
end 
// shift by 2 and concatenate
// xor bit position 2 and 4 together
// assign r_next to the output
assign r_next = {r_reg[3:1], r_reg[0] ^ feedback_value}; 

================================================================
example-42: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// First approach: a shift left and a shift right. Replace first shift 
// left with a fulladd8 operation that adds the shifted value. Swap 
// feednac and shift right arguments to feed the bit shifted value as 
// the input for later operation.
assign q = r_reg;
assign q_next = {q[0],q[4:1],feedback_value};
assign feedback_value = q[2]^q[4]; 
// second approach:
// Start building feedback_value from left child of current_state
// (current_state having been assigned in the pps/1 tostarting xbsconcat)
function [4:0] b4;
input [4:0] starting_value;
input [4:0] child_value;
begin
	case (starting_value) 
	
	5'b01101
================================================================
example-43: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg; //r_reg gets new random values every clk th invoke of random
// Using the following Verilog code to create a truth table with a circuit
// for a level triggered flip-flop
// $display("The shifting values are %b", r_next);
// alter the condition in line 47 to include inputs to produce the random
// values
initial
begin
r_reg = 1 #5;
// r_reg = 2 #10;
end
// define an integer lw for reading other module variables
integer lw;
// DEFINITIONS FOR THE LFSR INPUT VALUES. Inputs to the lw module must be 5-bit numbers.
// Add the values of all the bit positions serially (i.e. shift left shift_amount values )
// with the value input to the lfsr module. The values of the input"shift
================================================================
example-44: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk, posedge reset) begin
if(reset) begin
	r_reg <= 5'b00000;
	end
else begin 
	//on reach a certain value of the current state
	r_reg <= r_next;
	end
end
assign r_next = { q[1:0],feedback_value };
assign feedback_value = q[2] ^ q[4];
assign q = r_reg;

================================================================
example-45: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always@*
begin
if (reset)
r_reg = 5'b00011; //assign q to 5'b00011
else
r_reg = r_next; //assign q to R_next
end
assign feedback_value = XOR(r_reg[2],r_reg[4]);
assign r_next = {r_reg[4], feedback_value ^ r_reg[4], r_reg[2], r_reg[1], r_reg[0]};
assign q[4] = r_next[4];
assign q[3] = r_next[3];
assign q[2] = r_next[2];
assign q[1] = r_next[1];
assign q[0] = r_next[0];

================================================================
example-46: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value =r_reg[0] ^ r_reg[3];
assign r_next = r_reg[4+:4] ^ (r_reg[4] & {feedback_value, r_reg[4] ^ r_reg[2] ^ r_reg[0] ^ r_reg[1] ^ r_reg[3] ^ r_reg[2] ^ r_reg[0] ^ r_reg[1]});

always @(posedge clk)
	begin
	if(reset) r_reg <= 5'b00001;
	else r_reg <= r_next;
	end
assign q = (reset)? 5'b00001 : r_reg;


================================================================
example-47: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = (r_reg & ({5{~reset}} | {5{feedback_value}})) | (r_reg & ({5{~feedback_value}})) ;
assign q = r_reg;
always @ (posedge clk) begin
if (reset) 
r_reg <= {5'b1};
else
r_reg <= r_next;
end

================================================================
example-48: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q=r_reg; 
FUNC2
// how do you know if you have used this feedback function?
// look at the assign statements
// notice that there is only one position of feedback
//the policy regarding how you write feedback in Verilog is, LFSR adds the values at output positions to what you tell it absorbing
// so it will do r_reg-feedback_value (for r in r_reg) = r_next 
module THERM_1( input CLK, input RST, input [7:0] set_temp,
output [7:0] State_in,
output [7:0] State_out);
parameter N = 8;
//State names in a sequential state automata
reg [7:0] state;
//Local Parameter giving state value
reg [7:0] set_temp_next;
//Next
================================================================
example-49: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg ^ r_next[4:2];
always @ (posedge clk, posedge reset)
	if (reset)
	begin
	r_reg <= 5'b11111;
	end
	else
	begin
	r_reg <= r_next;
	end

================================================================
