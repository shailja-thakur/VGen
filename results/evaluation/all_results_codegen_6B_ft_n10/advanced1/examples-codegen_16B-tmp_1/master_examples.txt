example-0: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = (a[7] == b[7] && a[7] == s[7])? 1'b1: 1'b0;


always @(*) begin // this block is a combinational always block

// similar to a case-statement, the if-else statements check the conditions when a signed adder has been requested

if ((a[7] == 1'b0 && b[7] == 1'b0 && s[7] == 1'b1) || (a[7] == 1'b1 && b[7] == 1'b1 && s[7] == 1'b0)) begin // case 1

assign s[6:0] = 7'b11000011; // all of the bits are high (overflow)

// assign s[6:0] = (a[6:0] + b[6:
================================================================
example-1: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 endmodulemodule multicycle(a,b,cin,x,ansout);
 input [7:0] a,b;
 input cin;
 output [7:0] x;
 output [1:0] ansout;
 
 reg of1,of2;
 reg [7:0] x1,x2;
 reg [1:0] ansout1,ansout2;
 
 initial x1 = 0;
 initial x2 = 0;

// assign ansout1 = 2'b00;

 // reg inquality, equality;
 reg [7:0] equalitycheck, inqualitycheck;

// always@(a) begin
// equality <= (a[7:4] == b[7:4]);
// end

// always@(a) equalytopelement = (equality) ? a[7:0]: 8'b00000000; // prints
================================================================
example-2: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign carry[7:0] = {carry[6], a[7] + b[7] };
assign s[7:0] = { carry[7], po, carry[6:0]};
assign ovf = (a[7]==0 & b[7]==1 & low2[7]==1 & s[7]==1) | (a[7]==1 & b[7]==0 & high2[7]==1 & s[7]==0);

integer low0;
integer mid0;
integer hi0;
integer mid1;
integer lo1;
integer hi1;
integer mid2;
integer lo2;
integer hi2;
integer mid3;
integer lo3;
integer hi3;

always@(a or b or s) begin

low0[0] = a[0
================================================================
example-3: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = (a[7] == b[7] && a[7] == s[7]); 


================================================================
example-4: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


initial begin 

$monitor("a[%b] + b[%b] + s[%b]",a,b,s);//print the sum of a and b after each change 

// repeat (10000000000) //repeat for debugging 

#1 assign a=10'd10; // sets a to 10
#1 assign b=10'd1; // sets b to 1
#1 assign s=10'd100; //sets the sum to 100 (a+b)

//@a as well to print the result 
end

//the bits {overflow,a,b} are all true 

always @a or @b or @s begin (overflow =1'b0 & (a>b)) or (a=b); end 


================================================================
example-5: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = (a[7] == 0 & b[7] ==0 & s[7] ~== b[7] ) || (a[7] == b[7] & b[7] != s[7] );


================================================================
example-6: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = overflow_detection(a,b);


//overflow detection
function overflow_detection; 

input [7:0] a,b;

begin 
 shift_a_left(a,1);
 shift_b_left(b,1);

end 

endfunction

// shift a by 1
task shift_a_left;
input [7:0] inp;
begin
inp = (inp << 1);
end

endtask

// shift b by 1
task shift_b_left; 
input [7:0] inp;
begin
 inp = (inp << 1);
end

endtask





================================================================
example-7: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// The above conditions does not perfectly capture all the conditions of a signed adder. We need logic in the case where 
// a and b2's most significant is the same, but s1 is lower than the other condition where s1 is higher than s2

always@(a or b)
 begin
for(i=0;i<8;i++) 

 if(a[i]==1'b1)
 begin
 if(b[i]==1'b1)
 begin
 s[i]=1'b1;
 end

 else s[i]=1'b0;
 end

 else s[i]=1'b0;
 end

assign overflow1=(a[7]==1'b1 && b[7]==1'b1 && s[7]==1'b0)? 1'b1: 1'b0;
assign overflow
================================================================
example-8: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	wire [7:0] carry;

	addsub_1bit addsub1(.cout(carry[0]), .overflow(overflow), .a(a[0]), .b(b[0]), .x(1'b0), .s(s[0]));
	
	genvar i;	
	generate for (i=1; i<8; i = i+1) begin: addbit
	addsub_1bit addsub(.cout(carry[i]), .overflow(overflow), .a(a[i]), .b(b[i]), .x(carry[i-1]), .s(s[i]));
	end endgenerate


================================================================
example-9: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// define bit_a signals for both a and b 
wire bit_a[7], bit_b [7], bit_s[8];

assign bit_a[0] = a[0];
assign bit_a[1] = a[1];
assign bit_a[2] = a[2];
assign bit_a[3] = a[3];
assign bit_a[4] = a[4];
assign bit_a[5] = a[5];
assign bit_a[6] = a[6];
assign bit_a[7] = a[7];


assign bit_b[0] = b[0];
assign bit_b[1] = b[1];
assign bit_b[2] = b[2];
assign bit_b[3] = b
================================================================
example-10: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire a_b_s_stream_overflow;
wire signed a_b_s_overflow;
assign a_b_s_overflow = (~a[7]) & (~b[7]) & s[7];
assign overflow = a_b_s_overflow | a_b_s_stream_overflow;
assign s[7] = (~a[7]) & (~b[7]) & (a[7] ^ b[7]);


always @ (*) begin
	if (a[7] == b[7]) begin
	//////////////////////////////////////////// check for the most significant bit /////////////////////////////////
	// both bits that determine if s is signed or not are high, then the output should be signed
	// for example if a is 128 and b is 255 then the sum should output -127
	if (((a[7] == 1'
================================================================
example-11: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 assign overflow = (~sr[s] & a[7] | a[0] & ~sr[b], ~sr[s] & ~a[7] & b[7], ~sr[s] & a[7] & b[7] & ~sr[b], sr[s])
 
 
always @ *
begin
case(overflow)

0: sr[s] = a + b;
4'b1111: begin
sr[s] = 8'h00;
	end

endcase

end




================================================================
example-12: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


 wire [8:0] asl; // Overflow detect detector (shifts with 0-fill over 8 bits)
 wire ssme [7:0]; // output o the same as a

xor(ssme[0], a[0], b[0]);
xor(ssme[1], a[1], b[1]);
xor(ssme[2], a[2], b[2]);
xor(ssme[3], a[3], b[3]);
xor(ssme[4], a[4], b[4]);
xor(ssme[5], a[5], b[5]);
xor(ssme[6], a[6], b[6]);
xor(ssme[7], a[7], b[7]);

assign asl[8]= ( ^(a[7:0]) ^ ^(
================================================================
example-13: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire signed [9:0] d; 

//signed experiment A
wire s_op1, s_op2, s_add; 
wire [7:0] mux1, mux2; 
signed_add op1(a[7], b[7], 'b0, mux1[7], mux1[8], mux1[9]);
signed_add op2[7](a[6:0], b[6:0], mux1[9], mux2[7], mux2[8], mux2[9]);
led_mux mux3(a[7], b[7], mux2[8], s_op1, s_op2);
led_mux mux4(mux2[9], mux1[9], mux1[8], s, s_add);


================================================================
example-14: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = (a + b);
assign overflow = (a[7] == b[7] && a[7] != s[7]);


================================================================
example-15: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s [7:0] = ( {8{(~b[7] & a[7]) | (~a[7] & b[7])}} ) +

( {8{(~b[6] & a[6]) | (~a[6] & b[6])}} ) +

( {8{(~b[5] & a[5]) | (~a[5] & b[5])}} ) + 

( {8{(~b[4] & a[4]) | (~a[4] & b[4])}} ) + 

( {8{(~b[3] & a[3]) | (~a[3] & b[3])}} ) + 
( {8{(~b[2] & a[2]) | (~a[2] & b[2])}} ) + 
( {
================================================================
example-16: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


reg overflow;

always@(a or b or s)
begin
	overflow = ((a[7]==0 && b[7]==0 && s[7]==1) || ((a[7]==1 && b[7]==1 && s[7]==0)))?1:0;
end

assign overflow = 0;

================================================================
example-17: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b;
assign overflow = (a[7] == 1'b0 && b[7] == 1'b0 && s[7] == 1'b1) ||
	(a[7] == 1'b1 && b[7] == 1'b1 && s[7] == 1'b0);


================================================================
example-18: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 assign overflow = ((a[7] == 0) && (b[7] == 0) && (s[0] == 1)) ||
 ((a[7] == 0) && (b[7] == 1) && (s[0] == 0)) || 
 ((a[7] == 1) && (b[7] == 0) && (s[0] == 0)) ||
 ((a[7] == 1) && (b[7] == 1) && (s[0] == 1));

// add the bits of the two inputs

 wire [6:0] s1, s2, s3;

assign s1 = a[6:0] + b[6:0];	//sum of two most significant parts of input a and b
assign s2 = a[7] + b[7];	//sign bit of a and b added
assign
================================================================
example-19: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 pt_5 pt5(a,b,s,c);

 assign overflow = c[0] + c[1];


================================================================
example-20: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign #3 s[0] = (~a[0] && b[0]) ^ s[0]; // pregenerate case statement conditions, substract low numbers from the most significant statememnt (assign the results of the calculations to new variables to allow the statememnt equations to be used in various calculations without having the output change every input


assign s[1] = (a[1] ^ b[1]) ? ((~a[1]) && b[1]) ^ s[0] : s[2]; // the equation for adding a and b is: s[i] = (a[i] ? b[i] : 0) ^ s[i-1] 
 

assign s[2] = (a[2] ^ b[2]) ? ((~a[2]) && b[2]) ^ s[1] : s[3];


ass
================================================================
example-21: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 end

// assign the core output s to the used_overflow wire. 
// Carry only occur when the core output s is low and the output overflow is high. 
 // assigned the temp overflow wire to the output overflow



// tested the functionality of the core signed adder from its functionality
// a and b negative numbers did not throw a warning of signed overflow with the warnings 
// niterated 50 times
// verify No more warnings of signed overflow were throw for positive numbers
// Verify warnings of signed overflow were throw when you assign a or b negative number to the core output in the ln undt_tb.v file that this module is based on and running from in ither simulation result enviroment.




================================================================
example-22: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign s = a + b; 

	assign overflow = (a[7]==~b[7] && a[3]==~b[3] && a[2]==~b[2] && a[1]==~b[1] && a[0]==~b[0]) 
	 	|| (a[7]==~b[7] && a[3]==~b[3] && a[2]==~b[2] && a[1]==~b[1] && a[0]==b[0]) 
	 || (a[7]==~b[7] && a[0]==~b[0]) || (a[7]==b[7] && a[0]==0); //an unsigned overflow has occured as the result of 2's complement
 



================================================================
example-23: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow =
a[7] & b[7] & ~s[7] | ~a[7] & ~b[7] & s[7];

wire wide_sum_lobytes;

wire [8:0]sum_lobytes = a[7:0] + b[7:0];
assign sum_lobytes[7] = a[7] & b[7] & (s[7] | ~a[7] & ~b[7]);

assign sum_lobytes[6:0] = a[6:0] + b[6:0];
assign sum_lobytes[8] = a[7] & ~b[7] & ~s[7] | a[7] & b[7] & s[7] | ~a[7] & b[7] & ~s
================================================================
example-24: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s[0] = a[0] ^ b[0]; 

genvar i;
generate
for (i=0; i<8; i=i+1)
begin: generate_adder

wire final_bit = a[i]&&b[i]&&s[i] || a[i]||b[i];

// positive route to adder and negative to add er
assign z[i] = s[i];
assign y[i] = 1'b0;

if (final_bit ==1'b0)
begin

assign weight = 8-i;

always @(weight)
begin
z[i] = z[i+weight];
y[i] = y[i+weight];
z[i+weight] = z[i] ? 1'b0:1'b1;
================================================================
example-25: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



// Design the two-step method for signed addition

// Step1: First the output nibbles are assigned a signed value based on the significand values. Explain the math.
// Fix the integers a and b, and assign result as explained in the problem statement.

// Step2: It gets numbers in unsigned format, and then writes the output of step 1 to another unsigned number (without any sign bit), thus converts it in to signed format.

// Resulting in the overflow.



reg [6:0] a_ordered[7:0];
reg [6:0] b_ordered[7:0];
reg [7:0] numb_1;
reg [7:0] numb_2;
reg overflow_2 = 1'b0;
reg new_numb_ordered, all_overflow_holder; // for testing overflow of the new number generated based on second step
================================================================
example-26: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 assign s = (a & b); // get the sign bit from a, b, and s
 assign s[7] = (a[7] ^ b[7]); // add the sign bits 


always @ (a or b or s) // if bits were truncated, preserve the sign bit
 begin
 assign overflow = (~a[7] & b[7]) | ( (~a[7] & ~b[7] & s[7]) | (a[7] & b[7] & ~s[7]) );// check if incementing causes the overflow

 end


================================================================
example-27: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s[0]=a[0]^b[0];
assign a1=(a[0]&b[0]),
assign a2=(a[1]&b[1]),
assign a3=(a[2]&b[2]),
assign a4=(a[3]&b[3]),
assign a5= (a[4]&b[4]),
assign a6= (a[5]&b[5]),
assign a7= (a[6]&b[6]),
assign a8= (a[7]&b[7]),
//assign a9=(a[7]&b[6]),
//assign a10=(~b[7]),
assign s1=( (a[0]^b[0])^(a[0]& b[3]) ),
assign s
================================================================
example-28: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// assign the values into the s ex
assign s = a + b; 



// The addition of a and b may cause the most significant bits to exceed the range -128 to +127, 
// if a, b signed, has more significant bits. When a signed overflow occurs the most significant bits a and b are both set to their maximum positive values. 

// The high boundary of a signed subtraction is set to -128. The subtraction of b from a will complete
// at its most significant bit b if the most significant the b is set to its maximum positive value and the most significant bit a is set to its minimum negative value, or at its most significant bit a if the most significant bit b is set to its minimum negative value. 

// The subtraction of a from b may also result in a signed overflow of the same magnitude. 
// The subtraction of b from a can cause the most
================================================================
example-29: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = (overflow) ? ({1'b1, a} + {1'b1, b}) : ({1'b0, s1} + {1'b0, s0}); 
assign overflow = (s[7] == 1) && (a[7] == 0) && (b[7] == 1) || (s[7] == 0) && (s[6] == 1) && ((a[7] == 1) || (b[7] == 0));


================================================================
example-30: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign {s,overflow} = a + b;
 
/*All the inputs of the adder are 32 bit numbers.*/
/*The output s is 8 bits of a and 8 bits o f b.
End is the (8 + 8 + 3) bit output
*/

/*Step1 : Binary To BCD*/
/*Binary to BCD conversion requires three shift right operator for shifting the input numbers 0111010011 and 1011000010*/
/*0 is represented as '6' in a bcd*/
/*1 is represented as '3' in a BCD*/

/*Step 2 : Intermediate sums computation*/
/*Ones Computations*/
/*Hence the least significant bit of the sum will not be 14 if the carry from the bit 6 to bit 0 is 1(a is 0 or 1)*/
/*00 = 5 + 5 = Into Three Block 
0010 = calculate 4 + 6
================================================================
example-31: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = ((is_a_negative & is_b_positive) | ((~is_a_negative) & is_b_negative & is_s_positive)) & 
((a[7] & b[7]) | ((a[7] & is_s_positive) & (~b[7])) | ((is_s_positive & b[7]) & (~a[7])));

// use two-accumulator architecture to detect the signed overflow

// if either a or b is negative, then the most significant bit of its absolute value is high and the
// remaining bits are low (makes a negative number)
// if the remainder of the addition is bigger than the msb of b, then there is an overflow

assign is_a_negative = a[7] & (a[6] | a[5] | a[4] | a[3
================================================================
example-32: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low



assign s={(a[7]==b[7])?a+b,({7{(a[7]==b[7])}} & (a[7] | ~(a[7]^b[7]))+({7{(a[7]==1'b1)}} & b[7])});
assign overflow=(s[7]==1'b1 && a[7]==1'b1) ? 1'b1:1'b0;





================================================================
example-33: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 wire b_and_a, a_or_b;

//assign wire b_and_a = b & a; 
assign wire 0 ? b_and_a : a_or_b = a + b;

assign s = b_or_a + a_or_iface;

always @(b_or_a or a or b)
if (({b[7], a[7]} == {b[6], a[6]})) //only true if signs differ
assign overflow = 0;
else begin //negative or positive, does opposite ever happen?
if (({b[7], a[7]} == {b[6], a[6]})) //negative, logic negative and b_or_a's sign bit differ
assign overflow = ~a_or_iface + 1;
else overflow = a_or_iface;

================================================================
example-34: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign overflow = (a[7]==1'b0) && (b[7]==1’b0) && (s[7]==1’b1) ? 1’b1 : 1’b0;


================================================================
example-35: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// The final carry bit of s, CF, is an input. We connect the carry bit of the subtraction to i for the case 
// in which the subtraction does not overflow.
// We use Case statements to wire the two cases of overflow to the final carry bit.
// For the case in which the subtraction overflows, CF = 1.

assign s[7] = ((! (a[7]^b[7])) & (a[7] ^ s[7])) + (a[7] & b[7]) + CF; 
assign s[6] = ((! (a[6]^b[6])) & (a[6] ^ s[6])) + (a[6] & b[6]) + ((! (a[7]^b[7])) & (a[7] & b[7])) + CF;

================================================================
example-36: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign s = (a + b);
	assign overflow = (s[s[7]) && (!(a[s[7]) || !(b[s[7]));

// A logic statement that tests whether a negative number has been added to a positive number, detects this and does not add the first bit.
// The bits of the number must be switched before the first bit is added to the digit in the number 
	
//This encoder detects whether the most significant 1-bit of the sum (the most significant digit in the IR analysis) is a 1 or a 0. 
//This then turns 1 or 0 to be 0 or 1 in the output bit string 
	
	assign s8 = 	!(s[s[7]]) + s[s[7]];
	assign s7 = !(s[s[7] > 0]) + s[s
================================================================
example-37: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign overflow = (a[7] == 1 || b[7] == 1) && s[7] == 0 ? 1 : 0; // checked: May 2, 2017



always@ (*)begin
	if (a[7] == 0 && b[7] == 0) begin // Numbers are unsigned
 
 
 
 
 
// Assign bits to a variable to keep bit operation localized
// Add prefix 0b to b, inputs from the outside. Join inputs, and return result. 

assign s = {a, b}; // 0 + 0 = 0. 0b0_xxxx_xxxx__xxxx_xxxx = 7 bits of 0s.

end 
// If any of the number is a negative number, then "the most significant bit toggles high"

else begin

assign s[7] = a[7]; // numbers need to be compared
================================================================
example-38: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


// compare unsigned numbers 
assign eq1 = {a[7:0],b[7:0]} == {s[7:0],1’s1};

assign eq2 = {a[7:0],b[7:0]} == {s[7:0],1’s0};

assign overflow = eq1 & ~eq2;



================================================================
example-39: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	
	assign s = a ^ b;
	assign overflow = ((a[7] == 1) && ( b[7] == 1) &&(s[7] == 0)) || 
((a[7] == 0) && (b[7] == 0) &&(s[7] == 1)) ; 



================================================================
example-40: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign overflow = (a[7]==b[7] && a[7]!=s[7]) || (a[7]!=b[7] && s[7]==1'b0); 

// always block to add the arguments (a, b, s) whichever of them are declared as a reg or a wire
always @ (a or b or s) 
	{overflow, s[7:0]} = a + b; 


================================================================
example-41: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s = a + b; 
assign overflow = (^a) & ^b & +(|(a[7:4] ^ onset) | |a[7:4]) ; 


================================================================
example-42: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

	assign s = (a + b);
	assign overflow = (a[7] == b[7]) & (a[7] != s[7]);
	



================================================================
example-43: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s [7:0] = (a[7] == b[7]) ? {a[7], a[6:0] + b[6:0]} : {a[7], a[6:0] + ({1'b0, b[7:1]} + {1'b1, a[7:2]})};

assign overflow = ((a[7] == b[7]) & (a[7] != s[7])) | ((a[7] != b[7]) & (b[7] != s[7]));


================================================================
example-44: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low

 wire [8:0] temp_sum;

 wire signed [7:0] sum1;
 wire signed [7:0] sum2;

 xor sum1_xor(sum1[7],a[7],b[7]);
 xor sum2_xor(sum2[7],sum1[7],s[7]);
 xor temp_sum_xtro[7],sum2[7],sum1[7];
 xor temp_sum_xor(temp_sum[7],temp_sum[6],temp_sum[7]);
 rotateright sum_ror(temp_sum[7:0],sum2[7:0],b[7:0]);

 xor sum2_xor(sum2[6],sum2[7],temp_sum[7]);
 xor sum1_xor(sum1[6],sum1[7],
================================================================
example-45: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low






================================================================
example-46: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


wire //least significant bit in entire result
xor_operand_0 = a[0] ^ b[0],
//any bits with "xor_operand_0" as a component are set to 0 in the addition
carry_0 = b[0] ? xor_operand_0 : a[0],
//the result is corrected if the least significant bit of b is 0 or a is 0, where "carry_temp[0]" is extracted from the temporary variable "carry_0"
//If either a or b is 0 then it will replace the old value with 1, if the other number is 0 is replaces with 1
carry_temp[1] = a[1] ? b[1] ? carry_0 : ~ (xor_operand_0) : a[1],
//more specifically if the value of either a or b is 1 the least significant bit of result will
================================================================
example-47: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign s [7:0] = a + b; // addition as both a and b are assumed to be signed. however, the output can also be treated as a standard 8 bit integer type if use of an out of range hazard is performed. 
assign overflow = (b[7]&&a[7]&&!s[7]) || (!b[7]&&!a[7]&&s[7]); 


================================================================
example-48: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


assign r2 = {1'b0, b[0]}; // additional bits 0
assign r39 = a + r2; // calculate sum of two extensions. s is an extension of 8 bits and r39 is an extension of 40 bits.
assign check1 = {1'b0, r39[39]}; // check to see if these are different.
assign check2 = {1'b0, r2[0]};
assign check3 = r39 + {1'b0, check1};
assign s = (overflow) ? (r39) : (r39 + {1'b0, check2}); // assign output value to an 8-bit or 40-bit number.
assign overflow = ((a[7]==b[7]) && (a[7]!=s[7])) ? 1'b1 : 1'b0
================================================================
example-49: 
// Design a signed adder that adds two 8-bit 2's complement numbers, a[7:0] and b[7:0]. 

module signed_adder(input [7:0] a,
    input [7:0] b,
    output [7:0] s,
    output overflow
); 

// The numbers a and b are added to the output s. 
// assign the occurence of the signed overflow of a and b to the output overflow.
// a signed overflow occurs if the most significant bits of a and b are low and the most significant bit of s is high
// a signed overflow may also occur if the most significant bits of a and b are high and the most significant bit of s is low


sign_xor_nxor(a[7],b[7],s[7],c1); // assign the nxor gate values
sign_xor_nxor(a[6],b[6],c1,s[6]);
sign_xor_nxor(a[5],b[5],c1,c2);
sign_xor_nxor(a[4],b[4],c2,s[5]);

sign_xor_nxor(a[3],b[3],c2,c3);
sign_xor_nxor(a[2],b[2],c3,s[4]);

sign_xor_nxor(a[1],b[1],c3,c4);
sign_xor_nxor(a[0],b[0],
================================================================
