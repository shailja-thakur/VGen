example-0: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = (next_state == 1 ? 1 : 0);
always@(posedge clk)
begin
if (reset == 1'b1)
 begin
 present_state <= 1'b0;
 end
else
 present_state <= next_state;
end
always@(present_state or in or reset)
begin
if (present_state == 1'b0 && in == 1'b1)
 next_state <= 1'b0;
else if (present_state == 1'b0 && in != 1'b1)
 next_state <= 1'b1;
else if (present_state == 1'b1 && in == 1'b0)
 next_state <= 1'b1;
else if (present_state == 1'b1 && in != 1'b0)
 next_state <= 1'b0;
end 

================================================================
example-1: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk and posedge reset)
begin
	if (reset)
	begin
	 present_state <= 0;
	 //next_state <= 0;
	end
	else
	begin
	 present_state <= next_state;
	 //next_state <= 0;
	end
end
always @ (present_state or in)
begin
 case (present_state)
 0 : begin 
	if (in) 
	 begin
	// next_state = 0;
	 end
	 else 
	 begin
	 next_state = 1;
	 end
 end
 1 : begin 
	if (in) 
	 begin
	next_state = 1;
	 end
	 else 
	 begin
	next_state = 0;
	 end
 end
 default : next_state = 0; 
 endcase 

================================================================
example-2: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// If reset_state=1, it means reset, so present state will change to reset_state
// If there is no reset_state, then it will always go to state 0
parameter almost_zero=1e-6;
always @ (posedge clk)
begin
	// Following is an assignment with a state machine, with transiton conditions. The state machine is embedded in a genvar for iteration in always block"
	if(reset)
	begin
	present_state<=reset_state;
	end
	else 
	begin
	present_state<=next_state;
	end
end

always @ (*)
begin // This block contains the state transition logic
	case(present_state)
	// If the present state is zero, the next state must be 1
	almost_zero:
	begin
	if (in)
	begin

================================================================
example-3: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// out=0 in state 0 and out=1 in state 1
always @ (present_state, in)
begin
case(present_state)
0: if(in) begin next_state=0; out=0; end else begin next_state=0; out=0; end


1: if(in) begin next_state=1; out=1; end else begin next_state=0; out=1; end

endcase
end

always @(posedge clk)
begin
if(reset)
present_state=0;
else 
present_state=next_state;
end


================================================================
example-4: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// out=1 in state 1 and out=0 in state 0
always @(*)
	case(present_state)
	0 : begin
	next_state = (in) ? 0 : 1;
	out = (present_state == 0 && in) ? 1 : 0;
	end
	1 : begin
	next_state = (in) ? 1 : 0;
	out = (present_state == 1 && in) ? 1 : 0;
	end
	default 	: next_state=0;
	endcase
always @(posedge clk)
begin
if(reset)
	present_state <= 0;
else
	present_state <= next_state;
end

================================================================
example-5: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// State 0 will go back to state 0 again if in=0, and state 1 will go back to state 1 again if in=1.
// What goes into state 0 and 1 are the following, where j = bits of input in
// casej 0: out=0, next_state=0 if in=0, next_state=1 if in=1. Once again, if in = 0 then back to state 0
// 1: out=0, next_state=1 if in = 1. Once again, if in = 0 then back to state 0
// 2: out=1, next_state=0 if in = 1;
 // Once again, if in = 0 then back to state 1
// 3: out=1, next_state=0 if in = 0. Once again, if in = 0 then back to state 1
always @ (in, present_state)
begin
case (present
================================================================
example-6: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@( posedge clk, posedge reset )
begin
	if( reset )
	begin
	present_state <= 5'b0;
	end
	else
	begin
	present_state <= next_state;
	end
end
always@( present_state, in )
begin
	case( present_state )
	1'b0:
	begin
	next_state <= 1'b0;
	if(in)
	begin
	next_state <= 1'b0;
	end
	else
	begin
	next_state <= 1'b1;
	end
	end
	1'b1:
	begin
	next_state <= 1'b1;
	if(in)
	begin
	next_state <= 1'b1;
	end
	else
	begin
	next_state
================================================================
example-7: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter idle = 0, in_1=1, in_0=2, out_1=3, out_0=4;
always@(posedge clk or posedge reset) // present state
begin
 if(reset) /// In reset state, go to IDLE
 begin
	present_state <= idle;
 end
	else
	begin
	 present_state <= next_state;
	end
end
always@(present_state or in) // next state
begin
 case(present_state) /// Idle: when in idle
 begin
 next_state <= in ? in_1 : idle;
 end
 in_1: begin
 next_state <= in ? in_1 : in_0;
 end
 in_0: begin
 next_state <= in? in_1 : in_0;
 end
 out_1: begin
 next_state <= in ? out
================================================================
example-8: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter S0 = 0, S1 = 1;
always @(present_state, in) begin
case (present_state)
S0: if(in) begin
next_state <= S0;
out <=0;
end else begin
next_state <= S1;
out <= 0;
end
S1: if(in) begin
next_state <= S1;
out <= 1;
end else begin
next_state <= S0;
out <= 1;
end
default: next_state <= S0;
endcase
end
always @ (clk, reset, next_state)
case (next_state)
S0: present_state <= S0;
S1: present_state <= S1;
default: present_state <= S0;
endcase

================================================================
example-9: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = (present_state == 1)?(in):current_state;
always @ (negedge clk)
begin
if (reset) begin
	present_state = 0;
end
else begin
	present_state = next_state;
end
end
always @(*)
begin
	case(present_state)
	0: begin
	if (in==0) begin
	next_state = 0;
	end
	else begin
	next_state = 0;
	end
	end
	1: begin
	if (in==0) begin
	next_state = 0;
	end
	else begin
	next_state = 0;
	end
	end
	default: begin
	next_state = present_state;
	end
endcase
end

================================================================
example-10: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

D_flip_flop reg_bank[0:0] (clk, (reset & ((present_state == 0) & (~in))), ((present_state == 0) & in), out, present_state);
always@(posedge clk, negedge reset)
begin
	if(reset==0) present_state <= 0;
	else begin
	case(present_state)
	 0: if (in==1'b1) next_state <= 0; else next_state <= 1;
	 1: if (in==1'b1) next_state <= 1; else next_state <= 0;
	endcase
	end
	present_state <= next_state;
end

================================================================
example-11: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// In state 0, if in=1, go to state 1. In state 0, if in=0, stay in state 0
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
if(reset)
	present_state <= 0;
else
	present_state <= next_state;
end
always @(posedge clk)
begin
if(present_state == 0 & in == 1)
	next_state <= 0;
else if(present_state == 0 & in == 0)
	next_state <= 1;
else if(present_state == 1 & in == 1)
	next_state <= 1;
else if(present_state == 1 & in == 0)
================================================================
example-12: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// reset=1 is active high clear the present state to state 0
always @(posedge clk)
begin: FSM1
	begin: State_sequence_detector_FSM
	if (reset) present_state = 0;
	else present_state = next_state;
	end 
end
always @(present_state or in)
begin: FSM2
	case (present_state)
	0: begin
	if (in) next_state = 0;
	else next_state = 1;
	out = 1'b0;
	end
	1: begin
	if (in) next_state = 1;
	else next_state = 0;
	out = 1'b1;
	end
	endcase
end

================================================================
example-13: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// FSM algorithm, determines next state
always@(posedge clk)
begin
if(reset == 1'b1)
present_state = 1'b0;
else
present_state = next_state;
end
always @ (in or present_state)
begin
case(present_state)
1'b0:
begin
if(in == 1'b1)
next_state = 1'b0;
else
next_state = 1'b1;
end
1'b1:
begin
if(in == 1'b1)
next_state = 1'b1;
else
next_state = 1'b0;
end
default:
next_state = 1'b0;
endcase
end
//invert_port returns 1 if in=0 and out=1 in state 0 and in=1 and out=0
================================================================
example-14: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(next_state or in or reset)
begin
case(present_state)
 0:	begin
	 if (!reset)
	 begin
	 next_state <= 0;
	 end
	 else 
	 begin
	 if (in)
	 next_state <= 0;
	 else
	 next_state <= 1;
	 end
	 end
 1:	begin
	 if (!reset)
	 begin
	 next_state <= 1;
	 end
	 else 
	 begin
	 if (in)
	 next_state <= 1;
	 else
	 begin
	 next_state <= 0;
	 end
	 end
	 end
endcase
end
always @(present_state or in or reset)
begin
case(present_state)
 0: begin out = 0; end
 1: begin out = 1; end
endcase

================================================================
example-15: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (present_state or in)
begin
case (present_state)
1'b0: begin
present_state <= (~in) ? 1'b0 : 1'b1;
next_state <= (in) ? 1'b0 : 1'b1;
out <= 1'b0;
end
1'b1: begin
present_state <= (~in) ? 1'b0 : 1'b1;
next_state <= (in) ? 1'b0 : 1'b1;
out <= 1'b0;
end
endcase
end
// Because used a flip flop to store values, we needed to specify 2 different
// input and output pins to the flip flop.
initial begin next_state <= 1'b0; end
always @(posedge clk)
begin
if (present_state == 1'b0) begin
================================================================
example-16: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// out=1 and current_state=1 -> state 1
// out=1 and current_state=0 -> state 0
parameter S0 = 2'b00, // state 0
	S1 = 2'b01, // state 1
	S2 = 2'b10; // state 2
always @(posedge clk) // next state
begin
	if(reset)
	begin
	next_state = S0;
	present_state = S0;
	end
	else
	begin
	case(present_state)
	S0:
	begin
	if(in == 0)
	begin
	if(present_state != S1) // if in => 1 and state != 1, go to state 1
	begin
	present_state=S1;
	next_state=S1;
	end
	else // if in =>
================================================================
example-17: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk)
begin
if(reset==1)
	present_state<=0; //changing to state 0
else 
	present_state<=next_state; //don't change when reset is high
end
always@(present_state, in)
begin
next_state=0;
case(present_state)
0:begin
	if(in==1)
	begin
	next_state<=0;
	end
	else
	begin
	next_state<=1;
	end
end
1:begin
	if(in==0)
	begin
	next_state<=0;
	end
	else
	begin
	next_state<=1;
	end
end
endcase
end
assign out=present_state;

================================================================
example-18: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(present_state or in)
begin
	case(present_state)
	0:begin if(in)
	present_state<=0;
	else if(!in)
	present_state<=1;
	else 
	present_state<=present_state;
	next_state=present_state;
	end
	1:begin if(in)
	present_state<=1;
	else if(!in)
	present_state<=0;
	else
	present_state<=present_state;
	next_state=present_state;
	end
	default:
	next_state=0;
	endcase 
end
// Pfunction updates input and output during posedge clk
// out is output anytime and clk=1
Pfunction simple_fsm(out, next_state
================================================================
example-19: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// reset is a reset
//
// I used the struct def statement to declare the STATE and NEXT_STATE as types.
//A bunch of wires declared to not conflict with one another.
// 
//Next State and State Variables for the FSM
//
/*
 present_state: There are four possible states that the system could be in.
 
 0) The system is in a reset state. 
 1) The system is in a ready state. 
 2) The system is in an operating state. 
 3) The system is in an enable state.
 
 */

//Next state , State variable initializations.

initial
	begin
 
 
//States 0, 1, 2, 3 defined as Case statements
//State 0 and State 1 are the reset and ready states
	case(present_state)

0:	begin
	if(reset)
 

================================================================
example-20: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// output out is equal to (in^out)
parameter state0=0, state1=1;
always @(posedge clk)
if (reset)
present_state <= state0;
else 
present_state <= next;
always @(*) begin
case(currentstate)
state0: begin if(in)begin nextstate = state0; out=0 ; end 
else begin nextstate =state1; out =0; end 
end
state1: begin if (in) begin nextstate=state1 ; out=0 ; end 
else begin nextstate=state0;out=1;end 
end
endcase
end

================================================================
example-21: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
initial
begin
	present_state = 0;
	next_state = 0;
end
always @ (reset)
	if (reset)
	begin
	//set it all back to 0
	present_state = 0;
	next_state= 0;
	end
	else
	begin
	next_state = present_state;
	present_state = next_state;
	end
assign out = (present_state == 1);

================================================================
example-22: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// Note, need to fix next_state generation for Last state in given case
always @(posedge clk)
begin
if (reset)
begin
present_state <= 0;
// A present state or Reset state value is given
end
else 
if (in)
begin
if (present_state == 0)
begin
next_state <= 0;
// A next state value and whatever part in is equal to x
present_state <= 0;
// A change to state 0 
end
else if (present_state == 1) 
begin
next_state <= 1;
// A next state of 1 and anything else
present_state <= 1;
// On the next clock the present state will change to 1
end 
end
else
begin
if (present_state == 0)
begin
next_state <= 0;
// Not changing the state
present_
================================================================
example-23: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk, posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always@(present_state, in)
begin
next_state=0;
case(present_state)
0: begin
if(in==1'b1)
next_state = 0;
else
next_state = 1;
end
1: begin
if(in==1'b0)
next_state = 0;
else
next_state =1;
end
endcase
end
assign out = (present_state == 1)?1:0;

================================================================
example-24: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter up = 1'b0, down =1'b1;
always @(reset, `UP, `down)
begin
	if(reset) begin
	present_state = up;
	next_state = up;
	end
	else begin
	case(present_state)
	up: if(`down) begin
	next_state = down;
	end
	else begin next_state=up; end
	case(present_state)
	down: if(`down) begin
	next_state = down;
	end
	else begin next_state =up; end
	endcase
end

always @(posedge clk)
begin
	if(reset == 1'b1) begin
	present_state = up;
	end
	else begin
	present_state = next_state;
	end
end
================================================================
example-25: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
localparam resolution = 5;
reg [4:0] shiftReg = 5'b0;
assign out = (present_state == 1'b0);
always @ (posedge clk)
begin
	if (reset == 1'b0)
	begin
	shiftReg[4:0] <= 5'b0;
	present_state <= 1'b0;
	end
	else
	begin
	shiftReg[4:0] <= next_state;
	present_state <= next_state;
	end
end
always @ (*)
begin
	case (shiftReg[4:0])
	5'b0: next_state = in ? 5'b0 : 5'b1; 
	5'b1: next_state = in ? 5'b1 : 5'b0; 
	default: next_state= 5
================================================================
example-26: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
initial begin
present_state=0;
end

always@(posedge clk, posedge reset) begin
if (reset) begin
present_state<=0;
end
else begin
next_state<=present_state;
present_state<=next_state;
end
end
assign out= present_state;


================================================================
example-27: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
reg out;
initial
begin
// present state reg
	present_state = 1'd0;
// next state regs
	next_state = 1'd0;

	out = 1'd0;
end
always @(posedge clk, posedge reset)
begin
	if(reset)
	// upon reset, modified FSM will do...
	begin
	// present state reg
//god damnit c++ closure operator com
// they wrote c++ way again
	present_state = 1'd0;
// next state regs
	next_state = 1'd0;
	out = 1'd0;
	end
	else 
	begin
	// present state reg
	present_state = next_state;
// next state regs
	next_state = present_state;
// actions to take the FSM any the current state
	if(
================================================================
example-28: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ ( reset or clk )
begin : FSM_COMBO
	if (reset) 
	begin
 	 present_state <= #1 1'b0;
 	 next_state <= #1 1'b0;
 	 end
	else 
	begin
 	 present_state <= #1 next_state;
	end
end

================================================================
example-29: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk or posedge reset)
begin
	if (reset)
	begin
	present_state <= 0;
	end
	else
	begin
	present_state <= next_state;
	end
end
always @ (present_state or in)
begin
case(present_state)
0:
	begin
	if(in)
	begin
	next_state = 0;
	out = 1;
	end
	else
	begin
	next_state = 1;
	out = 0;
	end
	end
1:
	begin
	if(in)
	begin
	next_state = 1;
	out = 0;
	end
	else
	begin
	next_state = 0;
	out = 1;
	end
	end

endcase
end



================================================================
example-30: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(*) 
begin
case(present_state)
	0: begin
	present_state <=next_state;
	if(in) 
	begin
	out <=0;
	end
	else 
	begin
	out <=0;
	end
	end
	1:begin
	present_state <=next_state;
	if(in) 
	begin
	out <=1;
	end
	else 
	begin
	out <=0;
	end
	end
endcase
end
// Set up transition matrix
always @(*) 
begin
case(present_state)
	0:begin
	next_state <=in? 0:1;
	end
	1:begin
	if(in) 
	begin
	next_state <=0;
	end
	else 
	begin

================================================================
example-31: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(reset, in, present_state)
begin
	if (reset)
	begin
	present_state <= `INITIAL_STATE;
	end
	else
	begin
	present_state <= next_state;
	end
end
always @(*)
begin
	case (present_state)
	`INITIAL_STATE: 
	begin
	next_state <= `STATE_0;
	out <= `FALSE;
	end
	`STATE_0:
	begin
	next_state <= `STATE_1;
	out <= `FALSE;
	end
	`STATE_1: 
	begin
	next_state <= (in) ? `STATE_0 : `STATE_1;
	out <= (in) ? `TRUE : `FALSE;
	end
	default:
	begin
	
================================================================
example-32: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always_ff @(posedge clk) begin
	if (reset)
	begin
	present_state <= 0;
	end
	else
	begin
	present_state <= next_state;
	end
end
always_comb begin
	case (present_state)
	0:
	begin 
	if(in==1)
	begin
	next_state <= 0;
	out <= 0;
	end
	else
	begin
	next_state <= 1;
	out <= 0;
	end
	end
	1:
	begin 
	if(in==1)
	begin
	next_state <= 1;
	out <= 0;
	end
	else
	begin
	next_state <= 0;
	out <= 1;
	end
	end
	endcase
end

================================================================
example-33: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter up=1'b0, down=1'b1;
always @(posedge clk)
begin
	if (reset)
	begin
	present_state <= up;
	end
	else
	present_state <= next_state;
end
// next state values
always @(present_state,in)
begin
case(present_state)
	up: if(in)
	next_state <= up;
	else
	next_state <= down;
	down: if(in)
	next_state <= down;
	else
	next_state <= up;
endcase
end
// out values	
assign out = (present_state == up)? 1:0;

================================================================
example-34: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// state serial_out, clock = 0
// state serial_out, clock = 1
// Flip-flop state Logic:
reg state_flipfloptb;
always @(posedge clk)
begin
if(reset) begin
state_flipfloptb<=1'b0;
present_state<=1'b0;
end
else begin // reset ends here
case(present_state) // case to alter the output based on the current flip flop value of 0 or 1
1'b0 :begin 
if(in) begin //////// Start of logic to define state transition based on the 1 bit input called in
next_state<=1'b0;
state_flipfloptb<=1'b0;
end
else begin/// Start of logic to define state transition based on the 0 bit input called in
next_state<=
================================================================
example-35: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
reg out;
// Present state logic
always @*
begin
case ( present_state )
	0: begin
	if(in) 
	next_state <= 0;
	else
	next_state <= 1;
	out <= 1;
	end
	1: begin
	if(in) 
	next_state <= 1;
	else
	next_state <= 0;
	out <= 0;
	end
endcase
end
// Next state logic
always @*
begin
case ( present_state )
	0: begin
	if (reset) 
	present_state = 1;
	else
	present_state = 0;
	end
	1: present_state = next_state;
endcase
end

================================================================
example-36: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
	if(reset)
	begin
	present_state <= 1'd0;
	 end
	else
	begin
	present_state <= next_state;
	end
end
always @(present_state or in)
begin
case(present_state)
0:
begin
	if(in)
	begin
	next_state <= 0;
	end
	else
	begin
	 next_state <= 1;
	end
end
1:
begin
	if(in)
	begin
	next_state <= 1;
	end
	else
	begin
	next_state <= 0;
	end
end
endcase
end
assign out = (present_state==0)?1'b1:1'b0;

================================================================
example-37: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
initial
begin
	present_state=0;
	next_state=0;
end
always@(present_state or in)
begin
	case(present_state)
	0:
	begin
	if(~in)
	begin
	next_state=0;
	out=0;
	end
	else
	begin
	next_state=0;
	out=0;
	end
	end
	1:
	begin
	if(~in)
	begin
	next_state=1;
	out=1;
	end
	else
	begin
	next_state=0;
	out=0;
	end
	end
	
	endcase
	present_state=next_state;
end
always@(present_state or in)
begin
	case(present_state)

================================================================
example-38: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(*)
begin
case(present_state)
	0: begin
	if (in == 1'b0)
	next_state = 0;
	else
	next_state = 1;
	end
	1: begin
	if (in == 1'b0)
	next_state = 1;
	else
	next_state = 0;
	end
endcase
end
always @(posedge clk)
begin
if (reset)
present_state = 0;
else
present_state = next_state;
end
assign out = (present_state == 0) ? 1 : 0;

================================================================
example-39: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always_comb
begin
	present_state = 0;
	case ( {reset, in} )
	2'b00: next_state = 0;
	2'b01: next_state = 0;
	2'b10: next_state = 1;
	2'b11: next_state = 1;
	endcase
end
// register_module implementation, this is a behavioural model if <component name="" design_instance="">
// The name attribute "> design_instance=" is needed to distinguish between multiple computed instances
// The portnames attribute acts as a comment for the generic infer module
register_module #(0, 0) main_output (out, clk, 0, present_state, next_state);

================================================================
example-40: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = (present_state == 0) ? (in) : (~in);
// Design the next state output
always @(posedge clk or reset)
begin
if(!reset)
present_state <= 0;
else
present_state <= next_state;
end
// Moore state machine in a row
always @(in or present_state) // Asynchronous block
begin
case (present_state)
0 : if (in)
next_state = 0;
else
next_state = 1;
1 : if (in)
next_state = 1;
else
next_state = 0;
default : next_state = 0;
endcase 
end

================================================================
example-41: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter S0=0, S1=1;
//Stablish the present state
initial
begin
present_state = S0;
end
//Next state
assign next_state = (reset) ? S0 : present_state;
always @(posedge clk)
begin
	case(next_state)
	// Default state is `S0, we only care about the receiving
	// and ignore data that is not being sent
	S0: //Data is always 0 when state is S0
	begin
	if(in)
	next_state = S0;
	else
	next_state = S1;
	end
	S1: //Data is 0 when state is S1
	begin
	if(in)
	next_state = S1;
	else
	next_state = S0;
	end;
	default
================================================================
example-42: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
	begin
	if(reset)
	present_state <= 0;
	else
	present_state <= next_state;
	end
	always @(present_state, in)
	begin
	if(reset)
	next_state <= 0;
	else begin
	case(present_state)
	0: begin
	if(in)
	begin
	next_state <= 0;
	end
	else 
	begin
	next_state <= 1;
	end
	end
	1: begin
	if(in)
	begin
	next_state <= 1;
	end
	else 
	begin
	next_state <= 0;
	end
	end
	endcase
	end
	end
assign out = (present_state == 1);

================================================================
example-43: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = (present_state == 0) && in ? 0 : 0; // Means in state 0
always @(posedge clk or posedge reset)
if(reset) present_state <= 0;
else present_state <= next_state;
always @(in or present_state)
case(present_state)
0: begin 
	if(in == 1'b0) 
	next_state <= 0;
	else
	next_state <= 0;
	end
1: begin
	if(in == 1'b0)
	next_state <= 0;
	else
	next_state <= 1;
	end
endcase

================================================================
example-44: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
if (reset)
next_state <= 1;
else
next_state <= present_state;
end
always @(present_state, in)
case(present_state)
0: if(in)
out <= 0;
else
out <=0;
1: if(in)
out <= 1;
else
out <= 0;
endcase
always @(next_state)
begin
case(next_state)
0: present_state <= 0;
1: present_state <= 1;
endcase
end

================================================================
example-45: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
	if(reset)
	begin
	next_state <= 0;
	present_state <= 0;
	end
	else
	begin
	case(present_state)
	0:next_state <= (in==1)?0:1;
	1:next_state <= (in==1)?1:0;
	endcase
	present_state <= next_state;
	end
end
assign out = (present_state == 1)?1:0;

================================================================
example-46: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(present_state or in) begin
	case ( {present_state, in} )
	2'b00: next_state <= 0;
	2'b01: next_state <= 0;
	2'b10: next_state <= 1;
	2'b11: next_state <= 1;
	endcase
end	

always @(posedge clk) begin
	if(reset == 1) begin
	present_state <= 0;
	end
	else begin
	present_state <= next_state;
	end
end

assign out = (present_state == 1) ? 1 : 0;

================================================================
example-47: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

localparam RESET = 0, ONE = 1;

//state present state logic
assign present_state = (reset && in) ? RESET: ONE;

//next state logic
always @(present_state)
begin

case (present_state)

RESET:begin
if(in) begin
next_state <= RESET;
out <= 0;
end
else begin
next_state <= ONE;
out <= 0;
end
end

ONE: begin
if(in)begin
next_state <= RESET;
out <= 0;
end
else begin
next_state <= ONE;
out <= 1;
end
end

endcase

================================================================
example-48: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// Default values
present_state = 1;	

always @(*)
begin
	case (present_state)
	
	
	0:begin
	if(in)
	next_state = 0;
	else
	next_state = 1;
	end
	1:begin
	if(in)
	next_state = 1;
	else
	next_state = 0;
	end	
	default:begin
	next_state = 0;
	
	end
	
	
	endcase	
end

always @(posedge clk)
begin 
	if (reset)
	present_state <= 0;	
	else 
	present_state <= next_state;
end



================================================================
example-49: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
	if(reset) {
	present_state <=0;
	end
	if(present_state==0 && in) begin
	next_state <= 0;
	end
else if(present_state==1 && !in) begin
next_state <=1;
end
else begin
next_state <=present_state;
end
end
always @(posedge clk) begin
if(reset)
out <= 0;
else 
out <=next_state;
end

================================================================
