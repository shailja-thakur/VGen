example-0: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always_comb
begin
case( present_state )
1'b0 : 
if(in)
status=present_state;
else
status=1'b1;
1'b1:
status=1'b0;
default: status=1'bx;
endcase
case(status)
1'b1:next_state = 1'b0;
1'b0:next_state=1'b1;
default:next_state=1'bx;
endcase 
end
// Giving outputs
always_ff @ (posedge clk or posedge reset) 
begin
if(reset)
begin
real_out=1'b0;
end
else
begin
if(present_state!=next_state) real_out=1'b1;
else real_out=1'b0;
end
================================================================
example-1: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign present_state = {(in)?1'b1:1'b0, (reset)?1'b1:1'b0}; // Optional initializations
// next_state logic
always @(posedge clk, posedge reset)
begin
	if(reset) // Triggered reset
	 present_state <= {(in)?1'b1:1'b0, (reset)?1'b1:1'b0}; // Be careful about initializations here
	else
	 begin
	case(present_state)
	 16'h0001: next_state <= 16'h0002; // When s1 is 0 and s0 is 1 (in state 0), act like state 0
	 16'h0002: next_state <= 16'h0002; // If s0 is 0, stay in state 0, 
	 16'h4406: next_state <=
================================================================
example-2: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter A=0, B=1;
always @(posedge clk) begin
	if (reset==1'b1)
	present_state<=A;
	else
	present_state<=next_state;	
end
always @(present_state or in)
	next_state = 0;
	case(present_state)
	A: next_state = 0;
	B: next_state = 1;
	default: next_state = present_state;
	endcase


================================================================
example-3: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next_state is updated directly to out during the always block below
// Present State FF
reg[1:0] PS;
always @(posedge clk)
begin
	if (reset) 
	begin
	// Use FF to summit state infos and allow for reset values
	PS <= 2'b00;
	end
	else 
	begin
	case (PS)
	2'b00: if (in) begin
	case ({PS, in})
	2'b00, 1'b0: PS <= PS;
	2'b01, 1'b1: PS <= 2'b10;
	2'b10, 1'b1: PS <= 2'b00;
	2'b11, 1'b1: PS <= PS; // Idle case
	2'b11, 1'b0: PS <= PS; // Idle
================================================================
example-4: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk or reset or next_state)
begin
if(!reset)
	present_state<=0;
else
	present_state<=next_state;
end
always@(*)
begin
if(reset)
	next_state<=0;
else
	case(present_state)
	0:	next_state<=in ? 0 : 1;
	1:	next_state<=in ? 0 : 0;
	endcase
end
assign out<=present_state;

================================================================
example-5: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// Latching
always @(posedge clk, posedge reset) begin
	if (reset) begin // active high reset
 	present_state <= #1 0;
	next_state <= #1 0;
	end
	else present_state <= #1 in; 
end 
always @(in, present_state) begin
	case (present_state)
	 1'b0: next_state <= #1 in;
	 1'b1: next_state <= #1 1'b0;
	endcase
end
always @(posedge clk, posedge reset) begin
	if(reset) begin// active high reset
 	out <= #1 1'b0;
	end 
	else out <= #1 (present_state == 1)? 1:0; 
end


================================================================
example-6: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

always @(posedge clk)
begin
if(reset)
present_state <= 0;
else 
present_state <= next_state;
end

// Next state logic
always @(present_state or in)
begin
case(present_state)
0: next_state <= in? 1:0;
1: next_state <= in? 1:0;
endcase
end

================================================================
example-7: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
reg [1:0] state;
// Edge triggered sequential code section
always @(posedge clk or posedge reset)
	if(reset)
begin
	present_state <= 0;
	selected_register <= 0;
	state <= 0;
// Special case: register behaviour for state = 2
	selected_register[0] <= 0;	
	check_sum[0] <= 0;
	check_sum[1] <= 0;
	check_sum[2] <= 0;
	check_sum[3] <= 0;
end
	else
begin
	present_state <= next_state;
	case(present_state)
	0:	begin
	check_sum[0] <= in;
	check_sum[1] <= check_sum[0];
	check_sum[2] <= check_sum[1];
	check
================================================================
example-8: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk, posedge reset)
if(reset) begin
present_state<=0;
next_state=0;
end else begin
present_state<=next_state;
end

always@(in or present_state)
case(present_state)
0: if(in) next_state=1; else next_state=0;
1: next_state=0;
endcase
assign out= (present_state && 1);



================================================================
example-9: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
if(reset) 
present_state <= 1'd0;
else 
present_state <= next_state;
end
always@(present_state, in) begin
case (present_state)
1'b0: begin
	next_state <= in ? 1'b1 : 1'b0;
	out <= 1'b0;
	end
1'b1: begin
	next_state <= in ? 1'b1 : 1'b0;
	out <= 1'b0;	
	end
default: begin
	next_state <= 1'b0;
	out <= 1'b0;
	end
endcase
end
//
================================================================
example-10: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk, posedge reset)
if (reset) 
	present_state <= 0;
else
	present_state <= next_state;
	// doing Moore FSM here
always@(present_state)
	case (present_state)
	0: next_state <= in ? 1 : 0;
	1: next_state <= in ? 0 : 1;
	endcase
// Output
assign out <= (present_state == 1) && (next_state == 0);

================================================================
example-11: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// Instantiate the rest of the states you need. Each state contains a next_state wire
// by default.
reg_next_state regn (clk, reset, present_state, next_state);
initial
begin
present_state = 0;
next_state = 0;
end
always @ (posedge clk or negedge reset)
begin
if (!reset)
present_state=0;
else
present_state=next_state;
end
always @ (present_state, in)
begin
case (present_state)
0: if (in) next_state = 0;
else
next_state= 1;
1: if (in) next_state = 0;
else
next_state= 1;
default: 
	next_state = present_state;
endcase
end

================================================================
example-12: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// next_state = f(present_state, in)
always @(present_state or in)
case(present_state)
0: if(in == 1) next_state=0; else next_state=1; 
1: if(in == 1) next_state=1; else next_state=0; 
default next_state=0; 
endcase
// present state is the counter variable, next state is the output of the function.
assign out = (present_state == 1)? 1:0;
always @(posedge clk or negedge reset) 
begin 
if(reset == 0) 
present_state <= 0;
else
present_state <= next_state; 
end 

================================================================
example-13: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter s0=2'b00, s1=2'b01;
//state register
reg[1:0] state;
always@(posedge clk, posedge reset)
 begin
	if (reset)
	begin
	state = s0;
	present_state <= s0;
	end
	else
	present_state <= state;
 end
//next state
always@(present_state, in)
 begin
 case(present_state)
 s0: if(in) next_state = s1;
	else next_state = s0;
 s1: if(in) next_state = s0;
	else next_state = s1;
 endcase
 end
//output
always@(present_state)
 begin
 case(present_state)
 s0: out = 0;
 s1: out = 0
================================================================
example-14: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// In state 2, if in=1, stay in state 0, out=1 in state 1.
// Simple two-directional mux
always @(posedge clk)
begin
	if (reset==1'b0)begin
	present_state = 0;
	next_state = 0;
	$display("Empty");
	end
	else begin
	case({present_state, in})
	2'b0_0: begin
	next_state = 0;
	$display("0 0, input: %b present state: %b next state: %b\n", in, present_state, next_state);
	end
	2'b0_1: begin
	next_state = 1;
	$display("0 1, input: %b present state: %b next state: %b\n", in, present_state, next
================================================================
example-15: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter 0 = 2'b00,
	1 = 2'b01,
	2 = 2'b10;
// State table
always @(posedge clk, posedge reset)
	if(reset)
	present_state <= 0;
	else
	present_state <= next_state;
// Next state
always @(present_state, in)
case(present_state)
	0: next_state = (~in)? 0:1;
	1: next_state = (~in)? 1:0;
	default: next_state = 2'bxx;
endcase 
assign out = (present_state == 2'b11);

================================================================
example-16: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state;
always @ (posedge clk) begin
if (reset) begin
present_state <= 0;
next_state <= 0;
end
else begin
present_state <= next_state;
end
// State transitions
case (next_state)
1'b0 : next_state <= 1'b1 ; // Output 0 state
1'b1 : next_state <= 1'b0 ; // Output 0 state
default : next_state <= 1'bx ; //Evarily '1' state
endcase
end
// Next state and present state registers
always @ ( posedge clk ) begin
if (reset || next_state != present_state) begin
next_state <= 1'b0;
end
present_state <= next_state;
end 

================================================================
example-17: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk or posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
always @ (present_state or in or next_state)
begin
case(present_state)
0 : next_state <= in ? 0 : 1;
1 : next_state <= in ? 1 : 0;
endcase
end
assign out = ~present_state & next_state; 

================================================================
example-18: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
if(reset)
	present_state <= 0;
else
	present_state <= next_state;
// Moore Moore FSM- {in,present_state} -> {0,1} -> {next_state} ->{present_state,out}
always @(present_state or next_state or in) 
begin 
	case({present_state, in}) 
	 //{present_state, in} -> {next_state} -> {present_state,out}
	 {1'b0,1'b1}: next_state = 1'b0;	//state 1
	{1'b1,1'b1}: next_state = 1'b1; 	//state 0
	{1'b1, 1'b0}: next_state = 1'b0;	
================================================================
example-19: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
if(reset)
present_state <= 1'b0;
else
present_state <= in;
always @(present_state or next_state)
case(present_state)
0 : next_state <= in; 
1 : next_state <= 1; 
endcase 
assign out = (present_state==1);


================================================================
example-20: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or negedge reset)
begin
if (!reset)
present_state <= 0;
else
present_state <= next_state;
end
always @(present_state or in)
//Next state assignment
begin
next_state <= present_state;
case (present_state) 
0 : if (in)
next_state <= 1; else next_state <= 0;
1 : if (in)
next_state <= 1; else next_state <= 0;
endcase
end

================================================================
example-21: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
if (reset) 
present_state <= 0;
else 
present_state <= next_state;
end
// Next state logic
always @(present_state or in)
case (present_state)
0: begin
next_state = in ? 0 : 1;
end
1: begin
next_state = in ? 0 : 0; 
end
default : 
next_state = 1'bx;
endcase
// ************ output
always @(present_state)
case (present_state)
0: out = 0;
1: out = 0;
endcase

================================================================
example-22: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(in or present_state or next_state)
begin
case(present_state)
0: present_state <= in;
0: next_state <= in;
1: next_state <= 0;
endcase
end
always @(present_state)
begin
case(present_state)
0:out <= 0;
1:out <= 1;
endcase
end

================================================================
example-23: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin : FSM
if(reset == 1)
present_state<=0;
else
present_state<=next_state;
end
always @(present_state, in)
begin : Moore_FSM
case(present_state)
0 : begin
if(in==1) next_state <=0;
else next_state <=1;
end
1 : begin
if(in==1) next_state<=1;
else next_state <=0;
end
default : next_state<=0;
endcase
end
assign out= (!reset) && (!present_state);
 

================================================================
example-24: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
reg present_state, next_state;
parameter state0 = 1'b0, state1 = 1'b1;
// Outputs
always@(posedge clk) begin
// Combinational logic
if(reset == 1'b0)
present_state <= state0;
else
present_state = next_state;
end
// State transition
always@(present_state or in) begin
next_state <= present_state;
case(present_state)
store <= 1'b0;
load_and_prepare <= 1'b0;
repeat_load <= 1'b0;
state0 <= in & state0;
state1 <= in & store;
endcase
end

================================================================
example-25: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge reset or posedge clk) begin
	if(reset)
	// reset high only
	present_state <= 1'b0;
	else
	// all else, current state value is true
	present_state <= next_state;
end
always@(posedge clk) begin
	// next_state can be a function of previous state and input
	if(reset) next_state <= 1'b0;
	else case(present_state)
	// this should be pretty obvious lol
	1'b0: next_state <= (in)? 1'b1: 1'b0;
	1'b1: next_state <= (in)? 1'b0: 1'b1;
	default: next_state <= present_state;
	endcase
end
//output
always@(posedge resreset) begin

================================================================
example-26: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
	if (reset) begin
	present_state <= 0;
	next_state <= 0;
	end
	else
	present_state <= next_state;
end
always @(present_state or in)	
begin
	if (present_state == 0) 
	if(in) begin
	next_state <=1;
	end
	else
	begin
	next_state <= 0;
	end
	
	if (present_state == 1) 
	if(in) begin
	next_state <= 0;
	end
	else
	begin
	next_state <= 1;
	end
end
// If in=0, next state 1, else next state 0
assign out = present_state == 1 ? 1'b1 : 1'b0;


================================================================
example-27: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
if(reset)
present_state<=0;
else
present_state<=next_state;
// next_state=present_state;
/*always@(present_state or in)
if(in)
next_state=0;
else
next_state=present_state;
end*/
always @(*)
case(present_state)
0: begin if(in) next_state=1; else next_state=0; end
1: begin if(in) next_state=0; else next_state=1; end
default: next_state = present_state;
endcase
// out=1 if in=1 in state 0 and out=0 in state 1
//out = 0; if in=1 in state 1 and out=1 in state 0 

================================================================
example-28: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter state0 = 0;
parameter state1 = 1;
always @(negedge clk or posedge reset)
begin
	if (reset)
	begin 
	present_state <= state0;
	end
	else 
	present_state <= next_state;
end
always @(present_state or in)
begin
next_state = (~in) ? state0 : (~reset) ? state1 : (~present_state) ? state1 : state0;
end
always @(present_state or in)
	case (present_state)
state0: if(in) out = 0; else out = 0;
state1: if(in) out = 0; else out = 1;
default: out = 0;
	endcase

================================================================
example-29: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter state_00 = 0;
parameter state_01 = 1;
always @(posedge clk)
begin: find_next_state
if (reset)
present_state = state_00;
else
present_state = next_state;
end
always @(present_state, in)
begin: determine_output
case (present_state)
state_00 : if ( in)
next_state = state_01;
else
next_state = state_00;
state_01 : if ( in)
next_state = state_01;
else
next_state = state_00;
default : next_state=state_00;
endcase
end
assign out = ( present_state == state_01)? 1:0;

================================================================
example-30: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, reset)
	begin
	 if (reset)
	 	present_state <= 0;
	 else
	 	present_state <= next_state;
	end
always @(present_state, in)
	begin
	 case(present_state)
	 0: next_state <= in ? 1 : 0;
	 1: next_state <= in ? 0 : 1;
	 endcase
	end
	assign out = present_state;

================================================================
example-31: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
parameter state_0=1'b0,
state_1=1'b1;
always @(posedge clk or posedge reset)
begin
	if (reset)
	present_state <= state_0;
	else
	present_state <= next_state;
end
always @(present_state, in)
case (present_state)
	state_0: begin
	if (in == 1)
	next_state <= state_1;
	else
	next_state <= state_0;
	end
	state_1: begin
	if (in == 0)
	next_state <= state_0;
	else
	next_state <= state_1;
	end
endcase

================================================================
example-32: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

always@(posedge clk)
 if(reset)
 present_state <= 0;
 else
 present_state <= next_state;

always@(in or present_state or next_state)
 case(present_state)
 0:
 if(in)
 next_state <= 1;
 else
 next_state <= 0;
 // Stay in same state unless reset or input changes
 1:
 if(in)
 next_state <= 1;
 else
 next_state <= 0;
// State 0 / State 1 are FSM's determined by top module
endcase
assign out = (present_state == 0) ? 0 : 1;


================================================================
example-33: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

parameter s0 = 0;
parameter s1 = 1;

reg[1:0] current_state, next_state;


always @(posedge clk or posedge reset)
begin
 if (reset)
 current_state <= 0;
 else
 current_state <= next_state;
end

always @(current_state or in)
begin
 case(current_state)
 s0 : begin
 if (in == 1) 
next_state = s0;
 else if (in == 0)
next_state = s1;
 else
next_state = s0;
 end
 s1 : begin
 if (in == 1)
 next_state = s1;
 else if (in == 0)
next_state = s0;
 else
next_state = s1;
 end
endcase
end

always @(
================================================================
example-34: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
	if (reset == 1)
	begin
	present_state <= 0;
	next_state <= 0;
	end
	else
	begin
	present_state <= next_state;
	end
end
always @(present_state, in)
begin
	case(present_state)
	1: next_state <= (in)? 0 : 1;
	default: next_state <= 0;
	endcase
end
wire out1;
assign out1 = (present_state == 0) ? 1 : 0;
assign out = present_state == 1 ? 1 : 0;

================================================================
example-35: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(in or present_state)
begin
case (present_state)
0: begin
if (in==1)
present_state <= next_state; 
else
present_state <= 0;
end
1: begin
if (in == 1)
present_state <= next_state;
else
present_state <= 0;
end
endcase
end
end
// Moore FSM
parameter S0 = 0, S1 = 1, S2 = 2, S3 = 3;
always@(present_state or in)
case (present_state)
S0: begin
if (in)
next_state = S0;
else
next_state = S2;
end
S1: begin
if (in)
next_state = S1;
else
next_state = S2;
end
S2: begin
next
================================================================
example-36: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) begin
if (reset == 1) present_state <= 0; else present_state <= next_state;
end
always @(present_state or in) begin
case (present_state)
0 : if(in == 1) next_state <= 1; else next_state <= 0;
1 : if(in == 1) next_state <= 1; else next_state <= 0;
endcase
end
always @(present_state) begin
case(present_state)
0 : out = 0;
1 : out = 0;
endcase
end

================================================================
example-37: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
begin
	if (reset == 1) begin
	// reset is asserted.
	present_state <= 0;
	next_state <= 0;
	end
	else begin
	if (in) begin
	next_state = present_state;
	end
	// When the next state sequence arrives, we can also determine the next output.
	case (present_state)
	4'b0000 : begin // if this rule doesn't apply why serialise this loop as it cannot be synthesised otherwise
	if(in)
	next_state = 4'b0000;
	else
	next_state = 4'b0001;
	end
	4'b0001 : begin // because serialisation only writes if singleton assigned here does not violate its independence rules (violating the above rule)
	/* Yes, like in a
================================================================
example-38: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
reg [2:0] present_state;
always @(posedge clk, posedge reset)
begin
if (reset) 
present_state = 0;
else 
present_state = next_state;
end
// Moore state machine
always @(present_state or in or next_state)
begin
case (present_state)
0 : begin
if (in == 1)
next_state = 1;
else
next_state = 0;
end
1 : begin
if (in == 1)
next_state = 0;
else
next_state = 1;
end
default : next_state = 3;
endcase
end
// Output of state machine
assign out = (present_state == 2);

================================================================
example-39: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
begin
 if (reset)
 present_state <= 0;
 else 
 present_state <= next_state;
end
always @(present_state, in)
begin
 case (present_state)
 0 : next_state <= in;
 1 : next_state <= 0; 
endcase
end

================================================================
example-40: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk, posedge reset)
if(reset == 1)
present_state <= 0;
else
present_state <= next_state;
// Next state sequential logic
always @(present_state, in)
case(present_state)
0 : next_state <= in ? 0 : 1;
1 : next_state <= in ? 1 : 0; 
default: next_state <= present_state;
endcase
// Output logic
assign out = (present_state == 0) && (next_state == 1);

================================================================
example-41: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// States are binary encoded. 000=state 0; 010=state 1; others=state 2
always@(posedge clk or posedge reset) begin
if(reset) present_state<=0;
else present_state<=next_state;
end
always@(present_state or in) begin
case(present_state)
	0:	begin
	if(in) next_state=1;	//Go to state 0 if in arrives
	else next_state=0;	//Stay in state zero if not in
	end
	1:	begin
	if(in) next_state=0;	//Stay in state zero if in arrives
	else next_state=1;	//Go to state 1 if not in
	end
	default:	next_state=2;	//Convenience so a state 2 can be added if desired

================================================================
example-42: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk or posedge in or posedge reset)
begin
if(reset)
present_state <= 0;
else
present_state <= next_state;
end
// Next state assignment
always @(present_state, in)
begin
case(present_state)
0: begin
if(in)
next_state <= 1;
else
next_state <= 0;
end
1: begin
if(in)
next_state <= 0;
else
next_state <= 1;
end
endcase
end
// Output
assign out = ((present_state == 0) && (in == 1)) ? 1 : 
((present_state == 1) && (in == 1)) ? 0 :
((present_state == 0) && (in == 0)) ? 0 :
((present_state == 1) && (in == 0)) ?
================================================================
example-43: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk) 
begin
if(reset) 
	present_state <=0;
else 
	present_state <= next_state;
end
always@(present_state, in) 
begin
case(present_state)
0 :
	if(in)
	begin
	next_state = 1;
	out <= 0;
	end
	else
	begin
	next_state <= 0;
	out <= 0;
	end
1 :
	if(in)
	begin
	next_state <= 1;
	out <= 0;
	end
	else
	begin
	next_state <= 0;
	out <= 1;
	end
endcase
end

================================================================
example-44: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// When reset is called, go back to state 0.
always@(posedge clk, posedge reset)
if (reset) present_state <= 0;
else present_state <= next_state;
// Combinational logic of the Moore FSM.
always@(present_state, in)
case (present_state)
0 : next_state <= in ? 0 : 1;
1 : next_state <= in ? 1 : 0;
default : next_state <= 1'bx;
endcase
// Output logic of Moore FSM
assign out = present_state == 1;

================================================================
example-45: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// FSM output
always @(posedge clk, posedge reset)
 if(reset)
 present_state <= 0;
 else begin
 
 present_state <= next_state; 
 
 end 
 always @(present_state, in)
 case(present_state)
 0: next_state <= in ? 0 : 1;
 1: next_state <= in ? 1 : 0;
 endcase
 // Output logic
 assign out = (present_state == 0) && (next_state == 1);

 endmodulemodule fsm_wrapper(clk,reset,in,out,states);
input clk;
input reset;
input in;
output out;
output [3:0] states;
wire out;
wire [3:0] states;
simple_fsm fsm(clk,reset,in,out,states);

================================================================
example-46: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// Then, use present and next state to infer
// next state = present state + in
// present state = in + prev state

always @(posedge clk or negedge reset)
begin:state_proces
if(reset == 1'b0)
present_state <= 1'b0;
else
present_state <= next_state;
end


always @(present_state, next_state)
begin:state_table
if(present_state == next_state)
next_state <= 2'b00;
else if (present_state == 2'b00)
next_state <= next_state;


end


always @(posedge clk or negedge reset)
begin:out_lookup
if(reset == 1'b0)
out <= 1'b0;
else begin
case(next_state)
1
================================================================
example-47: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// ... 1 and 0 in state 1 and 1 and 0 in state 0
// Assume no metastable states
assign present_state = reset ? 0 :
latch ? 1 : ctl ? 0 : present_state;
// Combo Logic Block
// Next state is present state in state 0, unless specified otherwise
// in this case, next state becomes the state after the clock edge.
always @(present_state, in)
begin : NC
	if(in ^ next_state)
	begin : NC1
	// incoming data is a transition away from current state
	end
	else
	begin : NC2
	// transitioning because of control signal
	end
end // always @ (present_state, in)
// Modified Logic Block
// Our next state is just the output of the combinator currently."
assign next_state = in ? comb : present_state;
// Assign
================================================================
example-48: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
//remember, next_state=present_state && (in)
	always @(posedge clk)
	begin
	if (reset == 1)
	begin
	present_state <= 0;
	end
	else
	begin
	present_state <= next_state;
	end
	end
	always @(*)
	begin
	case(present_state)
	0: next_state = (in) ? 1 : 0;
	1: next_state = (in) ? 0 : 1;
	default: next_state = present_state;
	endcase
	end
	assign out = (present_state == 1 && in == 1) ? 1 : 0;	// if using == by using a case-statement instead
	// if using !=
	//assign out = (present_state != 1) ? 1 : 0;
end
================================================================
example-49: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// out=1 in state 1. Now in state=0
always@(posedge clk or posedge reset)
begin: case
	
	if (reset == 1'b1)
	begin
	
	present_state <= 0;
	next_state <= 0;
	
	$display("reset state 0");
	
	end // end if reset
	
	else 
	begin
	
	present_state <= next_state;
	next_state <= 0;
	
	//$display("present state %b , next sate %b",present_state,next_state);
	
	end //end else

default: next_state=present_state;

end // end case

================================================================
