example-0: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = (reset) ? 1 : (r_reg[2] ^ r_reg[4]);
assign r_next = (reset) ? 5'b10000 : (r_reg + feedback_value);
assign q = r_reg;
// register the current value of r_reg
always @(posedge clk) 
begin
	r_reg <= r_next;
end

================================================================
example-1: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = ~(r_reg[3] ^ r_reg[2]);
assign r_next = {r_reg[4], r_reg[3] ^ r_reg[4], r_reg[3], r_reg[4]};
assign q = r_reg;
// register the values of r_next and feedback_value
always @(posedge clk, posedge reset)
begin
if(reset)
 r_reg <= 5'b11111;
else
 r_reg <= r_next;
end

================================================================
example-2: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = (r_reg[2] ^ r_reg[4]);
assign r_next = {r_reg[4], feedback_value};
//assign q = r_reg;
assign q = r_next;
always @(posedge clk) begin
if (reset) begin
r_reg <= 5'b100001;
end
else begin
r_reg <= r_next;
end
end

================================================================
example-3: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg; 
always @ (posedge clk)
begin
if (reset)
begin
r_reg <= 5'b10000;
end
else
begin
r_reg <= r_next;
end
end
// calculate the next r_next value based on the feedback_value
// bit-wise feedback concatenation
// r_next = r_reg ^ {feedback_value, r_reg[4:2]};
assign r_next = {feedback_value, r_reg[4:2]};
assign feedback_value = r_reg[4] ^ r_reg[3]; 

================================================================
example-4: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next[0] = (reset || r_reg[4]) ? 1'b1 : 1'b0;
assign r_next[1] = (r_reg[0] || r_reg[4]) ? 1'b1 : 1'b0;
assign r_next[2] = r_reg[0] ? 1'b1 : 1'b0;
assign r_next[3] = r_reg[0] ? 1'b1 : 1'b0;
assign r_next[4] = r_reg[0] ? 1'b1 : 1'b0;
assign feedback_value = r_reg[2] ^ r_reg[4];
assign q = r_reg;
always @ (posedge clk)
begin
	r_reg <= r_next;
end

================================================================
example-5: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @ (posedge clk or posedge reset)
	begin
	if (reset)
	// if reset is high set r_reg to 1
	r_reg <= 8'b0000_0001;
	else
	// if reset is low assign r_reg to r_next
	r_reg <= r_next;
	end

================================================================
example-6: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @(posedge clk)
begin
	if (reset)
	begin
	r_reg <= 5'b00001;
	end
	else
	begin
	r_reg <= r_next;
	end
end 
// generate input to feedback logic
assign r_next = {r_reg[4], r_reg[4], feedback_value, r_reg[4], r_reg[4:1]};

================================================================
example-7: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = (r_reg[4] ^ {r_reg[4],r_reg[3]}) | {r_reg[4],r_reg[3],feedback_value};
always @(posedge clk)
begin
if (reset)
r_reg <= 5'b1;
else
r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-8: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk) begin
	if(reset) begin
	r_reg <= 5'b1;
	end else begin
	r_reg <= r_next;
	end
end
assign feedback_value = ^{1'b0,r_reg[3:1]}; //^ is a bitwise xor
assign r_next = {r_reg[4],r_reg[4:1] ^ feedback_value}; 
assign q = r_reg;

================================================================
example-9: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = ^{2'b0, r_reg[4]};
assign r_next = r_reg[4] ? r_reg ^ feedback_value : r_reg;
// when the reset signal is asserted, set the value of r_reg to 1
// otherwise assign r_next to r_reg
always @(posedge clk) begin
if (reset)
r_reg <= 5'b1;
else
r_reg <= r_next;
end

================================================================
example-10: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @ (posedge clk) begin
if (reset)
r_reg <= 5'b10000;
else
r_reg <= r_next;
end
// determine r_next
assign r_next = {r_reg[4], r_reg[4] ^ r_reg[3]};

================================================================
example-11: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset == 1'b0) ? 5'b1 : 
(feedback_value == 1'b0) ? r_reg :
(r_reg & {q[4], q[4] ^ q[3], q[4] ^ q[0]}) ^ {q[2], q[2] ^ q[1], q[2] ^ q[0]};
always @ (posedge clk)
begin
r_reg <= r_next;
end
assign feedback_value = (r_reg & {q[2], q[2] ^ q[1], q[2] ^ q[0]}) ^ {q[2], q[2] ^ q[1], q[2] ^ q[0]};
assign q = r_reg;

================================================================
example-12: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = ^(r_reg[2:0]);
assign r_next = r_reg ^ (feedback_value);
always@(posedge clk or posedge reset)
begin
if(reset)
r_reg <= 5'b1;
else
r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-13: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @ (posedge clk or posedge reset) begin
 if (reset) begin
 r_reg <= {4'b0101};
 end
 else begin
 r_reg <= r_next;
 end
end
// next function returns the next value in r_next, based on r_reg
// xor with feedback value, xor with r_reg
// concatenate r_reg with r_reg shifted left 1
function [4:0] next;
input [4:0] r_reg;
begin
 next = {r_reg[4], r_reg[3] ^ r_reg[4], r_reg[2] ^ r_reg[4], r_reg[1] ^ r_reg[4]};
 end

================================================================
example-14: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = r_reg ^ (r_reg ^ (r_reg >> 4));
always @ (posedge clk)
begin
if (reset)
begin
r_reg <= 1;
end
else
begin
r_reg <= r_next;
end
end
assign q = r_reg;

================================================================
example-15: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = r_reg ^ feedback_value;
assign q = r_reg;
// input clock
// input reset
// output [4 : 0] q
// output [4 : 0] r_next
// output feedback_value
initial begin
	r_reg <= 5'b0;
end
always @ (posedge clk or posedge reset) begin
	if(reset) begin
	
	end
	else begin
	
	end
end

================================================================
example-16: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
// q_out is the feedback value
// for all bits except bit 0
// q_out = q_reg[3] ^ q_reg[4] ^ q_reg[0] ^ q_reg[1] ^ q_reg[2] ^ q_reg[3] ^ q_reg[4] ^ q_reg[5] ^ q_reg[0] ^ q_reg[1] ^ q_reg[2] ^ q_reg[4] ^ q_reg[5] ^ q_reg[6]
// use an assign statement to concatenate bit position 3 with bit position 4
// then concatenate with bit position 0 at the end
assign r_next = {r_reg[3] ^ r_reg[4] ^
================================================================
example-17: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// define the feedback circuit
assign feedback_value = q[4] ^ q[2];
// define the clk and reset instances
always @(posedge clk) 
begin
	if (reset)
	begin
	// when reset is asserted, set the value of r_reg to 1
	r_reg <= 1'b1;
	// wait 1 clock cycle for feedback to update
	end
	else
	begin
	// else, maintain the previous value
	r_reg <= r_next;
	end
end
// define the r_next circuit
assign r_next = (r_reg & ~reset) | (r_reg & feedback_value);

================================================================
example-18: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset == 1'b1) ? r_reg : (feedback_value ^ r_reg[2] ^ r_reg[4]);
always @(posedge clk) begin
	r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-19: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset) ? 5'b00000 : (r_reg ^ (r_reg >> 2) ^ (r_reg >> 4));
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
assign clk_en = ~reset;
// instantiate a clk_divider module with 4 as the number of divisors
// create a clock divider module with 4 as the number of divisors
// assign the clock divider output to the module lfsr output

================================================================
example-20: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = (reset) 
? 5'b1 
: r_reg ^ {r_reg[4], r_reg[3] ^ feedback_value};
always @(posedge clk)
begin
	if (reset)
	begin
	 r_reg <= 5'b1;
	 end
	 else
	 begin
	 r_reg <= r_next;
	 end
end
assign q = r_reg;

================================================================
example-21: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {r_reg[4], r_reg[3] ^ feedback_value};
// always block that changes r_reg
always @(posedge clk or posedge reset)
begin
 if (reset)
 r_reg <= 5'b10000;
 else
 r_reg <= r_next;
end
// assign the bits of r_reg to q
assign q = r_reg;

================================================================
example-22: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg; 
always @ (posedge clk or posedge reset) begin 
	if(reset) begin
	r_reg <= 5'b00000;
	end
	else begin 
	r_reg <= r_next;
	end
end
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {r_reg[3:1],r_reg[4] ^ feedback_value};

================================================================
example-23: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q=r_reg;
always @(posedge clk)
begin
if(reset)
begin
r_reg<=5'b11001;
end
else
begin
r_reg<=r_next;
end
end
assign feedback_value=(r_reg[2]^r_reg[4]);
assign r_next=r_reg^(feedback_value<<1);

================================================================
example-24: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset) ? 5'b1 : (r_reg ^ {feedback_value, r_reg[4], r_reg[3]});
always @ (posedge clk)
begin
if (reset)
begin
r_reg <= 5'b1;
end
else
begin
r_reg <= r_next;
end
end
assign q = r_reg;
// note: the design is implemented as an always @ (posedge clk) block
// but the following code can be used to simulate it (as shown in the lab guide)
// always @ (reset)
// begin
// if (reset)
// begin
// r_reg = 5'b1;
// end
// else
// begin
// r_reg = r_next;
// end
// end

================================================================
example-25: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @(posedge clk or posedge reset)
begin
if (reset == 1)
r_reg <= 5'b100001;
else
begin
r_reg <= r_next;
end
end
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {r_reg[3:1], feedback_value};

================================================================
example-26: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @(posedge clk)
begin
	if (reset)
	begin
	// reset state to 1
	r_reg <= {1'b1,{4{1'b0}}};
	//q = 5'b00000;
	end
	else
	begin
	r_reg <= r_next;
	//q = r_next;
	end
end
// Compute the next value for r_next
assign r_next = {r_reg[4], r_reg[4] ^ r_reg[2]};
assign feedback_value = r_reg[4] ^ r_reg[2];

================================================================
example-27: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @ (posedge clk, posedge reset)
begin
if (reset)
	r_reg <= 5'b10011;
else
	r_reg <= r_next;
end
// define the feedback function
assign feedback_value = ^{r_reg[2:0], r_reg[4]};
// define the next state
assign r_next = (feedback_value) ? r_reg : r_reg + 5'b00011;

================================================================
example-28: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = (reset)? 5'b1 << 4 : r_reg;
assign feedback_value = r_reg[4] ^ r_reg[3];
assign q = r_reg;
always @(posedge clk) begin
 r_reg = r_next;
end

================================================================
example-29: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign feedback concatenated with q to itself
assign feedback_value = q[2] ^ q[4];
assign r_next = {r_reg[4], r_reg[3] ^ feedback_value, r_reg[2], r_reg[1] ^ feedback_value, r_reg[0] ^ feedback_value};
always@(posedge clk or posedge reset)
begin
if(reset)
	r_reg <= 5'b1;
else
	r_reg <= r_next;
end
assign q = r_reg;

================================================================
example-30: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// shift the least significant bit to the right
assign feedback_value = r_reg[2] ^ r_reg[4];
always @ (posedge clk)
begin
	if (reset)
	begin
	// set value of r_reg to all 1's
	// this is done by using the concatenation operator {5{1'b1}}
	r_reg <= {5{1'b1}};
	// set the value of r_next to all 1's
	r_next <= {5{1'b1}};
	end
	else
	begin
	// shift the value of r_reg to the right
	r_reg <= r_next;
	// xor r_reg with feedback_value
	r_next <= r_reg ^ feedback_value;
	end
end

================================================================
example-31: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next[0] = r_reg[0] ^ r_reg[4];
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next[1] = r_reg[1] ^ r_reg[4] ^ r_reg[0];
assign r_next[2] = r_reg[2];
assign r_next[3] = r_reg[3] ^ r_reg[4] ^ r_reg[0];
assign r_next[4] = r_reg[4];
always @ (posedge clk)
begin:r_reg_concat
	if (reset == 1'b1)
	begin
	r_reg <= 5'b00000;
	end
	else
	begin
	r_reg <= r_next;
	end

================================================================
example-32: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
// assign bit position 0 of r_next to feedback_value
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @( posedge clk or posedge reset ) begin
if ( reset ) begin
r_reg <= 1;
end
else begin
r_reg <= r_next;
end
end
assign r_next = {r_reg[3], r_reg[4] ^ feedback_value};

================================================================
example-33: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg ^ r_reg << 1;
// flip the bits if reset is asserted
assign r_next = (reset) ? 0 : r_reg + feedback_value;
always @(clk)
begin
	if (reset) r_reg <= 0;
	else r_reg <= r_next;
end

================================================================
example-34: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = r_reg[4] ^ feedback_value;
always @ (posedge clk)
begin
if (reset) 
r_reg <= 5'b01010; // 010 is decimal 2
else
r_reg <= r_next;
end 
assign q = r_reg;

================================================================
example-35: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// calculate the next value
assign r_next = (r_reg & q[4]) ^ (r_reg & ~q[4]) ^ (q[2] & q[4]) ^ (q[2] & ~q[4]);

always @(posedge clk)
begin
	if (reset)
	begin
	r_reg <= 'd1;
	end
	else
	begin
	r_reg <= r_next;
	end
end
// feedback = (r_reg[2] & r_reg[4]) + (r_reg[2] & ~r_reg[4]) + (~r_reg[2] & r_reg[4]) + (~r_reg[2] & ~r_reg[4])

================================================================
example-36: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @(posedge clk or posedge reset) begin
if(reset) r_reg <= 5'b1 << 4; // assign r_reg to 1
else begin
r_reg <= r_next;
end
end
// calculate the next value of r_next
assign r_next = r_reg ^ (5'b1 << feedback_value); 

================================================================
example-37: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
//assign q = {r_reg[0], r_next[0] ^ r_reg[4] ^ r_reg[3]};
//assign q = {r_reg[0], r_next[0] ^ r_reg[4] ^ r_reg[3], r_next[1] ^ r_reg[0] ^ r_reg[4] ^ r_reg[2] ^ r_reg[3] ^ r_reg[1] ^ r_reg[0] ^ r_reg[2] ^ r_reg[4] ^ r_reg[5]};
assign q = {r_reg[0], r_next[0] ^ r_reg[4] ^ r_reg[3], r_next[1] ^ r_reg[0] ^ r_reg[4] ^ r_reg[2] ^ r_reg[
================================================================
example-38: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = ~(r_reg[2] ^ r_reg[4]);
always @(posedge clk, posedge reset)
begin
	if (reset)
	begin
	r_reg <= 5'b11111;
	end
	else
	begin
	r_reg <= r_next;
	end
end
assign r_next = r_reg ^ {r_reg[3], feedback_value};

================================================================
example-39: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
always @ (posedge clk)
begin
if (reset)
r_reg <= 5'b10000;
else
begin
r_reg <= r_next;
end
end
// Calculate the next value of r_next
assign r_next = r_reg << 1;
// XOR bit positions 2 and 4 of r_reg with r_next
// concatenate r_reg with the 4 most significant bits of r_next

================================================================
example-40: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk, posedge reset) begin
	if (reset) 
	begin
	r_reg <= 5'b1;
	end
	else 
	begin
	r_reg <= r_next;
	end
end
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {r_reg[4], r_reg[3:1]};
assign q = r_reg;

================================================================
example-41: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
always @(posedge clk)
begin
	if (reset) 
	begin
	r_reg <= 'b1;
	end 
	else
	begin
	r_reg <= r_next;
	end 
end
assign q = r_reg;
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {r_reg[3:1],feedback_value};

================================================================
example-42: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next[0] = ~r_reg[1] & ~r_reg[0] & ~r_reg[4] & ~reset;
assign r_next[1] = r_reg[0] & ~r_reg[1] & ~r_reg[4] & ~reset;
assign r_next[2] = r_reg[1] & ~r_reg[2] & ~r_reg[4] & ~reset;
assign r_next[3] = r_reg[2] & ~r_reg[3] & ~r_reg[4] & ~reset;
assign r_next[4] = r_reg[3] & ~r_reg[4] & ~reset;
assign feedback_value = r_reg[2] & ~r_reg[1];
assign q = r_
================================================================
example-43: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = r_reg ^ { feedback_value, r_reg[4] & ~r_reg[2] };
assign q = r_reg;
always @(posedge clk) begin
if (reset) begin
r_reg <= 5'b01100;
end
else begin
r_reg <= r_next;
end
end

================================================================
example-44: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
// define the feedback value
assign feedback_value = q[2] ^ q[4];
// define the next state of the LFSR
always@(posedge clk) begin
	if(reset)begin
	// if reset is high
	// set r_reg to 1 (initial state)
	r_reg <= 5'h1;
	end
	else begin
	// if reset is low
	// set r_reg to x (feedback_value is the next state)
	r_reg <= feedback_value;
	end
end

================================================================
example-45: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = q[2] ^ q[4];
assign r_next = {r_reg[3],r_reg[3] ^ r_reg[0], r_reg[3] ^ r_reg[1] ^ r_reg[2] ^ r_reg[4]};
always @ (posedge clk or posedge reset)
begin
	if (reset)
	begin
	r_reg <= 5'b00000;
	end
	else
	begin
	r_reg <= r_next;
	end
end
assign q = r_reg;

================================================================
example-46: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign r_next = ~(r_reg[4] ^ r_reg[2]) ? r_reg : (r_reg[2] & r_reg[4]) ? r_reg: r_next;
// define the clk and reset signals
always @(posedge clk)
begin
if (reset)
begin
r_reg <= 5'b1;
end
else
begin
r_reg <= r_next;
end
end
assign feedback_value = r_reg[4] ^ r_reg[2];
assign q = r_reg; 

================================================================
example-47: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign q = r_reg;
always @ (posedge clk or posedge reset)
begin
if (reset)
r_reg <= 5'b1;
else 
r_reg <= r_next;
end
//assign r_next = {r_reg[4],r_reg[4] ^ r_reg[2]}; //reset to original code
assign r_next = r_reg ^ {r_reg[4],r_reg[4] ^ r_reg[2]}; //reset to new code
//assign feedback_value = r_reg[4] ^ r_reg[3]; //reset to original code
assign feedback_value = r_reg[4] ^ r_reg[2]; //reset to new code

================================================================
example-48: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = {clk,r_reg[4],feedback_value};
always@(posedge clk)
begin
	if (reset)
	begin
	r_reg <= 0; // when reset is true, change r_reg to 0
	end
	else
	begin
	r_reg <= r_next; // otherwise assign r_next to r_reg
	end
end
assign q = r_reg;

================================================================
example-49: 
// Design a 5-bit maximal-length Galois LFSR with taps at bit positions 5 and 3
module lfsr( 
    input clk,
    input reset,
    output [4:0] q
); 
reg [4:0] r_reg;
wire [4:0] r_next;
wire feedback_value;
// on reset set the value of r_reg to 1
// otherwise assign r_next to r_reg
// assign the xor of bit positions 2 and 4 of r_reg to feedback_value
// assign feedback concatenated with 4 most significant bits of r_reg to r_next
// assign r_reg to the output q
assign feedback_value = r_reg[2] ^ r_reg[4];
assign r_next = (reset) ? 5'b1 : (r_reg + feedback_value);
assign q = r_reg;
always @ (posedge clk)
begin
	if (reset)
	begin
	r_reg <= 5'b1;
	end
	else
	begin
	r_reg <= r_next;
	end
end

================================================================
