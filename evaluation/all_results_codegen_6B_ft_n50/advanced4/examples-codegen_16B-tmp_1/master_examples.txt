example-0: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk)
	begin 
	case(amount) 
	2'b00: q <= data;
	2'b01: q <= q << 1; 
	2'b10: q <= q >> 1;
	2'b11: begin 
	if(ena)
	q <= q >> 1;
	end
	endcase
	if(ena)
	q <= q << 1;
end

================================================================
example-1: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) 
begin
 if (load)
 begin
	//assign q = data[63:0];
	q = {enb,data[63:1]};
 end
 else 
 begin
 	if (ena)
	 begin
	 	if(amount==2'b00)
	 	 begin
	 	// left shift by 1 bit.
	 	 	q = {1'b0, q[63:1]};
	 	 end 
	 	else if(amount==2'b01)
	 	 begin
	 	// LEFT SHIFT ENCASING 8x1 MOV USED LSB FIRST
	 	// Left shift 8 times, so shift 1
	 	 	q = {q[0], q[63:9]};
	 	 end

================================================================
example-2: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// when ena is 1
always @(posedge clk) begin
// if load is high
// begin
	if(load) begin
	// store input data in the register
	q = data;
	// for shifting left
	if (amount == 2'b00 | amount == 2'b11) begin
	// left shift stored term will become part of the output
	q = q << 1;
	// when shifting right
	if(amount == 2'b01 | amount == 2'b10) begin
	// right shift stored term will become part of the output
	q = q >> 1;
	// performs a right shift
	// when amount is neither 2'b00 nor 2'b11
	end
	end
// if load is low, retain previous value
// end
	
	
// assign data to output
// assign output to q
end
================================================================
example-3: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always@(posedge clk)
begin
	if(load)
	begin
//	if (ena)
	begin
	if(amount == 2'b00)
	begin
	q <= data << 1;
	end
	else if(amount == 2'b01)
	begin
	q <= data << 8;
	end
	else if(amount == 2'b10)
	begin
	q <= {data[55:0], data[63:56]};
	end
	else if(amount == 2'b11)
	begin
	q <= {data[63:0], data[63:64]};
	end
	end
	end


================================================================
example-4: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
begin
	if(load)
	begin
	q[63:62] <= data[63:62];
	q[61:60] <= data[61:60];
	q[59:56] <= data[59:56];
	q[55:28] <= data[55:28];
	q[27:0] <= data[27:0];
	end
	else
	begin
	if(ena)
	begin
	if(amount == 2'b00)
	begin
	q[63:62] <= q[55:28] >> 1;
	q[61:60] <= q[37:0] >> 8;
	q[59:56] <= q[55:28] >> 1;	
	q[55:28] <= q[27:0] << 8;
================================================================
example-5: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.



always @ (posedge clk) begin
	if(load == 1'b1)
	 begin
	 // ??? BELOW IS SHIFT REGISTER WITH SHIFT ENABLED
	 q[63:0] = data[63:0];
	 end
	 // ??
	 // Design the remainder of the design with shift_register.
	 if (ena == 1'b1)
	 begin
	 // In case a shift should occur
	 if (amount == 2'b01 || amount == 2'b10) 
	 begin
	 // If left-shift, shift 1 to the left, else 8 to the right.
	 q[0] <= q[63];
	 q[63:1] <= q[62:0];
	 }
	 else if (amount == 2'b11 || amount == 2'b01) 
	 begin
	 // Reverse direction
================================================================
example-6: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk) begin 
	if (~load)
	q <= data;
	else if (~ena)begin
	if(amount==2'b00) begin
	q[0] <= q[63];
	q[63:1] <= q[62:0];
	end
	if(amount==2'b01) begin
	q[0] <= 0;
	q[63:8] <= q[63:0];
	end
	if(amount==2'b10)
	begin
	q[63] <= q[0];
	q[63:1] <= q[63:0];
	end
	if(amount==2'b11) begin
	q[0] <= 1;
	q[63:8] <= q[63:0];
	end

	end
	end


================================================================
example-7: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


integer direction;

always @ (posedge clk)
begin
 if (load && ena)
 begin
	q <= data;
 end 
 else if (ena)
 begin
	 //this is the case when the bit shift is happening at the same clk cycle as when the load was issued.
	 if (amount == 2'b00 && q [63]) direction<= 1;
	 else if (amount == 2'b01 && q[63] == 0) direction <= 1;
	 else if (amount == 2'b10 && q[63] == 1) direction <= 1;
	 else if (amount == 2'b11 && q[63] == 0) direction <= -1;
	 else;

	 //direction is assigned a value if it is assigned to anything but 'else'
	 q = q + direction;
 end
 else;
end

================================================================
example-8: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 
always @ (posedge clk)
begin
if (load) begin
case (amount)
2'b00: q <= q-1'b1;
2'b01: q <= q-8'b1;
2'b10: q <= q+1'b1;
2'b11: q <= q+8'b1;
endcase
q <= data;
end
if (ena)
q <= q>>amount;
else begin
case (amount)
2'b00: q <= q;
2'b01: q <= q;
2'b10: q <= q+1'b1;
2'b11: q <= q+1'b1;
endcase
end
end

================================================================
example-9: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if(load)
	begin
	q[63:1] <= data[63:1]; // TODO: verify memories work.
	// Sequential assignment of the 2nd 8-bits only.
	q[63:56] <= q[55:48];
	q[63:56] <= q[47:40];
	q[63:56] <= q[39:32];
	q[63:56] <= q[31:24];
	q[63:56] <= q[23:16];
	q[63:56] <= q[15:8];
	q[63:56] <= q[7:0];
	q[63:48] <= q[47:32];
	q[63:48] <= q[31:16];
	q[63:
================================================================
example-10: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk)
begin



q <= 
( load ) ?
( data ) :
( amount == 2'b00 ) ?
{q[62:0], 1'b0} :
( amount == 2'b10 ) ?
{q[62:0], 8'h00} :
( amount == 2'b01 ) ? 
{32'h00000000, q[63:1]} : 
( amount == 2'b11 ) ? 
{32'h00000000, q[63:8]} : 
( data );

end





================================================================
example-11: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk) begin 
	
	if(load) begin 
	q <= data;
	end else if(ena) begin 
	
	case(amount)
	2'b11: q <= q >> (2*amount);
	2'b10: q <= ((q[0] & 64'h7fffffffffffffff) << 1);
	2'b01: q <= ((q[0] & 64'h7fffffffffffffff) >> (8 - 3 * amount));
	2'b00: q <= q << amount;
	endcase 
	end 
	end

================================================================
example-12: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 initial q = 64'b0;

 always @ (posedge clk) 
 begin
 if(load && ena) begin q = data; end
 else if(ena) begin
 case (amount) 
 2'b00: q = { q[62:0], q[63] }; // Left Shift
 2'b01: q = { q[55:0], q[63:56] }; // Left Shift
 2'b10: q = { q[63:0], q[63:64] }; // Right Shift
 2'b11: q = { q[63:0], q[63:64] }; // Right Shift
 endcase
 end
 end

================================================================
example-13: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk)
 begin
	 if (load)
	 begin
	 //$display( "%t: advanced shift with ena ",$time," SHIFT: ",data);
	 q[63:0] = data[63:0];
	 end
	 if (ena)
	 begin
	 if (amount == 2'b00) //SHIFT 1 bit LEFT
	 begin
	 q[0] = q[1];
	 q[63:1] = q[62:0];
	 end
	 else if (amount == 2'b01) //SHIFT 8 bits LEFT
	 begin
	 q[0] = q[8];
	 q[63:1] = q[57:0];
	 end
	 //$display( "%t: advanced shift with ena ",$time," SHIFT: ",q);
	 end
end
================================================================
example-14: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	
	if(load)
	begin
	// [63:0] is the input for the shift register
	// [63:0] is the shift output
	q <= data;
	
	end


	else if(ena)
	begin
	
	// amount determines how much the shift 
	// will change the 64-bit value
	case(amount) 
	2'b00: q <= q;
	2'b01: q <= {q[18:0], q[63:19]};
	2'b10: q <= {q[28:0], q[63:29]};
	2'b11: q <= {q[36:0], q[63:37]};
	default:
	q <= q;
	endcase
	end
	

================================================================
example-15: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk)
	begin
	
	if (ena)
	begin
	if(load)
	
	//	begin
	
	q={data[63:0],1'b0};
	end
	
	else 
	//	begin
	
	if (amount[1])
	q={q[63:1],q[0]};
	
	else if (amount[0])
	q={q[62:0],1'b0};
	end
	
	else
	begin
	
	q=q;
	
	end
	
	end
// always block to assign the contents of the forwarding register to the output
	always@(*)
	begin
	if(load)	
	q=data;
	else
	q=q;
	end



================================================================
example-16: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if (load == 1) begin
	q <= data;
	end
	else begin
	if(ena == 1) begin
	// shift left/right by 1 bit
	if(amount == 2'b00 || amount == 2'b02) 
	begin
	//Do shift left
	q[63] <= q[62];
	q[63:62] <= q[63:62] - 1;
	q[61:0] <= q[61:0] + 1;
	end // End if
	
	// shift left/right by 8 bits
	else if (amount == 2'b01 || amount == 2'b10)
	begin
	// Do shift right
	q[63:62] <= q[31:0];
	q[63:31] <= q[
================================================================
example-17: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @ (posedge clk)
begin
 if (load) 
begin
 // perform assignment only when load is high.
 q[63:0] <= data[63:0]; 
 end
 if (ena) 
 begin // if ena is high, perform shift.
	 case (amount)
	 2'b00: // amount is 0
	 begin
	 q <= q << 1; 
	 end
	 2'b01: // amount is 1
	 begin 
	 q <= q << 8;
	 end
	 2'b10: // amount is 2
	 begin
	 q <= q >> 1;
	 end
	 2'b11: // amount is 3
	 begin
	 q <= q >> 8; 
	 end
	 endcase 
	 end


================================================================
example-18: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk) begin	
	
	if(load)
	// Shift register is loaded using the value in the load line.
	begin
	q <= data;
	end
	
	else if(ena)
	// Shift is enabled.
	begin
	// Shifter is used, based on the values of amount.
	if(amount==2'b00)
	begin
	q[0] <= q[0];
	q[63:1] <= q[63:1];
	end
	
	else if (amount==2'b01)
	begin
	// Shift left by 1 bit.
	q[0] <= q[0];
	q[63:1] <= q[63:1];
	end
	
	else if (amount==2'b10)
	// Shift right by 1 bit.
================================================================
example-19: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk)
	begin
	if(load)
	 	q <= data;
	if(ena && amount==2'b00 && q > 0 ) // left shift by 1 bit if overflow
	 	q<= q << 1; // left shift
	else if(ena && amount==2'b10 && q > 0 )// right shift by 1 bit if overflow
	 	q<= q >> 1; // right shift
	else if(ena && amount==2'b01 && q[61:61]>0) // left shift by 8 bits if overflow
	 	q<= q << 8; // left shift
	else if(ena && amount==2'b11 && q[63:63] > 0) // right shift by 8 bits if overflow
	 	q<= q >> 8; // right shift
	else
	
================================================================
example-20: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) // Triggers on positive edge of clock
begin
	if(load || ena)
	begin
	q<=data;
	end 
	else /* if ena == 0 */
	begin
	case(amount) // Determine shift direction and amount.
	2'b00: /*shift left*/
	begin
	q <= {q[56:0],1'b0};
	end
	2'b01: /*shift left*/
	begin
	q <= {q[56:0],8'b0};
	end
	2'b10:	 /*shift right*/
	begin
	q <= {1'b0,q[63:1]};
	end
	2'b11: /*shift right*/
	begin
	q <= {8'b0,q[63:8
================================================================
example-21: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk) 
begin
	if (load) 
	begin
	// if the load is '1' then load the input into the reg. 
// assign the input to the debounced output register for synchronous output 
	q=data;
	end 
	else
//default values of all the control signals
	begin
	
	if (clk==1'b1) 
	begin
	if (ena) 
	begin
// if the 'enable' signal is high, begin doing the arithmetic shift 
	case(amount) 
	2'b00:	begin // left shift
	// do the operation on data and assign it to the q
	q= q << 1;
	end
	2'b01: begin // left shift
	q = q << 8;
	end
	2'b10:
================================================================
example-22: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 register [63:0] shift0;
 
 
 // Determine shifts.
 assign lsftA = (amount == 2'b00) ? shift1 :
 // If shift left by 1 bit.
 ((amount == 2'b01) ? shift8 :
 // If shift left by 8 bits.
 ( (amount == 2'b10) ? shift1: 
 // If shift right by 1 bit.
 ((amount == 2'b11) ? shift8 : 0));
 // Determine shift amount.
 assign shift0 = (lsftA == 1) ? data: 0;
 assign shift1 = (lsftA == 2) ? data: 0;
 assign shift8 = (lsftA == 3) ? data: 0;
 
 // Determine shift direction. 
 assign l2r = (~(amount[1])) & (amount[0]);
 // Current shift direction.
================================================================
example-23: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk) begin

if(ena) 
q=data;
 
else if(load)
	q=data;
end

================================================================
example-24: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load)
	begin
	q <= data;
	end
	else if(ena)
	begin
	case(amount)
	2'b00:
	begin
	q <= q << 1; // shift Left
	end
	2'b01:
	begin
	q <= q << 8; // shift Left 8 bits 
	end
	2'b10:
	begin
	q <= q >> 1; // shift Right
	end
	2'b11:
	begin
	q <= q >> 8; // Shift 8 bits Right
	end
	endcase
	end
end


// Dealing with Overflow.
// q[62] is q[63], except it changes value at the same time as the last bit changes.
// - q[63] gets precedence. q
================================================================
example-25: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk) begin
	begin
	if (load == 1 && ena == 1)
	q <= data; //when load is high, prevent q from the data from being loaded
	else if (ena == 1)
		/* below if conditions prevent any extra bits from showing up if not necessary */
	case (amount)
	2'b00: q <= q << 1;
	2'b01: q <= q << 8;
	2'b10: q <= q >> 1;
	2'b11: q <= q >> 8;
	endcase
	end
end //enclosing of always

================================================================
example-26: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @ (posedge clk) begin
 if (load) begin
 q[63:0] <= data[63:0];
 end
 else begin
 if (ena) begin // When enabled, shift.
 if (amount == 2'b00) begin
 q <= q << 1; // shift left by 1 bit.
 end 
 else if (amount == 2'b01) begin
 q <= q << 8; // shift left by 8 bit. 
 end
 else if (amount == 2'b10) begin
 q <= q >> 1; // shift right by 1 bit. 
 end 
 else begin
 q <= q >> 8; // shift right by 8 bit. 
 end 
 end
 end
 end

================================================================
example-27: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk) begin
	if(load) q <= data; // if the user wants to load the data
	else begin
	if(ena) q <= q << amount; // if ena is high, perform the shift.
	else q <= q; // otherwise, keep the value of q the same.
	end
	end

================================================================
example-28: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 reg [63:0] q1,q2;
 always @ (posedge clk)
 if (ena) 
begin 
	if (amount == 2'b00) 
	 q <= q1; 
	else if (amount == 2'b01) 
	 q <= q2; 
	else if (amount == 2'b10) 
	 q <= {q[56:0],q[63]}; 
	else if (amount == 2'b11) 
	 q <= {q[0 : 56],q[63:1]}; 
	else q <= 'bx;
end else begin 
	q <= 'd0; 
end 
always @(load) 
	q <= data;
always @(posedge clk)
begin
 q1 <= q << 2;
// q1 <= q;
 q
================================================================
example-29: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @(posedge clk) // performs action on rising edge of ena
	begin
	if(ena)
	case(amount)
	2'b00: q <= {{62{q[61]}},q[61:1]};
	2'b01: q <= {q[62:0],q[61:0]};
 	2'b10: q <= {{31{q[63]}} ,q [63:1]};
	2'b11: q <= {{56{q[56]}},q[56:1]};
	endcase
	end

================================================================
example-30: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


//Behavioral Logic:representational Logic: Seven-segment Display Representation of shifter
always @(*)
begin
case(amount)
2'b11: 
begin
case(ena)
1'b0:q=64'b0; //disable
1'b1:q={data[62:0], 1'b0};//right shift by 1
endcase
end

2'b10:
begin
case(ena)
1'b0:q=64'b0; //disable
1'b1:q={data[63:1], 1'b0}; //right shift by 8
endcase
end

endcase
end


================================================================
example-31: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk) begin
	
	if(load) begin
	
	q <= data;
	
	end
	
	else if(ena) begin
	
	if(amount == 2'b00) begin

	// left 
	// shift to the left by 1 bit
	// =( q << 1 )
	
	q[0] <= q[63];
	q[63:1] <= q[62:0];
	
	end
	
	if(amount == 2'b01) 
	
	begin
	
	// left 
	// shift to the left by 8
	// =( q<< 8 )
	
	q[0] <= q[63];
	q[63:1] <= q[62:0];
	
	end
	
	if( amount == 2'
================================================================
example-32: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// conditional statement
// The (load) AND (ena) is the left shift direction.
// The (amount) AND (load) makes sure that q isn't shifted before the input data is loaded.
always @(posedge clk) begin
case( (load & ena) | amount[1] )
//case statement for which direction
// direction AND amount
2'b00: q <= q - 1'b1;
//left shift
2'b01: q <= {1'b0, q[59:7]};
//(h01) right shift
2'b10: q <= q + 1'b1;
//(10) left shift
2'b11:	q <= {q[0], q[63:1]};
//(h11) right shift
endcase
end 

================================================================
example-33: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always @ (posedge clk )
 begin
	if(load) 
	 q<=data;
	else 
	 begin
	 if(ena) 
	 begin
	 case(amount)
	 2'b00: q= q << 1;
	 2'b01: q= q << 8;
	 2'b10: q= q >> 1;
	 2'b11: q= q >> 8;
	 default: q = 64'hxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
	 endcase
	 end
	 else
	 q = 64'hxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
	 end
	end

================================================================
example-34: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always@(posedge clk)
	
	begin

	if (load)	
	begin
	
	q <= data;
	
	end	

	if (ena)
	begin
	
	if (amount == 2'b00)
	begin // left by 1 bit
	
	q <= q << 1;
	
	end // left 1 bit
	
	else if (amount == 2'b01)
	begin // left by 8 bit
	
	q <= q << 8;
	
	end // left by 8 bits
	
	else if (amount == 2'b10) // right by 1 bit
	begin 
	
	q <= q >> 1;
	
	end // right by 1 bit
	
	else // right by 8 bit
	begin
	
	q <= q >> 8;
	
	end
================================================================
example-35: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


reg q0,q1,q2,q3,q4,q5,q6,q7,q8,q9,q10,q11,q12,q13,q14,q15;

always @(posedge clk) begin
	// number of shifts (right shifts only count if done via 8 bit amount)
	
	q0 <= q0;
	q1 <= ena&q0 ? (q0 >>> amount = q1):q1;
	q2 <= q1 & ena;
	q3 <= temp& q2 ? (q2 >>> amount =q3):q3;
	q4 <= q3 & ena;
	
	q5 <= endshift & q4 ?(q4 >>> amount =q5):q5;
	q6 <= q5 & ena;
	q7 <= temp& q
================================================================
example-36: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if (load == 1)
	begin
	//	q <= data;
	end
	else if (ena == 1)
	begin
dwa:	begin
	if (amount == 2'b00)
	begin
	q[0] <= 1'b0;
	q[63:1] <= q[62:0];
	end
	else if (amount == 2'b01)
	begin
	q[0] <= 1'b0;
	q[63:8] <= q[62:0];
	end
	else if (amount == 2'b10)
	begin
	q[63:1] <= q[62:0];
	q[0] <= 1'b0;
	end
	else if (amount == 2b11)
	begin

================================================================
example-37: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin: AdvShifter
//	if (load == 1'b1) //Assigns data[63:0] to the register q.
//	begin
//	q <= data;
//	end

	if(ena) //Begins shift operation only if ena is high.
	begin
	if(amount == 2'b11 )
//	begin
	q[63:8] <= q[55:0];
	q[7:0] <= q[63:56];
	q[55:8] <= q[23:0];
	q[23:0] <= q[55:24];
	q[55:24] <= q[31:0];
	q[31:0] <= q[47:24];
	q[47:24] <= q[7:0];

================================================================
example-38: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if ( load == 1'b1 || ena == 1'b1)
	begin
	
	end
	else if ( (amount == 2'b11 || amount == 2'b01) && ena == 1'b0)
	// if shift direction is right and it's not enabled
	// prevent it because it's unpredictable.
	begin
	
	end
end

================================================================
example-39: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 	always @(posedge clk)
 	begin
 	//MOta
 	if(ena)
 	begin
 	
 	if(amount==2'b00|amount==2'b11)
 	begin
 	q=data;
 	//q={{56{1'b0}}, data};
 	end
 	else
 	begin
 	if(amount==2'b01)
 	begin
 	//<= {1'b0, data[55:1]};
 	//q <= {q[62:0], 1'b0};
 	q = {q[56:0],data[55:0]}; 
 	end
 	else
 	begin
 	if(amount==2'b10)
 	begin
 	//<=
================================================================
example-40: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin
	if(ena)
	begin
	if(load)
	q <= data;
	else
	begin
	if(amount == 2'b00)
	q <= q << 1'b1; 	// if 2'b00, shift left 1 bit.
	else if(amount == 2'b01)
	q <= q << 8'b1;	// Shift left by 8.

	else if(amount == 2'b10)
	q <= q >> 1'b1;	// if 2'b10, shift right 1 bit
	else if(amount == 2'b11)
	q <= q >> 8'b1;	// Shift right by 8.

	end
	end
	end


================================================================
example-41: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @(posedge clk)
begin
	if(load==1)
	begin
	q=data[63:0];
	end
	
	else
	begin
	
	if(ena==1)
	begin
	if(amount == 2'b00)
	begin
	q=q << 1;
	end
	
	if (amount == 2'b01)
	begin
	q=q << 8;
	end
	
	if(amount == 2'b10)
	begin
	q=q >> 1;
	end
	
	if(amount == 2'b11)
	begin
	q=q >> 8;
	end
	
	end
	end
	

================================================================
example-42: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always@(posedge clk) begin //Depending on the options this performs a shift.
	if(load) begin
	q <= data; end
	else if(ena) begin
	if(amount == 2'b00)
	q <= q << 1;
	else if(amount == 2'b01)
	q <= q << 8;
	else if(amount == 2'b10)
	q <= q >> 1;
	else if(amount == 2'b11)
	q <= q >> 8;
	end
	end 



================================================================
example-43: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

 always@(posedge clk)
//if load is high (positive edge):
//	assign q = data[63:0];	
//else 
if(ena)	
//if ena is high when load is low (negative edge):	
//	shift the register value if key is pressed.
	begin
	if(amount == 2'b00)
	begin
	q <= q << 1;
	end
	else if(amount == 2'b01)
	begin
	q <= q << 8;
	end
	
	else //if(amount == 2'b10)
	begin
	q <= q >> 1;
	end
	
	else
	begin
	q <= q >> 8;
	end
	end

================================================================
example-44: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @ (posedge clk) begin
	begin
	if (load)
	q <= data;
	if (ena) begin
	case(amount)
	2'd0: q <= q << 1;
	2'd1: q <= q << 8;
	2'd2: q <= q >> 1;
	2'd3: q <= q >> 8;
	endcase 
	end
	end
	end

================================================================
example-45: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk) begin
	// if load is high, assign to shift reg
	if(load) q <= data;
	// if ena is high, perform pad
	if(ena) begin
	shiftcase(amount)
	//2'b00: left-shift by 1 bit;
	//2'b01: left-shift by 8 bits;
	//2'b10: right-shift by 1 bit;
	//2'b11: right-shift by 8 bits.
	endcase
	end // ena


================================================================
example-46: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	always @(posedge clk)
	begin
	if(load)
	 q = data;
	 else if(ena)
	 begin
	 	case(amount)
	 2'b00:
	 begin
	 	case(q[0])
	 1'b0:
	 q = q + 1'b1;
	 else
	 q = q;
	 endcase
	 2'b01:
	 begin
	 	case(q[0])
	 1'b0:
	 q = q + 8'b0000_0001;
	 else
	 q = q;
	 endcase
	 2'b10:
	 begin
	 	case(q[63])
	 1'b0:
	 q = q - 1'b1;
	 else
	 q = q;
	 endcase
	 2
================================================================
example-47: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if(load) array[63:0] = data;
	else begin 
	if(ena)
	 q[63:0] = array[63:0];
	if (amount == 2'b00) q[63:1] = q[62:0]; 
	else if (amount == 2'b01) q[63:8] = q[62:0];
	else if (amount == 2'b10) q[62:1] = q[61:0];
	else if (amount == 2'b11) q[62:8] = q[61:0];
	end
	
	
end



================================================================
example-48: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


always @ (posedge clk)
begin
	if (load)
	begin
	// whenever load is high, q gets the data.
	q[63:0] = data[63:0];
	end
	else if (ena)
	begin
	q <= q[63:amount];	// shift according to amount.
	end
	else 
	begin
	q <= q;
	end
end


================================================================
example-49: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

	reg [63:0] tempp, tempn;
	// define async. low-high term of shift value

always @(posedge clk)
	begin
	if(load)
	q <= tempp;
	else if(ena)
	begin
	 // always use conditional terms.
	 if (amount == 2'b00)
	begin
	 // shift left by 1 bit
	 tempp <= q[63:1] ;
	 tempn <= q[63:1] ;
	 end
	 else if (amount == 2'b01)
	begin
	 // shift left by 8 bits
	 tempp <= q[63:8] ;
	 tempn <= q[63:8] ;
	 end
	 else if (amount < 2)
	begin
	 // when > 2, i.e. when amount < 2
	tempp
================================================================
