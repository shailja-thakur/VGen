example-0: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state & in;
// The state against out
always @(posedge clk or negedge reset) 
if (reset==0)	begin 
	present_state <=	1'b1;	//initial state is 1
	end
else 
	present_state <= next_state;
//set next state for fsm
assign next_state = present_state & (~in); 

================================================================
example-1: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
	if (reset)
	begin 
	next_state = 0;
	present_state = 0;
	end 
	else 
	//present state logic
	present_state <= next_state;
//next state logic
always @ (posedge clk or posedge reset)
	if (reset)
	begin
	next_state = 0;
	end 
	else 
	//next state
	next_state <= present_state;
//output logic
always @ (posedge clk or posedge reset)
	// if in state 0 and out = 0, then out = 1
	if (reset)
	begin 
	out = 5'b00000;
	end 
	else 
	//if not reset, then a transition must have occured
	begin
	//
================================================================
example-2: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state==next_state)&&(in);
// The transition of the Moore State machine from state to state is if state changing on a clk edge, where a clock edges in=1 and out=0.
always @(posedge clk or posedge reset)
	begin
	// reset state machine
	if (reset)
	present_state <= next_state;
	else
	present_state <= {present_state[0],in};
	end
//the next state is equal to the present state with the exception of next_state=0, which means reset and out=1.
always @(present_state)
	begin
	next_state = present_state;
	//next_state[0]=0;
	if (present_state[0]==1'b0 && in==1'b1)
	next_state[
================================================================
example-3: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state & in;
//we want to display next state, so we declare a data type for it
always @(posedge clk or posedge reset)
	if (reset)
	over;
	assign next_state = present_state & (~ in);
	always @(*)
	case(present_state)
	0:if(in)
	next_state = 0;
	else next_state = 1;
	1:if(in)
	next_state = 0;
	else	next_state = 1;
	endcase
initial
	begin
	 present_state = 0;
	end

================================================================
example-4: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) 
	if(reset)	 
present_state <= `A;
else 
	present_state <= next_state;
wire out;
always @( posedge clk ) 
	if( present_state == `A && ( ~in ) ) 
	next_state <= `A; 
	else if( ( ~in ) && (instruction[7] == 1'b1 ) )
	
	next_state <= `C;
	else if( ( ~in) && ( instruction[7] == 1'b0 ) )
	
	next_state <= `B;
	else if ( in && ( ( instruction[7] == 1'b0 ) || ( ( instruction[6:5] == 2'b0 ) && ( !instruction[4] ) ) )
	next_state <= `A;
================================================================
example-5: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state ? (in ? 1 : 0) : (in ? 0 : 1);
// Register output during this flipflop is synthesized
// Intermediate values are optional and only used for timing
always @(posedge clk or posedge reset)

	if(reset)
	begin
	present_state <= 0;
	// Set the next state to be the same as the present state.
	next_state <= present_state;
	end
	else
	begin
	// Update the state of the flipflop.
	present_state <= next_state;
	end

// Output result of state and present_state, which is uses to generate
// the next_state based on the present_state.


================================================================
example-6: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// New input and curr_state feed each other on clock edge
// ------------------------------------------------------------------------

//ounce out if transitioning to new state
assign out = (present_state == next_state);

always @ (posedge clk or posedge reset) begin
	if (reset) 
	begin
	end 
	else begin
	//apply your design here
	 present_state <= next_state;
	end
end

always @ (posedge clk) begin
	if (present_state == `S0 & in == 1) 
	begin
	next_state = `S1;
	//set next state
	end 
	else if (present_state == `S1 & in == 1)
	begin
	next_state = `S0;
	//set next state
	end 
//set next state
always @ (posedge cl
================================================================
example-7: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state ? 1 : next_state;

always @(posedge clk) 
begin
	if(reset==1'b0)
	begin
	next_state = 0;
	present_state = 0;
	end 
	else 
	begin
	//next_state = present_state;
	next_state = {next_state[0], in};
	present_state = next_state;
	end
end


================================================================
example-8: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always@(posedge clk, posedge reset)
	if (reset) 
	begin
	present_state <= 0;
	next_state <= 1;
	end
	else 
	begin
	// You can also instantiate a combinational always block (created by)
	// to do the same thing.
	// Combinational always block for state 0
	if (in && !present_state)
	begin
	next_state <= 0;
	// Combinational always block for state 1
	end 
	else if (!in && present_state)
	begin
	next_state <= 1;
	end 
// This always block is a sequential always block which drives the 
// output on out.
always@(posedge clk)
	if (present_state)
	begin
	out <= next_state;
	end

================================================================
example-9: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk)
	if (reset)
	present_state <= 0;
	else 
	present_state <= next_state;

always @(in or present_state)
	case(present_state)
	0: 
	begin 
	if (in) 
	begin 
 	next_state <= 0; 
	out <= 0; 
	end 
	else 
	begin 
	next_state <= 1; 
	out <= 0;
	end 
	end 
	1: 
	begin 
	if (in) 
	begin 
 	next_state <= 1; 
	out <= 1; 
	end 
	else 
	begin 
	next_state <= 0; 
	out <= 1;
	end 
	end 

================================================================
example-10: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state? 0:next_state ? 1 : in;
 
// The next state is a bit more complex. In state 0, if in=1 force next state to 0. If in=1 force next state to 1.
// If in=1 and next_state=0, and out=1 force next state to 0. If in=1 and next_state=1, and out=1, then set next state
// to 0.
// State transitions are not allowed without an input. In the simple example we can toggle next_state without
// a clock.
code = <=0; //equals <= when iterating through its pipeline; <=0 = when LHS expression; <=1 = when RHS expression; 0 = Systemtol 1st time we enter the <=0; 1 = Systemtol 1st time we enter the <=1
initial
	begin
	next_state
================================================================
example-11: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// responsibility of next state
parameter 
S0=0, S1=1;
//state reg declarations
/*
reg [1:0] present_state,next_state;
//present state logic
always @(posedge clk or posedge reset)
	if(reset)
	 	//if(1)
	 	present_state<= S0;
	else
	 	present_state<= next_state;
	//next state logic
	always @(present_state or in)
	 	case(present_state)
	 	2'b00:
	 	 	if(in)
	 	 	 	next_state = S0;
	 	 	else
	 	 	 	next_state = S1;
	 	 	2'b01:
	 
================================================================
example-12: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// d-flip-flops (DFFs) implement the state logic in the always forms shown below
always @(posedge clk)
if(reset | present_state=='d0 & in) begin
	present_state <= 'd0;
	end 
else begin
	present_state <= next_state;
	end

assign next_state = present_state'b0;
assign out = present_state'b1;

================================================================
example-13: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state[1] & ~in & ~reset;

// Red always block - compue state to next state
always @(posedge clk or posedge reset) begin
if(reset) 
present_state <= "0";
else 
present_state <= next_state;
end

// Green always block - next state from other 7segment lights
always @(present_state) begin
case(present_state)
"0": if(in) next_state = "1";
	else next_state = "0";

"1": if(in) next_state = "0";
	else next_state = "1";
endcase
end

================================================================
example-14: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state & in;
// The next state is an xor of the present state and the input.
// When the xor is 0, we transition to state 0. When it is 1, 
// we transition to state 1.
always @ (posedge clk or posedge reset)
begin
	if (reset)
	begin
	next_state <= 0;
	// Initialize to state 0
	end 
	else
	begin
	// Set the next state equal to the input
	next_state <= in;
	// If the input is a 1, then transition to state 1
	if (in) 
begin
next_state <= 1;
end
end
// Always output a 1 in state 1
// The output depends on the present state.
always @ (posedge clk or posedge reset)
begin
	if (reset)
================================================================
example-15: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// When out=1 in state 0, it means the the system output 1
always @(posedge clk, posedge reset)
	if(reset)
	{
	 present_state <= 1'b0;
	 next_state <= 1'b0;
	end
	else
	 //case(present_state)
	 //1'b0:
	 //begin
	 //next_state = 1'b1;
	 //end 
	 //1'b1:
	 //begin
	next_state <= present_state;
	//case(next_state)
	//1'b1:
	//begin
	//out = 1'b1;
	//end
	//1'b0:
	//begin
	//out = 1'b0;
	//end
	//endcase
	case({present_state,
================================================================
example-16: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

always @(posedge clk)
	present_state <= next_state;
	
assign out = (present_state == `s1 && in) ? 1 : (present_state == `s0 && in) ? 0 : out;

always @(posedge clk)
	if (reset)
	// You'll want some way of storing an error state and recovering from it (if IO negedge comes back.)
	begin
	next_state <= `s0;
	end 
	else
	begin
	next_state <= `s0; // OUTPUT RESULT
	end 

================================================================
example-17: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// if both branches are taken, go to state 1.
always @(posedge clk or posedge reset)
	begin
	if (reset)
	present_state <= 0;
	else
	present_state <= next_state;
	end

assign next_state = in ? 0 : 1;

assign out = (present_state == 1'b1 & in == 1'b1) ? 1'b1 : 1'b0;
// Muxing means if X=present_state and Y=next_state, then Z=out

================================================================
example-18: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state & in; // Why state 0 and state 1 are out=0 and out=1?
always @(posedge clk, posedge reset)
begin
	if(reset) 
	 begin
	nextState<=`s0;
	 LO<=`b0000_0000;
	 HI<=`b0000_0000;
	end 
	else 
	 begin
	 nextState<=`s0;
	 HI<=LO;
	 LO<=HI;
	end
end 
always @(present_state, in, nextState)
begin
	case(nextState)
`s0: begin //Push button case 
	if(in==1)
	begin
	nextState<=`s0;
	LO<=`b0000_0000;
	 HI<=`b0000_0000;
================================================================
example-19: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state & in;
always @(posedge clk)
begin
if(reset)
present_state <= 0;
else 
case(present_state)
0:in <= 0;
1:if(in)
present_state <= 1;
else
present_state <= 0;
endcase
end
//state transitions
always @(present_state or in)
case(present_state)
0:if(~in)
next_state <= 0;
1:if(~in)
next_state <= 1;
default:next_state <= 1;
endcase
assign out = present_state & in;
always @(posedge clk)
case(present_state)
0:if(in)
begin
out <= 1;
present_state <= 1;
end
1:if(in)
begin
================================================================
example-20: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

// along with a clock

assign out= present_state AND in; // in the current state, a&b

always @(posedge clk)
begin 
if(reset) // if in state 0, then transition to state 1 if reset is TRUE
present_state <= next_state;
else
present_state <= present_state;
end 

// Next state block

always @(present_state, in)
begin
next_state = 0; // Default state
case( present_state )
0: if(~in)
	next_state = 1;
	else
	next_state = 0;
	
1: if(~in)
	next_state = 0;
	else
	next_state = 1;
endcase
end


assign out = present_state AND in; // In the output (outs) block
================================================================
example-21: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (present_state or in)
begin 
	if(reset == 1)
	 begin 
	 next_state = 0; // go to state 0
	 end 
	else if (in == 1 && present_state == 0)
	 next_state = 1; 
end
// output logic
always @ (current_state or in)
begin 
	if(reset == 1)
	 out = 0;
	else if (current_state == 0 && (in==1))// && (in==1)
	 out = 0;
	else if ((current_state == 1) && (in==0)) //&& (in==0)
	 out = 1;
end
// current state transition logic
always @ (posedge clk or posedge reset)
begin
	if (reset == 1)
	 present_state = 0;
	else

================================================================
example-22: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state == 1'b1) ^ (next_state == 1'b1);
// Compute the next state just based on the current state
always @ (*)
	if (reset)
	next_state= 1'b0;
	else
	try
	begin
	next_state= present_state;
	case (present_state)
	1'b0:
	if (in)
	next_state=1'b1;
	else
	next_state=1'b0;
	1'b1:
	if (in)
	next_state=1'b1;
	else
	next_state=1'b0;
	endcase
	end
/* For the output, it is one-shot regardless of the state, because
this is a sequential machine (RS232 module it is - analogy
================================================================
example-23: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state==next_state && (in==1));
// The following code will produce the output out=0 for input 0 and out=1 for input 1
always @(posedge clk or posedge reset)
begin	
	if (reset)	
	present_state <= 0;	
	else	
	present_state <= next_state;	
	end	
	
	

// nextstate combinational always block for state 0 and state 1
// Store it in this combinational always block
always @(present_state) 
begin
	case(present_state)
	0: if(in==1)
	next_state=1;
endcase
case(present_state)
	1: if(in==1)
	next_state=1;
	else
	next_state=0;
endcase
end
================================================================
example-24: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state == 1'b1 & ~in | present_state == 1'b0 & in;
always @(posedge clk or posedge reset)
	if (reset)
	begin
	next_state = 0;
	//Reset next state to state 0
	end
	
	else
	begin
	//Use the procedural assignment statement to set next state to state 0
	next_state = {present_state, in};
	//State 1 only happens if in (i.e. if state 1 is next state)
	case(next_state)
	2'b10: 
	begin
	if(in)
	begin
	next_state = 2'b01;
	//Why override state 1 to 1'b1 if it will still be 0???
	present_state = 1'b1;
	//Initial
================================================================
example-25: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset) begin
	if(reset)
	begin 
	present_state = 0;
	next_state = 0;
	end
	else 
	present_state = next_state;
end

always @(present_state or in) 
begin
	case(present_state)
	0: 
	begin 
	if(in) next_state = 0;
	else next_state = 1;
	end
	1: 
	begin 
	if(in) next_state = 1;
	else next_state = 0;
	end
	endcase
end

assign out = (present_state == 1);


================================================================
example-26: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// To determine next state, a combinational always block is used.
// Wires are created for assign statements to assign the correct outputs.
assign out = present_state[0]^in;
assign next_state[0] = in;
assign next_state[1] = out;
always @ (posedge clk) begin	
	if(reset) present_state = 0;
	else	present_state = next_state;
end

================================================================
example-27: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset) 
	begin
	if (reset) 
	present_state <= next_state;
	else 
	present_state <= ((in) ? 0 : 1);
	end
 
always @(posedge clk or posedge reset) 
	begin
	if (reset) 
	next_state<=0;
	else 
	begin
	case(present_state)
	2'b00: next_state<= ((in) ? 2'b01 : 2'b00);
	2'b01: next_state<= ((in) ? 2'b01 : 2'b10);
	2'b10: next_state<= ((in) ? 2'b00 : 2'b01);
	endcase
	end
	end 

assign out = present
================================================================
example-28: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state == 1) && in;
always @(posedge clk or posedge reset)
// State transitions
begin
	if(reset)
	present_state <= 0;
	else
	present_state <= next_state;
end
always @(out or in or present_state or next_state)
// State transitions
begin
	if(present_state == 0 && in == 1)
	next_state <= 1;
	else if(present_state == 1 && in == 1)
	next_state <= 0;
	else
	next_state <= present_state;
end

================================================================
example-29: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
/*
always @(posedge clk or posedge w or posedge x) 
	begin
	//if w is asserted, then nextstate = write else nextstate = read
	//if x is asserted, then nextstate = write else nextstate = rom
	if(w) 	next_state = 2'b11;
	else if(x) 	next_state = 2'b01;
	else	next_state = {pres,{nw,nw,rw}};
	end
	

assign out = (({pres, prob, nw,rw} == 5'b00100) ? 1'b1 : 
	({pres, prob, nw,rw} == 5'b10000) ? 1'b1 : 
	({pres, prob, nw,rw} == 5'b?100) ? 1'b1 : 
================================================================
example-30: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk) 
	//get's current state and next state
	case(present_state)
	0: begin 
	next_state=in;
	if(in)
	out = 0;
	else
	out=1;
	end
	1:begin 
	next_state=in;
	if(in)
	out = 1;
	else
	out=0;
	end

	//default state
	default: begin 
	next_state=1'b0;
	out=0;
	end
	endcase
//has the output changed
always @(posedge clk) 
	//get's output
//sets output according to current_state

assign out=(present_state==next_state)?1:0;

//present state
always @(posedge clk
================================================================
example-31: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = (present_state == 1'b0) && (in == 1'b0);
always @(posedge clk or reset) begin
	if(reset)
	 present_state <= 1'b0;
	else
	 present_state <= next_state;
end
always @(present_state or in) begin
	case(present_state)
	1'b0: if(in == 1'b1) next_state = 1'b1; else next_state = 1'b0;
	1'b1: if(in == 1'b1) next_state = 1'b1; else next_state = 1'b0;
	endcase
end

================================================================
example-32: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk)
	if(reset) 
	begin
 	 next_state=0 ;
	 present_state=0;
	end
	else 
	begin
 	 next_state=0 ;
	 present_state=1;
	end
always @ (posedge clk) 
	present_state = s; 
// Each state s has nextstate s' if there is a transitions in the Moore transition diagram
// Diagram : https://hdlbits.github.io/diagrams/moore-tri-state-transitions-2/index.html
always @ (s, in)
	case(s)
	0 : if(in)
	begin
	next_state=1;
	out=1;
	end
	else
	begin
	next_state=1;
	out=0;
================================================================
example-33: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state==next_state)&(in);

always @(*)
	case(present_state)
	2'b00: next_state=in? 2'b01:2'b00;
	2'b01: next_state=in? 2'b00:2'b10;
	2'b10: next_state=in? 2'b11:2'b00;
	2'b11: next_state=in? 2'b00:2'b10;
	default: next_state=2'b00;
	endcase

always @(posedge clk)
	if(reset)
	present_state<=2'b00;
	else
	present_state<=next_state;
	

================================================================
example-34: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
/*
always @(posedge clk or posedge reset)
	if(reset)
	begin
	present_state <= S0;
	next_state <= S0;
	end
	else
	present_state <= next_state;
	*/

assign next_state = present_state;

// 
assign present_state = next_state;

assign out = (present_state == S1 & in == 1) ? 0 : (present_state == S0 & in == 1) ? 1 : 0;


================================================================
example-35: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
	if(reset)
	begin 
	present_state <= 0;
	next_state <= 0;
	out <= 0;
	end
	else 
	begin
	present_state <= next_state;
	out <= next_state==2 && present_state==0;
	/*
	next_state <= 2'b01;
	if(present_state==1'b0 || out==0)
	begin 
	out=1;
	end
	else if(next_state==2'b01)
	begin 
	out=1;
	end
	else if(&next_state)
	begin 
	out=0;
	end
	
	
	if(present_state==1'b1 || out==1)
	begin 
	
================================================================
example-36: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
// out=1 in state 0 and in=1 in state 1
// out=1 in state 1 and in=1 in state 0
// out=1 if all three states are entered
always @ (posedge clk or posedge reset) 
	begin
	if (reset)
	 present_state <= 1;
	else
	 present_state <= next_state;
	end
assign next_state = present_state & in;
assign out = present_state & in;

================================================================
example-37: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(*)
	present_state <= next_state;

// Compute next state
always @(posedge clk)
	if(reset | (present_state == 2'b00 && in==1'b1))
	next_state <= 2'b00;
	else if(present_state == 2'b01 && in==1'b1)
	next_state <= 2'b01;
	else if(present_state == 2'b01 && in==1'b0)
	next_state <= 2'b10;
	else if(present_state == 2'b10 && in==1'b0)
	next_state <= 2'b10;
	else if(present_state == 2'b10 && in==1'b1)
	next_state <= 2'b01;
	
// Compute output

================================================================
example-38: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=present_state[1] ^ (present_state[0] & in);
// Register implementation
always @(posedge clk)
	if(reset)
	begin
	present_state <= `S0;
	next_state <= `S0;
	end
	else current_state <= next_state;
always @(current_state or in)
	case(current_state)
	`S0:if(in)
	begin
	next_state <= `S0;
	end
	else
	begin
	next_state <= `S1;
	end
	`S1:if(in)
	begin
	next_state <= `S1;
	end
	else
	begin
	next_state <= `S0;
	end
	endcase
// Output implementation
always @(current_state
================================================================
example-39: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
/*
always @(posedge clk or posedge reset)
	begin
	if (reset)
	present_state <= 0;
	else
	present_state == next_state;
	end
*/
assign next_state = present_state;
assign out = present_state[1];
always @(posedge clk or posedge reset)
	if (reset)
	begin
	//present_state <= 0;
	out = 0;
	end
	//else
	begin
	/*case(present_state)
	0: 
	endcase */
	next_state[1:0];
	case(present_state)
	/*0: 
	begin
	out[1]=0;
	out[0]=0;
	end
	3:
	begin
	out[1]=1;
	
================================================================
example-40: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state==0 && in)||(present_state==1 && ~in);
always @(posedge clk or posedge reset)
	if(reset)
	present_state <=0;
	else 
	present_state <= next_state;

always @(present_state or in or out)
	case(present_state)
	0: if(~in)next_state=1;
	1: if(in)next_state=0;
	endcase
	//$display("next_state: %b",next_state);
	//$display("reset: %b",reset);

================================================================
example-41: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out = present_state;
always@(posedge clk, posedge reset)
	begin
	if(reset)
	present_state<=1'b0;
	else
	present_state<=next_state;
	end
always@(in, present_state)
	case(present_state)
	1'b0: if(in)
	next_state<=1'b0;
	else
	next_state<=1'b1;
	1'b1: if(in)
	next_state<=1'b0;
	else
	next_state<=1'b1;
	endcase

================================================================
example-42: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state == 1) ^ (in);
// the clock edge detector looks at the second rising clock edge of clock
// to reset the present state. The book has an errata where it falsely
// defines unknown in that code section to be out=0 always, regardless of in,
// regardless of clock. This isn't a problem with the idea of the design,
// but it makes the the about code in Model 2 in the same book errata.
// this changes state to reset for the zero interrupt.
always @ (posedge clk) begin 
	if(reset==1)
	present_state<=0;
	else
	present_state<=next_state;
end
always @(present_state, in, out)
	case(present_state)
	2'b00: 	begin
	if(next_state == 2 && in ==
================================================================
example-43: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @ (posedge clk or posedge reset)
	parameter A=0, B=1; 
always @ (present_state, in)begin 
	case(present_state) 
	A: if(in) next_state = A; else next_state = B;
	B: if(in) next_state = A; else next_state = B;
	endcase
	end
always @ (present_state, in)begin 	
	case(present_state) 
	A: if(in) out = 1; else out = 0;
	B: if(in) out = 0; else out = 1;
	endcase
	end

================================================================
example-44: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
mux2in m1(.in0(present_state), .in1(next_state), .sel(in), .out(out));
always @(posedge clk or posedge reset) begin
	if(reset) present_state <= 0;
	else present_state <= next_state;
end

================================================================
example-45: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1

parameter state0 = 1'b0, state1 = 1'b1; 
// changing this to two states keeps the next state logic simple

assign next_state = present_state & in; // determine the next state
// logic to determine if a transition between states occurs

assign transition = (present_state == state1) & (in); // if the two states are equal, then there is a transition
always @(posedge clk or posedge reset) 
	begin
	// if the reset flag is raised, or if the transition flag is raised
	if(reset | transition) 
	begin
	// assign the next state to be either a 0 or 1
	// this is according to the truth table for mux()
	out = next_state;
	
	// set the present state to be the next state
	present_state = next_state;
================================================================
example-46: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out= present_state==0?(next_state == 0?1:0):(present_state == 1 ? 1:0);
always @(posedge clk or posedge reset) begin
	if(reset) 
	begin
	next_state = 0;
	end 
	else 
	begin
	//$display("State = %d, Input = %d", present_state, in);
	next_state = present_state;
	case(present_state)
	1'd1: if (in == 1'b0) 
	begin
	next_state = 0;
	end 
	else 
	begin
	next_state = 1;
	end
	endcase
	end
	present_state = next_state;
end

================================================================
example-47: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
/*
assign out = present_state & (in);
*/

// New way

assign out = present_state[in];

always @(posedge clk) 
begin
	if (reset) 
	begin
 	next_state[0] = 0;
	next_state[1] = 0;
	end 
	else 
	begin
	next_state[0] = (in) ^ (present_state[0]);
	next_state[1] = (in) ^ (present_state[1]);
	end
	
end
// Old way
/*
assign next_state[0] = (in) ^ (present_state[0]);
assign next_state[1] = (in) ^ (present_state[1]);
*/

// New way

always @(posedge clk
================================================================
example-48: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
assign out=(present_state==`s1) &~(in) |(present_state==`s0) & (in);
always @(posedge clk)
	if(reset)
	begin
	present_state<=`s0;
	end 
	else if(in)
	begin
	present_state<=`s1;
	end 
	else if(out)
	begin
	present_state<=`s0;
	end 
	else if(present_state != `s1)
	begin
	present_state <= next_state;
	end
	assign out=(present_state==`s1) & (in) | (present_state==`s0) & (in) ;
///////////////////////////state table
//`define STATE_ADDRESS 	3'b000
//`
================================================================
example-49: 
// Design a Moore state machine with two states 0 and 1, one input in, and one output out. Reset state is 0.
module simple_fsm(clk, reset, in, out);
input clk;
input reset;
input in;
output out;
wire out;
reg present_state, next_state;
// In state 0, if in=1, stay in state 0. In state 0, if in=0, go to state 1
// In state 1, if in=1, stay in state 1. In state 1, if in=0, go to state 0
// out=1 in state 0 and out=0 in state 1
always @(posedge clk or posedge reset)
begin
	if(reset)
	begin
	 present_state <= 1;
	end
	else 
	 begin
	 present_state <= next_state;
	end
end

always @(present_state)
// Because this is a sequential machine, the output is UX, where UX represents the next state
begin
case(present_state)
1'b0: if(in)	
	next_state = 1'b0;
	else
	next_state = 1'b1;
1'b1: if(in)	
	next_state = 1'b1;
	else
	next_state = 1'b0;
endcase
endcase
assign out = present_state;


================================================================
