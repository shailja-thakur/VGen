example-0: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// asynchronous shared memory
module smx(input clk,
input ena,
input [63:0] address,
output reg [63:0] data,
output reg [1:0] ready,
output reg [1:0] busy);
// address: 32-bit memory address.
// ready: (read or write) signal, indicating if memory location is ready.
// busy: (read or write) signal, indicating if memory location is busy.

// asynchronous shared memory
module smy(input clk,
input ena,
input [63:0] address,
output reg [63:0] data,
output reg [1:0] ready,
output reg [1:0] busy);
// address: 32-bit memory address.
// ready: (read or write) signal, indicating if memory location is ready.
// busy: (read or write)
================================================================
example-1: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// This file was automatically generated by the lut-howto utility.
#include "advshift.h"

// the generated file is in the "formatted" output format,
// which is otherwise identical to the "unformatted" output format.
#include "advshift_defs.h"

// generate the table using the lut-howto utility.
// the generated file is in the "unformatted" output format.
#include "advshift_lut.h"

// assign the above to the register, to avoid rewriting the LUT each time.
reg advshift_table advshift_table_asm [] = advshift_lut;

// the following were generated with lut-howto.
#include "advshift_defs.h"
#include "advshift_lut.h"


================================================================
example-2: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


`

================================================================
example-3: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


module main (
	input clk,
	input ena,
	output [63:0] data);
// load register is used as the control signal.
// if ena is high, load register with data.
// if ena is low, load register with shift register.


================================================================
example-4: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.



// Let's have a test case.
// 1'b000 = 0
// 1'b001 = 1
// 1'b010 = 2
// 1'b011 = 3
// 1'b100 = 4
// 1'b101 = 5
// 1'b110 = 6
// 1'b111 = 7
// So let's test the shift with different amounts.

module test_advshift(input clk,
input load,
input ena,
input [7:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01:
================================================================
example-5: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


// opcodes
// 00: LASR(x) = x
// 01: LASR(x) = x + 1
// 10: LASR(x) = x + 8
// 11: LASR(x) = x + 9
//
// LASR(x): 0-63

// opcodes bits
// x: data to shift/add
// x + 1: shifted data
// x + 8: shifted data + 8
// x + 9: shifted data + 9

// S2 = 001 = 0x03
// S2 = 100 = 0x0C
// S2 = 101 = 0x0D
// S2 = 110 = 0x1C
// S2 = 111 = 0x1D

// S3 = 011 = 0x0B
// S3 = 110 = 0x1A
// S3 = 111
================================================================
example-6: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


module count(output reg [63:0], input clk, input i, input ena, input [1:0] w, input [63:0] x, input [63:0] y);
module ctl(output reg [63:0], input clk, input i, input ena, input [1:0] w, input [63:0] x, input [63:0] y);
module enum(input clk, input i, input ena, input [1:0] w, input [63:0] x, input [63:0] y);


module advshift_reg(input clk,
input load,
input ena,
input amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if en
================================================================
example-7: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


module advshiftreg(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


module advshifter(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high,
================================================================
example-8: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.


module main(input [31:0] data, output reg [31:0] result);

begin
    assign data = {data[0], data[1], data[2], data[3], data[4], data[5], data[6], data[7],
                 data[8], data[9], data[10], data[11], data[12], data[13], data[14], data[15],
                 data[16], data[17], data[18], data[19], data[20], data[21], data[22], data[23],
                 data[24], data[25], data[26], data[27], data[28], data[29], data[30], data[31]};
    assign result = advshift(clk, load, ena, amount, data, reg);
end

================================================================
example-9: 
// Design a 64-bit arithmetic shift register, with synchronous load. 
// The shifter can shift both left and right, and by 1 or 8 bit positions, selected by amount.
module advshift(input clk,
input load,
input ena,
input [1:0] amount,
input [63:0] data,
output reg [63:0] q); 
// when load is high, assign data[63:0] to shift register q.
// if ena is high, shift q.
// amount: Chooses which direction and how much to shift.
// 2'b00: shift left by 1 bit.
// 2'b01: shift left by 8 bits.
// 2'b10: shift right by 1 bit.
// 2'b11: shift right by 8 bits.

   always @(posedge clk) begin
      if(ena) begin
         if(load) begin
            q <= data;
         end else begin
            if(amount == 0) {
               q <= data;
            } else if(amount == 1) {
               q <= shift_left(data, q);
            } else if(amount == 8) {
               q <= shift_right(data, q);
            }
         end
      end
   end
 

================================================================
