example-0: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

always @(posedge clk or negedge reset) begin 
  if (reset == 1 && slowena == 0) q <= [2:0] 0;
  else if (ena == 1 && q != 2$1) q <= [q_sync_range : q_sync : q_counter_half_cycle] [q + 1 : q_number_of_zero_cycles];
end

 
// ----------------------------------------------------------------------------

always @(posedge clk) begin
  if (event == 1) 
  {
    // Reset the countdown clock
    if (cena == 1)
    {
      q <= 0;     // Skip entire decade
      cena <= 0;  // Skip, then go to next decade
    } 
    else if (reset == 1 && slowena == 1) 
    {
      q <= 0;
	  // 

================================================================
example-1: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

always@(posedge clock) begin
    if (reset > 0) q <= 0;
    else begin
      if (ena > 0)
        if (q != 9) q <= q + 1;
      else q <= 0;
    end
end

always @(posedge clock or posedge reset) begin
    if (reset > 0) q <= 0;
    else begin
      if (ena > 0)
        if (q != 9) q <= q + 1;
      else q <= 0;
    end
end


================================================================
example-2: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
// In any case, only a change to stat, or to ena, can cause q to be 9.
always @(posedge clk or ~reset) begin
    if (reset) q <= 0; else
    if (ena & ~stat & ~q == 9 & ~slowena) q <= q + 1;
end

always @(posedge clk) begin
    if (slowena & ~stat & ~q == 9 & ~slowena) q <= q + 1;
end

// Decay stat when 00 is reached
reg [3:0] stat = 0;
always @(posedge clk) begin
    if (stat[0] == 0) stat[0] <= 1;
    if ((stat[0] == 1) && ~stat & (stat[1] || stat[2] || stat[3])) stat[0] <= 0; 
end
================================================================
example-3: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

reg [3:0] regq; #0;

always @ (posedge clk or (reset and (slowena))) {
    if (reset) {
        regq <= 0;
    } else if (slowena) {
        regq <= regq + 1;
        if (regq >= 9) regq <= 0;           // class C alarms
    } else; // 0
}

// If enable is low, return the output q value. Otherwise, read q,
// increment it, and return the pre-incremented value.

reg [3:0] counts; bytes count;

always @ (posedge clk or (reset and (slowena))) {
    counts <= var_i;
    if (slowena) {
        counts <= regq;
        regq < 9 ? regq += 1 : regq <= 0;

================================================================
example-4: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
// Store the q value in qs.
// Store the next q to be received in qr.
 // The tickslope is generated by
 //     128 reps of doing:
 //        wait tb, ENA, q, 10
 //        dly 210
 //        do
 //            if reset=high, reset q2 and q4 to 0
 //            if q2 not 9, increment q2
 //            wait tb, ENA, q2, 30
 //            if q4 not 9, increment q4
 //            wait tb, ENA, q4, 30
 //        done
 //
 // Which amounts to rate 128, plus two extra wait cycles.
//
//   initial TICKSLOPE/128 = (0+2)+210+2t8 = 258, where t8 = 242
//
// The counter itself consists of a pair of unsigned counters fed by the clock 
================================================================
example-5: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
//
// On the negative edge of the clock:
// if reset is high, reset the output q to 9. 
// Otherwise, only increment the output q if the ena input is high, q is not 9 and q is not 8.
//
// Note this is totally equivalent to just:
//     consumer
// 1. always support the highest value 9.
// 2. increment the q register on "any" edge

always @(posedge clk or negedge reset) begin
    if (reset) q <= 9'd0;
    else if (!(slowena && q++ == 9'd9)) q <= 9'd0;
    q <= q + 1'd1;
end


================================================================
example-6: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
always @(posedge clk) begin
    if(reset == 1) begin
        q <= 0;
    else begin
        if(ena) q <= q + 1;
    end
end

// Initialize the register, by resetting the output.
always @* begin
    reset <= 0;
    case(slowena)
        q <= 0;
        default: begin
            break; end
    end
end
`
================================================================
example-7: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
    always @ (posedge clk or ~reset) begin
        if (reset) begin
            q <= 0;
        end else begin
            if (slowena) begin
                if (q != 9) begin
                    q <= q + 1;
                    if (q == 9 and slowena) begin
                        next_state wait;
                        wait <= 1;
                        while (wait) begin
                        | | | | | | | | | | | | |             // Example representation of bit emitters. A 10 dyn signal grouped 2-per-cou.
==============            ========   ================   ====================    Points to
     S0         _______        _______________         _______________        Points to
    |_|_|_|_  |   |   |      |label |   |   |      |label |   |   |      |label |
   |   |   |  |   |  
================================================================
example-8: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
// NOTE: disallow ena to change on slower clock.
assign q = {3'b000, q'b0}
    + reset 
    | [(clk == '1') & slowena
      & (q / 10'h3 == 9'b01) & ~(enabclk/16 == 1'b0) & ~enabclk];


================================================================
example-9: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
always @(posedge clk or ~reset)
    if (reset) q <= 0; 
    else if (ena and veq(q, 9)) q <= 9;
    else q <= q + 1;

// On the positive edge of the slowena input, toggle the q output.
always @(posedge slowena)
    q <= q + 1;

// The `reset` input is a logic reset. The value doesn't matter.
always @(posedge clk or posedge reset)
    if (reset) q <= 0;
    else q <= 9;

always @(posedge clk) slowena <= 0;


================================================================
example-10: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

always @(posedge clk | negedge reset)
    if (reset)
        q <= {3'b 000};
    else if (slowena && q <= 9)
    {
        if (clk)
            q <= q + 1;
        else
            q <= q;
    }
    else
        q <= {3'b 000};

// On the positive edge of slow clock:
// if reset is high, reset the output q to 0. 
// Time-sensitive on low frequency clock. Try using the Rate Parameter on a clkout?

always @(posedge slowclk | negedge reset)
    if (reset)
        q <= {3'b 000};
    else
        q <= q;

// If don't care ENa is high, reset q to 0.

always @(posedge clk
================================================================
example-11: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
always @(posedge clk) begin
    if (reset == 0) begin
        q <= 0;
    end else begin
        if (ena && q < 9) q <= q + 1;
    end
end

// On the positive edge of the slow enable, reset the counter to 0, and
// also set ena to 1, meaning that this counter is enabled.
always @slowafel(slowena) begin
    count_slow.en_a <- 1;
    count_slow.reset_lh <= 0
end

always @(posedge clk) begin
    count_slow.ena <- 1;
end

always @* begin
    count_slow.reset_lh <= 0
end


================================================================
example-12: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

always @(posedge clk)
    if (reset == 1)
        q <= 0;
    else if (!reset && !$display("fastena") && slowena == 1 && q != 9)
        q = q + 1;

// On the positive edge of slowena (usually 400ns) the decorator
// will translate q to a string of 3 characters, meaning [0:2].

assign [3:0] d = {0, 1, 2, 3, 4};
assign [7:0] qa = {3, 2, 1, 0, 0, 0};


1:   // always
    count_slow(clk, $display("fastena"), $display("reset"), q);

================================================================
example-13: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.

always @(posedge clk or posedge reset) begin
    if (reset) q <= 0;
    else if (slowena) q <= (q + 1) % 10;
end


================================================================
example-14: 
// Design a decade counter that counts from 0 through 9, inclusive.

module count_slow(
    input clk,
    input slowena,
    input reset,
    output reg [3:0] q);

// On the positive edge of the clock:
// if reset is high, reset the output q to 0. 
// Otherwise, only increment the output q if the ena input is high and q is not 9.
always @(posedge clock) begin
    if (reset) q <= 0;
    else if (!slowena || q != 9) q <= q + 1;
end


================================================================
