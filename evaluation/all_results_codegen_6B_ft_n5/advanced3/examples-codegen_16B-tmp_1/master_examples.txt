example-0: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always@ ( present_state )
	begin
	case( present_state )
	 IDLE : begin 
	 if ( x ) begin 
	 next_state = S1;	
	 end 
	 else
	 next_state = IDLE;
	 end
	 S1 : begin
	 if ( x )
	 next_state = S10;
	 else 
	 next_state = S1; 
	 end
	 S10 : begin
	 if ( x )
	 next_state = S101;
	 else
	 next_state = IDLE;
	 end
	 S101 : begin
	 next_state = IDLE;
	 end
	 endcase
	 end
	 
	 
	//present state
	 always@ ( posedge clk ) begin
	 if(rst)
	 present_state <= IDLE;
================================================================
example-1: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( present_state, x )
case ( present_state )
	IDLE 	:	begin
	next_state = x ? S1 	:	IDLE;
	z = 1'b0; 
	end

	S1 	:	begin
	next_state = x ? S1 	:	IDLE;
	z = 1'b0; 
	end
	
	S10	:	begin
	next_state = x ? S10	:	IDLE;
	z = 1'b0; 
	end
	
	S101	:	begin
	next_state = x ? IDLE 	:	S101;
	z = 1'b1; 
	end
	
	default	:	begin
	next_state = x ? S1 	:	IDLE;
================================================================
example-2: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(*)
case(present_state)
IDLE: if(x==1) next_state=S1;	//if x is 1, next state S1
	else next_state=IDLE;
S1:	if (x==0)	next_state=S1;	//if x is 0, next state is S1
	else next_state=S10;	//if x is 1, next state is S10
S10:	if (x==1) next_state=S101;	//if x is 1, next state is J, (not S101!)
	else next_state=S10;	//if x is 0, next state is S10
S101:	if (x==1) next_state=IDLE;	//if x is 1, next state is idle
	else next_state=S1;	
================================================================
example-3: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


// State transition logic 
always @(posedge clk)begin
if(reset==1)
present_state<=IDLE;
else
present_state<=next_state;
end 

always @(present_state)begin
case(present_state)
IDLE: if(x==1)
next_state=S1;
else 
next_state=IDLE;
S1: if(x==0)
next_state=S10;
else 
next_state=IDLE;
S10: if(x==1)
next_state=S101;
else 
next_state=IDLE;
S101: 
next_state=IDLE;
default: next_state=IDLE;
endcase
end 

assign z=(present_state==S101)? 1:0;

================================================================
example-4: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@( negedge reset, posedge clk ) begin

if ( reset ) 
present_state <= IDLE; 
else 
present_state <= next_state; 
end
// always block fullfilled 10 lines earlier than the lines in the diagram

always@( negedge clk ) begin

case ( present_state ) 
IDLE : 
if ( x )
next_state = S1;
else 
next_state = IDLE;

S1 : 
if ( ~x )
next_state = S10;
else 
next_state = IDLE;

S10 : 
if ( x )
next_state = S101;
else 
next_state = IDLE;

S101 : 
next_state = IDLE;
endcase
end


================================================================
example-5: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	assign z = (present_state == 101) ? 1:0;

================================================================
example-6: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


//altera's synthesic tool will verfiy the the logic resulting output signals
assign z = (present_state == S101) ? 1:0; 
always @ ( present_state, x )
	begin
	case( present_state ) 
	IDLE : 
	begin 
	case ( x ) 
	0 : next_state = S1; 
	1 : next_state = IDLE; 
	endcase 
	end 
	S1 :
	begin 
	case ( x ) 
	0 : next_state = S10; 
	1 : next_state = IDLE; 
	endcase 
	end 
	S10 : 
	begin 
	case ( x ) 
	0 : next_state = S101; 
	1 : next_state = IDLE; 

================================================================
example-7: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(posedge clk)
	begin
	if (rset)	
	present_state <= IDLE;
	else
	present_state <= next_state;
	end
	
	always @(*)
	begin
	case (present_state)
	IDLE: 	begin
	 next_state = x ? S1 : IDLE;
	 end
	 S1: 	begin
	 next_state = x ? S10 : IDLE;
	 end
	 S10: begin
	 next_state = x ? S101 : IDLE;
	 end
	 S101: begin
	 next_state = x ? IDLE : IDLE;
	 end
	 endcase
	end

	assign z = (present_state == S101);
	

================================================================
example-8: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(posedge clk)
	begin 
	if(reset)
	present_state <= IDLE;
	else
	present_state <= next_state ;
	end 
	// IDLE is the initial/idle state
	// S1 is the state that detects a 1 in X 
	// S10 that detects a 0 in X and goes to S1
	// S101 is the state that detects 101 in X and goes to IDLE
	always @(*)
	begin 
	case (present_state)
	IDLE : begin
	if (x) next_state = S1;
	else next_state = IDLE;
	end
	S1 : begin
	if (!x) next_state = IDLE;
	else next_state = S10;
	end 
	S10 : begin
	if(x
================================================================
example-9: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(present_state,x)
case(present_state) 
IDLE: if(x)
 next_state = S1;
else
 next_state = IDLE; 

S1: if(~x)
 next_state = S10; 

S10: if(x) 
next_state = S101; 
 
S101: if(~x) 
next_state = IDLE; 

endcase 

always@(posedge clk, posedge reset)
begin 
if(reset)

present_state <= IDLE;

else 
present_state <= next_state; 
end 

assign z = (present_state == S101) ? 1: 0; 


================================================================
example-10: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE




// next state transition conditions
always @( present_state ) 
case ( present_state ) 
IDLE: begin if( x ) next_state = S1; else next_state = IDLE; end
S1: begin if( ~x ) next_state = IDLE; else next_state = S10; end
S10: begin if( x ) next_state = S101; else next_state = S1; end
S101: begin if(~x)next_state = IDLE; end
endcase

// state machine implementation
always @(posedge clk)
begin 
if ( reset )
present_state <= IDLE;
else 
present_state <= next_state;
end
// output assignment
assign z = ( present_state == S101 ? 1 : 0 );
// States memory 
// concurrent assignment 

================================================================
example-11: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or reset)
begin
if(present_state == IDLE)
begin
if(x)next_state = S1;
else next_state = IDLE;
z = 1'b0;
end

else if(present_state == S1)
begin
if(~x)next_state = S10;
else next_state = IDLE;
z = 1'b0;
end

else if(present_state == S10)
begin
if(x)begin
 next_state = S101;
 z = 1'b1;
 end
else
 begin
next_state = IDLE;
z = 1'b0;
 end
end

else if(present_state == S101)begin
if(reset)
begin
next_state = IDLE;
z = 1'b0;
================================================================
example-12: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(posedge clk )
begin
if(reset) 
present_state <= IDLE;
else
present_state <= next_state;
end
always@(present_state or x)
begin
case(present_state)
IDLE : begin 
if(x == 1) 
next_state = S1;
else 
next_state = IDLE; 
end 
S1 : begin 
if(x == 0) 
next_state = S10;
else 
next_state = IDLE; 
end 
S10 : begin 
if(x == 1) 
next_state = S101;
else 
next_state = IDLE; 
end
S101 : begin 
if((x == 1) & (present_state != rst)) 
next_state = IDLE;
else
================================================================
example-13: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @ (posedge clk )// present state registers
	begin 
	if (reset) 
	present_state <= IDLE ; 
	else 
	begin 
	present_state <= next_state ; 
	end 
	end 
	//output is asserted 1 when IDLE, S1, S10, and S101 states occur
	always @ (*)	// combinational transition blocks 
	begin 
	// default goes to IDLE 
	case (present_state) 
	IDLE : 
	begin 
	if (x) 
	next_state = S1 ; 
	else 
	next_state = IDLE ; 
	end 
	// S1 next state goes to S10 if x is 0 
	// otherwise go to IDLE.
	S1 : 
	begin 
	
================================================================
example-14: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @ (present_state or x or reset)
	begin
	case (present_state)
	 IDLE: if (reset) next_state <= IDLE;
	else if ( x) next_state <= S1;
	 S1: if ( x) next_state <= S10; 
	else next_state <= IDLE; 
	 S10: if(x) next_state <= S101; 
	else next_state <= IDLE; 
	 S101: next_state <= IDLE;
	default: present_state <= IDLE;
	endcase
	end
	always @ (x, present_state)
	begin 
	case (present_state)
	 IDLE: begin z = 0; end
	 S1: begin z = 0; end
	S10: z = 0;
	 S101: begin 
================================================================
example-15: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @ ( present_state or x or reset ) 
	begin
	 	case( present_state )
	 	 	3’b000 : begin 
	 	 	 	 	 	 	next_state = x ? 3’b001 : 3’b000 ; 
	 	 	 	 	 	 	end 
	 	 	 	3’b001 : begin 
	 	 	 	 	 	 	 next_state = x ? 3’b010 : 3’b000 ; 
	 	 	 	 	 	 	end 
	 	 	 	3’b010 : begin 
	 	 	 	 	 	 	next_state = x ? 3’b010 : 3’b
================================================================
example-16: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(present_state,x)
	begin 
	 case (present_state)
	 IDLE : begin 
	 if (x == 1) 
	 next_state = S1; 
	 else 
	 next_state = IDLE; 
	 end 

S1 : begin 
if (x == 0)
next_state = IDLE;
else
next_state = S10;
end 
S10 : begin
if (x == 1)
next_state = S101;
else 
next_state = IDLE;	
end	
S101 : begin 
next_state = IDLE; 
end 
	endcase
 end
// always block performs the case statement whenever the signal x changes

always @(posedge clk)

 if (reset)
 present_state <= IDLE; 
	else
================================================================
example-17: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk)
 if(reset)
 present_state = IDLE;
 else
 present_state = next_state;

// assigned outputs
assign z = (present_state == IDLE);

always @(*)
 case(present_state)
 IDLE: 
 if(x)
 next_state = S1;
 else
 next_state = IDLE;
 S1:
 if(~x)
 next_state = S10;
 else
 next_state = IDLE;
 S10:
 if(x)
 next_state = S101;
 else
 next_state = IDLE;
 S101: 
 next_state = IDLE;
 default:
 next_state = IDLE;
 endcase 

================================================================
example-18: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(posedge clk or posedge reset ) // always block with sensitivity list
begin
	if(reset)
	begin
	// resetting present_state whenever reset is asserted
	present_state <= IDLE;
	end
	else
	begin
	// transtion of present state only if clock or reset is not asserted
	present_state <=next_state;
	end
end

always@(present_state or x)
begin
	case(present_state)
	IDLE : begin
	if(x == 1) next_state = S1;
	else next_state = IDLE;
	end
	S1 : begin
	if(x== 0) next_state = S10;
	else next_state = IDLE;
	end
	S10 : begin
	if(x == 1) next_state =
================================================================
example-19: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk or posedge reset)
begin
if(reset) begin 
	present_state = IDLE;
end
else begin
	present_state = next_state;
end
end

always @(x or present_state)
begin 
case (present_state)
IDLE: 
	begin
	if(x) begin 
	next_state = S1;
	end
	else next_state = IDLE;
	end
S1:
	begin
	if(!x) begin 
	next_state = S10;
	end
	else next_state = S1;
	end
S10: 
	begin
	if(x) begin 
	next_state = S101;
	end
	else next_state = S10;
	end
S101: 

================================================================
example-20: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ ( present_state )
begin
case ( present_state )
	IDLE: if ( x) next_state <= S1;
	IDLE: if (!x) begin next_state <= IDLE; end
	S1: begin if (!x) begin next_state <= IDLE; end
	S1: if (x) next_state <= S10;
	S10: begin if (x) begin next_state <= S101; end
	S10: if (!x); begin next_state <= IDLE; end
	S101: if (!x) begin next_state <= IDLE; end

	
endcase
end 


always @ ( present_state )
begin 

case ( present_state ) 
	IDLE: z = 0; 
	S1: begin z=0; end
	S10: begin z=0
================================================================
example-21: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(present_state, x)
begin 
if(present_state == IDLE | reset == 1)
	next_state <= x ? S1 : IDLE;

else 
begin
case(present_state)
IDLE: if(x)
	begin 
	next_state <= S1;
	z = 0;
	end
	else
	begin 
	next_state <= IDLE;
	z = 0;
	end

S1: if(!x)
	begin 
	next_state <= S10;
	z = 0;
	end
	else
	begin 
	next_state <= IDLE;
	z = 0;
	end

S10: if(x)
	begin 
	next_state <= S101;
	z = 1;
	end
	else
================================================================
example-22: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @( present_state, x )
	begin: FSM
	case ( present_state )
	IDLE : 
	begin
	// some output assigned
	if ( x == 1 )
	begin
	z = 1;
	next_state = S1;
	end
	else
	next_state = IDLE;
	end
S1 : 
	begin
	// some output assigned
	if ( x == 1 )
	begin
	z = 1;
	next_state = S10;
	end
	else
	next_state = IDLE;
	end
S10 :
	begin
	// some output assigned
	if ( x == 1 )
	begin
	z = 1;
	next_state = S101;
	end
	else
	next_state = IDLE;
	end
S
================================================================
example-23: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@ (present_state, x)
begin
case (present_state)
IDLE: if (x==1)
present_state <= S1;
else
present_state <= IDLE
S1: if (x==1)
present_state <= S10;
else
present_state <= IDLE
S10: if (x==0)
present_state <= S101;
else
present_state <= IDLE
S101: if (x==1)
present_state <= IDLE;
else
present_state <= IDLE;

default: present_state <= IDLE;

endcase

end


always @(present_state, x) // always block with sensitivity list.
begin
case (present_state)
IDLE:
	begin	
	next_state <= IDLE;
	z = 1'b0;

================================================================
example-24: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



// FSMD TFFs
// input clk as source clock
// present state and next state registers
reg [8:0] pre_reg; 
reg [8:0] next_reg;
wire z1;
wire z0;
// output TFF's
reg z1_reg;
reg z0_reg;
// gate level signal generated
wire [1:0] anyedge;

assign anyedge[1] = (x^pre_reg[1]) | (pre_reg[1] & pre_reg[8]);
assign anyedge[0] = (x^pre_reg[0]) | (pre_reg[0] & pre_reg[8]);


// mux controlled by anyedge

always@(x or pre_reg or anyedge)
begin
case(anyedge)
2'b00 : z1
================================================================
example-25: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( posedge clk or negedge reset )
begin
if(reset==1'b0)
 present_state <= IDLE;
else
 present_state <= next_state;
end
always @( present_state or x )
begin
case(present_state)
IDLE: 
begin 
if(x==1'b1)
 next_state = S1;
else
 next_state = IDLE;
end
S1: 
begin 
if(x==1'b0)
 next_state = S10;
else
 next_state = IDLE;
end
S10: 
begin 
if(x==1'b1)
 next_state = S101;
else
 next_state = IDLE;
end
S101:
begin
 next_state = IDLE;
end
endcase

================================================================
example-26: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(negedge clk or negedge reset) 
begin
	if(~reset)
	begin
	present_state <= IDLE; 
	end
	else
	begin
	present_state <= next_state; 
	end
end 


always @(present_state or x) 

begin 
case(present_state)
IDLE: 
begin 
	if(x) 
	begin
	next_state = S1; 
	z=0; 
	end 
	else 
	begin 
	next_state = IDLE; 
	z=0; 
	end

 end
S1: 
begin 
	if(~x) 
	begin
	next_state = S10; 
	z=0; 
	end 
	else 
================================================================
example-27: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( posedge clk or posedge reset )
begin
	if(reset)	// if reset is high, present_state is set to IDLE
	begin
	present_state <= IDLE;	
	end
	else
	begin
	case( present_state )
	IDLE :	// if present state is IDLE, check if xinput is high
	if( x )
	begin
	next_state <= S1;	// if xinput is 1, go to S1
	end
	else	// if xinput is 0, stay at IDLE
	next_state <= IDLE;
	S1 : 	// if present state is S1, check if xinput is low
	// Note that this state is same as S10, the next state is assigned to S1 if x input is 0
	if( x )
	begin

================================================================
example-28: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE




always @ (present_state, x ) // present_state and x must be declared with capture list 
	begin 
	
	case(present_state) // case must be used for sequential state transition only 
	
	IDLE:if ( x == 1) 
	begin 
	next_state <= S1; 
	z = 0; 
	end 
	else 
	begin 
	next_state <= IDLE; 
	z = 0; 
	end 
	
	S1: if (x == 0) 
	begin 
	next_state <= S10; 
	z = 0; 
	end 
	else 
	begin 
	next_state <= S1; 
	z = 0; 
	end 
	S10:if ( x == 1)
	begin 
================================================================
example-29: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


// combinational logic takes in present_state and x in it can cause transitions to next_state
// as explained in the comments above
always @ (present_state or x)
begin
	case (present_state)
	IDLE: begin
	if(x==0)
	next_state = IDLE;
	else next_state = S1;
	end 
	S1: begin
	if(x==0)
	next_state = IDLE;
	else next_state = S10;
	end
	S10: begin
	if(x==1)
	next_state = S101;
	else next_state = IDLE;
	end
	S101: begin
	if(x==0)
	next_state = IDLE;
	else next_state = IDLE;
	end
	default: next_
================================================================
example-30: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE




//always block changes value of present_state when rset is high
always @(posedge clk or posedge reset) 
begin
if (reset) 
present_state <= #2 IDLE;
 
else 
present_state <= #2 next_state;

end
 

// always block changes nex_state according to the signal x and current state whether IDLE or S1
always @(present_state or x)
begin
case (present_state)
IDLE : begin 
if (x) 
next_state = S1;

else
next_state = IDLE;
 end 
S1: begin 
if (x) 
next_state = S10;

else 
next_state = IDLE;
end
S10 : begin 
if (x) 
next_state = S101;
================================================================
example-31: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always@(present_state,x)
	begin
	 case(present_state)
	 IDLE : begin 
	 next_state = S1;
	 end
	 S1 : begin
	 if(x==1)
	 next_state = S10;
	 else 
	 next_state = IDLE;
	 end

	 S10 : begin
	 if(x ==1)
	 next_state = S101;
	 else 
	 next_state = IDLE;
	 end

	 S101 : begin
	 next_state = IDLE;
	 end

	 endcase

	 end
// next state to enable a signal z if present_state is S101
	always @ ( present_state )
	begin
	case(present_state)
	
	IDLE: 
	begin 
	z = 0;
	end
================================================================
example-32: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE




always @ ( present_state, x )
begin 
	case ( present_state )
	IDLE 	:	begin
	 case( x )
	1'b0	:	begin
	next_state = IDLE;
	z = 1'b0;
	end
	1'b1	:	begin
	next_state=S1;
	z = 1'b0;
	end
	endcase
	end
	S1 	:	begin
	case( x )
	1'b0	:	begin
	next_state = S1;
	z = 1'b0;
	end
	1'b1	:	begin
	next_state = S10;
	z = 1'b0;
	end
	endcase
	end
	S10	:	begin
	
================================================================
example-33: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always@(posedge reset or negedge clk)
begin
if(reset)
present_state <= IDLE;
else
present_state <= next_state;
end

always@(*)
begin
case(present_state)
IDLE : begin
if(x)
next_state = S1;
else
next_state = IDLE;
end;
S1 : begin
if(~x)
next_state = S10;
else
next_state = IDLE;
end;
S10: begin
if(x) 
next_state = S101;
else
next_state = IDLE;
end;
S101 : begin
if(x)
next_state = IDLE;
else
next_state = IDLE;
end;

endcase
end
always@(present_state or x)

================================================================
example-34: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @ ( present_state or x) 
begin
	case (present_state) // synopsys full_case parallel_case 
	IDLE : begin
	next_state = x ? S1 : IDLE;
	z=1'b0;
	end
	S1 : begin
	next_state = x ? S10 : IDLE;
	z=1'b0;
	end
	S10 : begin
	next_state = x ? S101 : IDLE;
	z=1'b0;
	end
	S101 : begin
	next_state = IDLE;
	z=1'b1;
	end
	default : begin
	next_state = IDLE;
	z=1'b0;
	end
	endcase
end

always @ (posedge clk) //stated
================================================================
example-35: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk) 
begin 
if( reset ) 
present_state <= IDLE; 
else 
present_state <= next_state; 
end 

always @(present_state or x ) 
begin 
case(present_state) 
IDLE: if( ~x ) 
begin 
next_state = S1; 
z <= 0; 
end 
else 
begin 
next_state = IDLE ; 
z <= 0; 
end 

S1: if( ~x ) 
begin 
next_state = S10; 
z <= 0; 
end 
else 
begin 
next_state = IDLE; 
z <= 0; 
end 
S10: if( ~x ) 
begin 
next_state = S101; 
================================================================
example-36: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(pos)
	begin
	case(pos)
	IDLE : if (reset == 1'b1)
	present_state <= S1;
	DONE : present_state <= IDLE;
	default : present_state <= IDLE;
	endcase
	end
// output signal z is asserted to 1 when present_state is S101 
assign z = (present_state == S101);
// the next state and output signal work together to make a state machine
always @(present_state)
begin
case (present_state)
IDLE : if (x == 0)
next_state <= S1;

S1 : if (x == 0)
next_state <= S1;

else
next_state <= S10;

S10 : if (x == 0)
next_state <= S1;

else
================================================================
example-37: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


//State encoding
always @(present_state)
begin
case(present_state)
IDLE: begin
if(x==1)
next_state = S1;
else
next_state = IDLE;
end
S1: begin
if(x==1)
next_state = IDLE;
else
next_state = S1;
end
S10: begin
if(x==1)
next_state = S101;
else
next_state = IDLE;
end
S101: begin
if(x==1)
next_state = IDLE;
else
next_state = S10;
end
default: next_state = IDLE;
endcase
end
//State Encoding Using Case Statements
always @(posedge clk )
begin
if(reset) 
present_state = IDLE;
else

================================================================
example-38: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @ (posedge clk) 
begin : FSM_SEQ 
present_state = next_state; 
case (present_state) 
	IDLE : if (x)
	begin 
	next_state = S1; 
	z = 1'b0; 
	end 
	else 
	begin 
	next_state = IDLE; 
	z = 1'b0; 
	end 
	S1 : if(~x) 
	begin 
	next_state = IDLE; 
	z = 1'b0; 
	end 
	else 
	begin 
	next_state = S1; 
	z = 1'b0; 
	end 
	S10 : if(x) 
	begin 
	next_state = S101;
================================================================
example-39: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @ ( posedge clk ) begin
	 // swaps between IDLE, S1, and S10 based on input x
	 if (present_state == IDLE)
	 begin
	 if(x == 1)
	 next_state = S1;
	 else
	 next_state = IDLE;
	 end
	 
	 // land at S1 when posedge on rst
	 if (present_state == S1)
	 begin
	 if(x == 1)
	 next_state = S10;
	 else
	 next_state = IDLE;
	 end
	 
	 // land at S10 when posedge on rst
	 if (present_state == S10)
	 begin
	 if(x == 1)
	 next_state = S101;
	 else
	 next_state = IDLE;
	 end
	
================================================================
example-40: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @( posedge clk, posedge reset)
if(reset)
present_state <= IDLE;

else
present_state <= next_state;


always @( posedge clk )
begin
case(present_state)
IDLE: if(x) next_state = S1;
	else next_state=IDLE;
S1: if(x) begin 
	next_state = S10;
	end
	else next_state=IDLE;
S10: if(x) begin 
	next_state = S101;
	end
	else next_state=IDLE;
S101: if(x) begin 
	next_state = IDLE;
	end
	else next_state=IDLE;

endcase
end

assign z = ( present_state == S101 )?
================================================================
example-41: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( posedge clk, posedge reset )
begin
if( reset )
present_state <= IDLE;
else
present_state <= next_state;
end


always @ ( present_state, x )
case( present_state )
IDLE :
begin
if( x == 1'b1 )
next_state = S1;
else
next_state = IDLE;
end
S1 : 
begin
if( x == 1'b0 )
next_state = S10;
else
next_state = IDLE;
end
S10 :
begin
if( x == 1'b1 )
next_state = S101;
else
next_state = IDLE;
end
S101 :
begin
if( x == 1'b1 )
next_state = IDLE;
else
next_state = ID
================================================================
example-42: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(present_state, x)
// next state transition logic
begin
case(present_state)
IDLE :
begin
z=1'b1;
if (x==1) $display("Debug Output : %b\n next state is S1, x is %b\n", present_state, x);
else $display ("Debug Output : %b\nnext state is IDLE, x is %b\n", present_state, x);
next_state = S1;
end
S1:
begin
$display("Debug Output : %b\n present state is S1, x is %b\n", present_state, x);
next_state = x ? S10: IDLE;
end
S10:
begin
$display("Debug Output : %b\n present state is S10, x is %b\n", present_state
================================================================
example-43: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @( present_state ) 
begin 
	case( present_state ) 
	IDLE: begin
	if( x == 1 ) 
	begin 
	next_state = S1; 
	z = 0;
	end
	else 
	begin 
	next_state = IDLE;
	z = 0; 
end 
	end 
	S1: begin 
	if( x == 1 ) 
	begin 
	next_state = S10; 
	z = 0;
	end
	else 
	begin 
	next_state = IDLE; 
	z = 0; 
end 
	end 
	S10: begin 
	if( x == 1 ) 
	begin 
	next_state = S101; 
	z = 0;
	end
================================================================
example-44: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


// FSM coding is assign statement
assign z = (present_state == IDLE)? x:1'bz; 

always @(posedge clk, posedge reset)
begin
 if (reset)
 begin 
 present_state <= IDLE;
 end 
 else 
 begin 
 present_state <= next_state;
 end 
 end 
 
always @(*)
begin 
 case ( present_state ) 
 IDLE: if( x ) 
 begin 
 next_state = S1;
 end 
 else 
 begin
 next_state = IDLE;
 end 
 S1: if( ~x ) 
 begin 
 next_state = IDLE;
 end 
 else 
 begin 
 next_state = S10;
 end 
 S10: if( x ) 
 begin 
 next_state =
================================================================
example-45: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE



always @ (present_state, x)
begin
	case ( present_state )
	IDLE : begin
	if ( x && ~reset )
	next_state <= S1;
	else
	next_state <= IDLE;
	end
	S1 : begin
	if ( ~x && reset )
	next_state <= IDLE;
	else
	next_state <= S10;
	end
	S10 : begin
	if ( x && reset )
	next_state <= S101;
	else
	next_state <= IDLE;
	end
	S101 : begin
	if ( ~x && reset )
	next_state <= IDLE;
	else
	next_state <= IDLE;
	end
	endcase
end


always @ ( present_state )
begin
 
case ( present_
================================================================
example-46: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk ) // Triggered always block
	if(reset) present_state <= IDLE; //reset asserted low
	else
	present_state <= next_state; //chooses next state

always @(x) //always triggers on x to determine the next state
	if(present_state == IDLE)
	case(x)
	1'b0: next_state <= S1;
	1'b1: next_state <= IDLE;
	endcase
	if(present_state == S1)
	case(x)
	1'b0: next_state <= S10;
	1'b1: next_state <= IDLE;
	endcase
	if(present_state == S10)
	case(x)
	1'b0: next_state <= IDLE;
	1'
================================================================
example-47: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(present_state)
begin
	case (present_state)
	IDLE: if (x) next_state = S1;
	else next_state = IDLE;
	S1: if (x) next_state = S10;
	else next_state = IDLE;
	S10: if (x) next_state = S101;
	else next_state = IDLE;
	S101: next_state = IDLE;
endcase

always @(posedge clk or posedge reset)
begin
	if (reset == 1) present_state <= IDLE;
	else present_state <= next_state;
end

assign z=(present_state==S101);


================================================================
example-48: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE


always @(posedge clk, posedge reset) begin
if (reset)
present_state <= IDLE;

else
present_state <= next_state;
end

always @(x, present_state) begin
case(present_state)

IDLE: if(x)
next_state = S1;
else
next_state = IDLE;

S1: if(!x)
next_state = S10;
else
next_state = IDLE;

S10: if(x)
next_state = S101;
else
next_state = IDLE;

S101: next_state = IDLE;

endcase
end

assign z = (present_state == S101) ? 1 : 0;



================================================================
example-49: 
// This is a finite state machine that recognizes the sequence 101 on the input signal x. 
module adv_fsm(
input clk,
input reset,
input x,
output z ); 
reg [1:0] present_state, next_state;
parameter IDLE=0, S1=1, S10=2, S101=3;
// output signal z is asserted to 1 when present_state is S101 
// present_state is reset to IDLE when rset is high
// otherwise it is assigned next state
// if present_state is IDLE, next_state is assigned S1 if x is 1, otherwise next_state stays at IDLE
// if present_state is S1, next_state is assigned S10 if x is 0, otherwise next_state stays at IDLE 
// if present_state is S10, next_state is assigned S101 if x is 1, otherwise next_state stays at IDLE 
// if present_state is S101, next_state is assigned IDLE

	always @(present_state, x) begin
	
	case(present_state)
	IDLE:
	begin
	if(x==1) 
	begin
	next_state = S1;
	z = 1'b0;
	end
	else
	begin
	next_state = IDLE;
	z = 1'b0;
	end
	end
	S1:
	begin
	if(x==0) 
	begin
	next_state = IDLE;
	z = 1'b0;
	end
	else
	begin
	next_state = S10;
	z = 1'b0;
	end
	end
	S10:
	begin
	if(x==1) 
	begin
	next_state = S101;
	z = 1'b0
================================================================
