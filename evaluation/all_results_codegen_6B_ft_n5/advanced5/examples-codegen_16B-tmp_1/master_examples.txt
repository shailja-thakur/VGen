example-0: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z = (cur_state == SAB);
// This gate is created in each case to move to the desired state
// Note: state transitions are asynchronous.
always @(posedge clk,negedge reset)
begin
if(!reset)
cur_state <= IDLE; // Default values
else begin
cur_state <= next_state;
end
end
// This logic assigns the next state as described above
always @(cur_state,a,b)
begin
case(cur_state)
IDLE:
begin 
if(a == 0 && b == 0)
next_state = IDLE; 
else if (a == 1 && b == 0) 
next_state = SA; // When only a is 1
else if (a == 0 && b == 1)
next_state = SB; // Only b is 1
else 
next_
================================================================
example-1: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero otherwise
always @(*)
begin
if (cur_state == SA or cur_state == SB) begin
if (a==1'b1 && b==1'b1) begin
next_state = SAB;
end
else if (a==1'b1 && b==1'b0) begin
next_state = SA;
end
else if (a==1'b0 && b==1'b1) begin
next_state = SB;
end
else begin
next_state = IDLE;
end
end else if (cur_state == SAB) begin
next_state = IDLE;
end
else begin
next_state = IDLE;
end
end
// next_state-logic
always@ (posedge clk or posedge reset) begin
if (reset) begin
cur_state <= IDLE;
================================================================
example-2: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk)
begin
if(reset)
cur_state <= IDLE;
// Overflow is also very important, enabling your code to execute beyond
// the operating points of your inputs. In this case, this can happen if the edge
// flip flops receive values on the 2nd positive edge, so no new value will be outputted
// putting this into the state machine is a very good idea.
// Here we catch the overflow condition on both edges of "a" without a glitch
// even when a or b change values suddenly.
else if ((cur_state == IDLE) & a & b)
cur_state <= SAB;
else if ((cur_state == IDLE) & a)
cur_state <= SA;
else if ((cur_state == IDLE) & b)
cur_state <= SB;
// Remember all state transitions are non-blocking!

================================================================
example-3: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
	
// State change logic
always@(posedge clk)
begin: state_FFs
	if(reset)
	begin
	cur_state <= IDLE;
	end
	else
	begin
	cur_state <= next_state;
	end
end

// State transition logic
always@(*)
begin
	case(cur_state)
	IDLE:
	begin
	if(a && b)
	begin
	next_state = SAB;
	end
	else if(a)
	begin
	next_state = SA;
	end
	else if(b)
	begin
	next_state = SB;
	end
	else
	begin
	next_state = IDLE;
	end
	end
	SA:
	begin
	if(b)
	begin
	next_state
================================================================
example-4: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned the value of sb when cur_state is SB 
// z is assigned the value of s when cur_state is SA 
// z is assigned zero when cur_state is IDLE
// When a or b change, the state transitions as described above
always @(posedge clk ) begin
if (reset) 
 cur_state <= IDLE; // initial state
else
cur_state <= next_state;
end
// The next state is assigned the same as the current state for the IDLE state.
// The next state is assigned S for the SA state.
// The next state is assigned SAB for the SB state.
// The next state is assigned SB for the S state.
always @(a or b) begin
if (cur_state == IDLE) begin
case ({a,b})
2'b00: begin
next_state = IDLE;
================================================================
example-5: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z=(cur_state==SAB || (cur_state==SB && a && b));
// But if it is busy, nothing is sent
always @(posedge clk or reset)
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(cur_state)
begin
case(cur_state)
IDLE: if (a==1 && b==1) next_state=SA; // If (a,b) is in, send SA
IDLE: if (a==1 && b==0) next_state=SB; // If (a,b) is out, send SB
SA: if(b) next_state=SAB; else next_state=IDLE; // bps always high, unless it is busy.
SB: if(a) next_state=SAB;
================================================================
example-6: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @ (cur_state,a,b)
begin
z = 1'b0;
case (cur_state)
IDLE: begin 
if (a == 1 && b == 1) next_state = SAB;
else next_state = IDLE;
end
SA: begin
if (a == 1 && b == 1) next_state = IDLE;
else next_state = SA;
end
SB: begin
if (a == 1 && b == 1) next_state = IDLE;
else next_state = SB;
end
SAB: begin
if (a == 1 && b == 1) next_state = IDLE;
else next_state = SAB;
end
default : next_state = IDLE;
endcase
end
// FSM outputs
always @ (posedge clk, negedge reset)
begin
if (
================================================================
example-7: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero when cur_state is IDLE
assign z = cur_state == SAB;
always @ (posedge clk or negedge reset) begin
if(!reset) begin z <= 1'b0; cur_state <= IDLE;
end
cur_state <= next_state;
end
always @ (a or b) begin
if(cur_state == IDLE) begin
if(a) begin next_state = SA;
end else if(b) begin
 next_state = SB;
 end else begin
next_state = IDLE;
 end
end else if(cur_state == SA) begin
if(a) begin next_state = SAB;
end else begin
next_state = SA;
 end
end else if(cur_state == SB) begin
if(a) begin
 next_state = SAB;
end
================================================================
example-8: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(*) begin
case(cur_state)
IDLE: if (a && b) next_state = SAB;
	else if (a) next_state = SA;
	else if (b) next_state = SB;
SA: if (b && a) next_state = SAB;
	else if (a) next_state = SA; 
	else if (b) next_state = SB;
SB: if (a && b) next_state = SAB;
	else if (a) next_state = SB;
	else if (b) next_state = SA;
SAB: if (b && a) next_state = IDLE;
	else if (a) next_state = SA; 
	else if (b) next_state = SB;
endcase
end
always @(posedge clk) begin

================================================================
example-9: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// This could also be achieved using always @(negedge a or posedge b)
assign z = (cur_state == SAB);
always @(posedge clk )
begin
if(reset)
cur_state <= IDLE;
else 
cur_state <= next_state;
end
always @(a or b)
begin
case(cur_state)
IDLE :
begin
if(a == 1 & b == 1)
next_state = SAB;
else 
next_state = IDLE;
end
SA : 
begin
if(a == 1)
next_state = SB;
else
next_state = (b == 1 ) ? IDLE : SA;
end
SB : 
begin
if(b == 1)
next_state = IDLE;
else
next_state = SA;
end
SAB
================================================================
example-10: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned 0 otherwise
always @(posedge clk) 
begin
if(reset == 1'b1)
cur_state <= IDLE;
else 
cur_state <= next_state;
end
always @(cur_state or a or b ) 
case(cur_state)
	IDLE:begin
	if(a == 1'b1 && b == 1'b1) begin
	next_state<=SAB;cur_out <= 1'b0;
	end
	else begin
	next_state<=IDLE;cur_out <= 1'b0;
	end
	end
	SA:begin
	if(a == 1'b1 && b == 1'b0) begin
	next_state<=STOP;cur_out <= 1'b0;
	end
	else begin
	next_
================================================================
example-11: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned 0 otherwise.
initial cur_state = IDLE;
always @(posedge clk )
begin
if (reset)
cur_state <= IDLE;
else 
cur_state <= next_state;
end
always @(*)
begin
case(cur_state)
IDLE:
begin
if(a==1 && b==1)
begin
next_state = SA;
z = 1'b0;
end
else
begin
next_state = IDLE;
z = 1'b0;
end
end
SA:
begin
if(a==1)
begin
next_state = SAB;
z = 1'b0;
end
else
begin
next_state = SA;
z = 1'b0;
end
end
SAB:
begin
if(b==1)
begin 

================================================================
example-12: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg z;
always @ (posedge clk, posedge reset )
begin
if (reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @ (*)
begin
case (cur_state)
IDLE : begin
if (a && b) begin
next_state = SAB;
z = 1'bZ;
end
else if (a) begin
next_state= SA;
z= 1'bZ;
end
else if (b) begin
next_state= SB;
z=1'bZ;
end
else begin
next_state= IDLE;
z= 1'bZ;
end
end;
SA : begin
if (b) begin
next_state= SAB;
z=1'bZ;
end
else begin
next_state= SB;

================================================================
example-13: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always@(cur_state)
begin
case(cur_state)
IDLE:
begin
if(a==1 & b==1)
assign z = 1;
else
assign z = 0;
if(a==1)
assign next_state = SA;
else if(b==1)
assign next_state = SB;
else
assign next_state = IDLE;
end
SA:
begin
assign next_state = SB;
if(b==1)
assign z = 1;
else
assign z = 0;
end
SB:
begin
assign next_state = SAB;
if(a==1)
assign z = 1;
else
assign z = 0;
end
SAB:
begin
assign next_state = IDLE;
assign z = 1;
end
================================================================
example-14: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always@ (cur_state or a or b)
begin
case(cur_state)
IDLE:
begin
if (a==1'b1 && b==1'b1)
cur_state <= SAB;
else
cur_state <= IDLE;
end
SA:
begin
if (b==1'b1)
cur_state <= SAB;
else
cur_state <= SA;
end
SB:
begin
if (a==1'b1)
cur_state <= SAB;
else
cur_state <= SB;
end
SAB:
cur_state <= IDLE;
default:
cur_state <= IDLE;
endcase
end
// assign z based on cur_state
assign z = (cur_state==SAB);
always@ (posedge clk)
//^ d1 high when next state is
================================================================
example-15: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// All these states can change at any time, except in steady state (cur_state == IDLE)
always @(posedge clk,posedge reset)
begin
	if(reset)
	begin
	cur_state <= IDLE;
	end
	else
	begin
	cur_state <= next_state;
	end
end
always @(*)
begin
	case(cur_state)
	IDLE: begin
	next_state = a&b ? SAB : cur_state;
	z = 0;
	end
	SA: begin
	next_state = b ? SAB : SA;
	z = 0;
	end
	SB: begin
	next_state = a ? SAB : SB;
	z = 0;
	end
	SAB: begin
	next_state = IDLE;
	z = 1
================================================================
example-16: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg [2:0] ztest; // This value must mirror cur_state
initial
begin
cur_state = IDLE;
z = 0;
end
always @(posedge clk )
begin
if(reset)
begin
cur_state <= IDLE; // AS LAB DOCS SAYS TO PUT IN IT IS ONLY FOR CYCLE SHIFT PURPOSES
current <= 1;
ztest <= 0;
end
else
current <= 0;
end
always @(a,b,cur_state)
begin
case (cur_state)
IDLE: begin
if (a == 1 && b == 1)
begin
next_state <= SA;
current <= 1;
ztest <= 0;
end
else
begin
next_state <= IDLE;
current <= 0;
ztest <= 0;
end
end
SA: begin
if (
================================================================
example-17: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// Note that output assignments are not synchronized. I don't see a problem,
// but real applications should synchronize them where feasible.
always @(posedge clk)
begin
if(reset)
	cur_state <= IDLE;
else
	cur_state <= next_state;
end
always @(cur_state or a or b)
begin
case(cur_state)
IDLE : begin
z = 0;
if(a == 1 && b == 1)
begin
	next_state = SA;
	z = 0;
end
else if(a == 1)
begin
	next_state = SA;
	z = 0;
end
else if(b==1)
begin
	next_state = SB;
	z = 0;
end
else
begin
	next_state = IDLE;
	z = 0;
end
================================================================
example-18: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// Otherwise, the z value stays unchanged.
//State changes obviously only when appropriate.
// Only one of the signals possible to all happen at the same time, depends on the
// current state. That way, the state changes on an each clock cycle.
always @(posedge clk or reset) begin
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
end
always @(a or b)
case(cur_state)
IDLE:	begin
	if(a == 0 & b == 0)	
	begin
	next_state = IDLE;
	z=0;
	end
	else if (a == 1 & b==0)
	begin
	next_state=SA;
	z=0;
	end
	else if (a==0 & b==1)
	begin
================================================================
example-19: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned 0 when cur_state is not IDLE
reg a_received,b_received,z;
always @(posedge clk)
begin

if(reset)
cur_state <= IDLE;	
else
cur_state <= next_state;

z <= 0;

end
always @(a or b) 
begin

a_received <= 0;
b_received <= 0;
next_state <= IDLE;

case (cur_state)
IDLE:
begin
if (a && b)
next_state <= SAB;
else if (a)	
next_state <= SA;
else if (b)
next_state <= SB;
end
SA:
begin
if (b)
next_state <= SAB;
else 
next_state <= SA;
if (b & a)
a
================================================================
example-20: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg z;
always @(posedge clk, posedge reset)
begin
if(reset)
cur_state=IDLE;
else
cur_state=next_state;
end
always @(cur_state,in,a,b)
begin
case(cur_state)
IDLE:
begin
if(a==1 && b==1)begin
	next_state=SAB;
	z=0;
end
else if(a==1)begin
	next_state=SA;
	z=0;
end
else if(b==1)begin
	next_state=SB;
	z=0;
end
else
begin
z=0;
next_state=IDLE;
end
end
SA:
begin
if(b==1)begin
	next_state=SAB;
	z=0
================================================================
example-21: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk)
begin
if (reset) begin cur_state <= IDLE; z<=0; end
else begin cur_state <= next_state;z<=1; end
end
always @(a or b or cur_state)
begin
if(cur_state==IDLE)
begin
if(a==1 && b==1)
begin next_state<=SAB; z<=0; end
else if(a==0 && b==0 && cur_state!=cur_state)
begin next_state<=IDLE; z<=0; end
else next_state<=IDLE;
end
else if(cur_state==SA && b==0 && a==0) begin next_state<=IDLE; end
else if(cur_state==SB && a==0 && b==0) begin next_state
================================================================
example-22: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// and 0 is assigned to other cases
always @(posedge clk)
begin
if(reset == 0)
begin
z <= 0;
cur_state <= IDLE;
end
else cur_state <= next_state;
end
always @(*)
begin
case (cur_state)
IDLE : begin
next_state = (a)? (b)? SAB : (b)? SB : (a)? SA : cur_state;
z = (cur_state == IDLE) & a & b;
end
SA : begin
next_state = (a) ? SAB : cur_state;
z = (cur_state == SA) & b;
end
SB : begin
next_state = (b) ? SAB : cur_state;
z = (cur_state == SB) & a;
end
SAB : begin
next_state =
================================================================
example-23: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @ (*)
begin
case (cur_state)
IDLE : begin
	if (~a & ~b) begin
	z = 1'b1;
	next_state = IDLE;
	end
	else if ( a & ~b ) begin
	z = 1'b1;
	next_state = SA;
	end
	else if (~a & b) begin
	z = 1'b1;
	next_state = SB;
	end
	else begin
	z=1'b0;
	next_state = IDLE;
	end
	end
SA : begin
	if (~b) begin
	z = 1'b1;
	next_state = SAB;
	end
	else begin
	z=1'b0;
	next_state = SA;
	end
	end
SB :
================================================================
example-24: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk, posedge reset) 
	if(reset == 1)
	cur_state <= IDLE; // when reset is high, make sure that the value of current state is 0;
	else
	cur_state <= next_state; // when reset is low, change state to next state
always @(cur_state,a,b)
case(cur_state)
IDLE: if(a==1 & b ==1)
	next_state = SA; // if both a and b are high, stay in IDLE state
	else if(a==1 & b == 0)
	next_state = SB; // if only a is high, stay in IDLE state
	else if(a==0 & b==1)
	next_state = SB; // if only b is high, stay in IDLE state
	else
	next_state
================================================================
example-25: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z = (cur_state == SAB);
always@(posedge clk,reset)
	if(reset) begin
	cur_state <= IDLE;
	end else begin
	cur_state <= next_state;
	end
always@(cur_state,a,b)
	case(cur_state)
	IDLE: begin
	if(a==1'b1 && b==1'b1)begin next_state = SA;
	end else next_state = IDLE;
	end
	SA:begin
	if(b==1'b1)begin next_state = SAB;
	end else next_state = SB;
	end
	SB:begin
	if(a==1'b1)begin next_state = SAB;
	end else next_state = IDLE;
	end
	SA
================================================================
example-26: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always@(posedge clk) begin
	if(reset) begin
	cur_state <= IDLE;
	z <= 0;
	end
	else begin
	cur_state <= next_state;
	z <= (cur_state== SAB) ? 1'b1 : 1'b0;
	end
end 

always@(*) begin
	case(cur_state)
	IDLE : begin
	if(a==0&&b==0) 
	next_state = IDLE;
	if(a==1&&b==0) next_state = SA;
	if(a==0&&b==1) next_state = SB;
	if (a==1&&b==1) next_state = SAB;
	end
	SA : begin 
	if(a==1&&b==0) next_state =
================================================================
example-27: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg z;
always @(posedge clk, posedge reset)
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(*)
begin
case(cur_state)
	IDLE:
	begin
	if((a & b) == 2'b11) 
	begin
	z = 1'b1;
	next_state = SAB;
	end 
	else if(a == 1'b1)
	begin
	next_state = SA;
	end
	else if(b == 1'b1)
	begin
	next_state = SB;
	end
	else 
	begin
	next_state = IDLE;
	end
	end
	SA:
	begin
	if(b == 1'b1)
	
================================================================
example-28: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero when cur_state is IDLE
always @ (posedge clk or posedge reset)
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
always @ (a or b or cur_state)
	begin
	// Register a and b
	x = a;
	y = b;
	case (cur_state)
	IDLE: 
	begin //cur_state
	if ( x && y) //cur_state is IDLE and both x and y are 1s
	next_state <= SAB;
	// Driving z high when cur_state is IDLE
	z = 0;
	end //end case of IDLE
	SA: 
	begin //cur_state
	if ( x && y) //cur_state is SA and both x and y are
================================================================
example-29: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(*)
begin
if(reset)
	cur_state <= IDLE;
else
	cur_state <= next_state;
// State transition
case(cur_state)
IDLE:
	if(a && b)
	begin	
	next_state = SA;
	end
	else if(a)
	begin
	next_state = SA;
	end
	else if(b)
	begin
	next_state = SB;
	end
	else
	begin
	next_state = IDLE;
	end
SA:
	if(b)
	begin
	next_state = SAB;
	end
	else
	begin
	next_state = IDLE;
	end
SB:
	if(a)
	begin
	next_state = SAB;
	end
	else

================================================================
example-30: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned 0 when cur_state is IDLE
always @ (posedge clk, posedge reset)
begin
if(reset)
cur_state = IDLE;
else
cur_state = next_state;
end
always @ ( a, b, cur_state)
begin
case(cur_state)
IDLE: begin
if(a && b) next_state = SA;
else next_state = IDLE;
end
SA: begin
if(a) next_state = SA;
else if(b) next_state = SB;
else next_state = IDLE;
end
SB: begin
if(b) next_state = SB;
else if(a) next_state = SAB;
else next_state = IDLE;
end
SAB: begin
next_state = SAB;
end
default: next_
================================================================
example-31: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z = (cur_state == SAB) ? 1:0;
always @(posedge clk or negedge reset)
begin
if(~reset) 
cur_state <= IDLE;
else 
begin
cur_state <= next_state;
end
end
always @(cur_state or a or b)
begin
if(cur_state == IDLE)
begin
if(a == 1'b1 && b == 1'b1)
begin
next_state <= SAB;
end
else if(a == 1'b1)
begin
next_state <= SA;
end
else if(b == 1'b1)
begin
next_state <= SB;
end
end
else if(cur_state == SA)
begin
if(b == 1'b1)
begin
next_state <= SAB;

================================================================
example-32: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk,posedge reset)
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(cur_state,a,b) //assign the output
begin
case (cur_state)
IDLE: if(a==1 && b==0)
begin
next_state = SA;
z=1'b0;
end
else if(a==0 && b==1)
begin
next_state=SB;
z=1'b0;
end
else if(a==0 && b==0)
begin
next_state = IDLE;
z=1'b0;
end
else //a and b are both 1
begin
next_state = SAB;
z=1'b0;
end
SA: if(a==0 &&
================================================================
example-33: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned to x when cur_state is IDLE, and x is true
// The state machine operates on cur_state
// when cur_state is IDLE, and x is high, z is unchanged
always@(posedge clk or negedge reset)
	begin
	if(reset)
//set the current state as IDLE, output 0, and preset the next state
// to SA
	cur_state <= IDLE;
	z <=0;
// when x and y are both high and curent state is IDLE
	else if(cur_state == IDLE && x==1 && y==1)
	begin
//set the current state to SA, the next value for x, and the 
// next state to IDLE
	cur_state <= SA;
	x <= 1;
	next_state <= IDLE;
// when previous state is SA
================================================================
example-34: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// All signals a and b should be given for IDLE state 
always@(posedge clk) 
begin
if (reset)
	cur_state <= IDLE;
else
	cur_state <= next_state;
end
always @(a,b,cur_state)
begin
case(cur_state)
IDLE:
	begin
	if(a && b)
	begin
	next_state = SAB;
	z = 1'b0;
	end
	else
	begin
	next_state = IDLE;
	z = 1'b0;
	end
	end
SA:
	begin
	if(b)
	begin
	next_state = SB;
	z = 1'b0;
	end
	else
	begin
	next_state = IDLE;
	z = 1'
================================================================
example-35: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero otherwise
always @(posedge clk) 
	if(reset == 1'b1)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
always @(z or cur_state) 
begin
	case(cur_state)
	IDLE:
	begin
	if(b == 1'b1 && a == 1'b1)
	begin next_state = SAB;
	z = 1;
	end
	else
	begin next_state = IDLE;
	z = 0;
	end
	end
	SA:
	begin
	if(b == 1'b1)
	begin next_state = SAB; 
	z = 1;
	end
	else
	begin next_state = SA;
	z = 0;
	end

================================================================
example-36: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z = ( (cur_state === SAB) ? 1'b1 : 1'b0);
// state register, contains logic for the state transitions.
always @(posedge clk or posedge reset) begin
 if(reset) begin
	cur_state <= IDLE;
 end else begin
	cur_state <= next_state;
 end
end
always @(cur_state,a,b ) begin
case( cur_state )
	IDLE: begin
	if( a == 1'b1 && b == 1'b1 ) begin
	next_state = SAB;
	 };
	else begin
	next_state = IDLE;
	end
	end
	SA: begin
	if( b == 1'b1 ) begin
	next_state = SAB;
	end else begin
	next_state = SB;
	
================================================================
example-37: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
assign z = (cur_state==SAB);
assign a_ = (cur_state==IDLE && a == 1);
assign b_ = (cur_state==IDLE && b == 1);
always @(posedge clk)
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @*
begin
case (cur_state)
IDLE : begin
z_ <= 0;
if (a_)
next_state = a;
else if (b_)
next_state = b;
else
next_state = cur_state;
end
SA : begin
z_ = 0;
if (a_)
next_state = a;
else
next_state = SB;
end
SB : begin
z_ = 0;
if (b_)

================================================================
example-38: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// This is a Moore Machine - Mealy Machine is Multiplexer based
always@(posedge clk,posedge reset)
	begin
	if(reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
	end
always@(cur_state,a,b)
begin
case(cur_state)
IDLE : begin
if(a)
next_state <= SA;
else if(b) 
next_state <= SB;
else 
next_state <= IDLE;
z <= 0;
end
SA : begin
if(b)
next_state <= SAB;
else
next_state <= SA;
z <= 0;
end
SB : begin
if(a)
next_state <= SAB;
else
next_state <= SB;
z <= 0;
end
SA
================================================================
example-39: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk or reset)
begin
 if (reset) 
cur_state <= IDLE;
else 
cur_state <= next_state;
end
always @(cur_state or a or b)
case(cur_state)
IDLE: if(a && b)
begin
next_state = SA;
end
else
begin
next_state = IDLE;
end
SA: if(a)
begin
next_state = SB;
end else
begin
next_state = IDLE;
end
SB: if(b)
begin
next_state = SAB;
end
else 
begin
next_state = IDLE;
end
SAB :begin
next_state = IDLE;
end

endcase

assign z = (cur_state == SAB);

================================================================
example-40: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero otherwise
always @(posedge clk )
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(cur_state or a or b)
begin
case(cur_state)
IDLE : begin z = 0; next_state = a + b; end
SA : begin z = 0; next_state = b; end
SB : begin z = 0; next_state = a; end
SAB : begin z = 1; next_state = IDLE; end
default: begin z = 1; next_state = IDLE; end
endcase
end

================================================================
example-41: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg [1:0] z_rr;
always @(posedge clk)
begin
if(reset)
cur_state <= IDLE;
else
cur_state <= next_state;
end
always @(*)
begin
case(cur_state)
IDLE:
begin
if (a==1 && b==1)
next_state = SA;
else
next_state = IDLE;
z_rr=2'b01;
end
SA:
begin
if (b==1)
next_state = SB;
else
next_state = IDLE;
z_rr=2'b11;
end
SB:
begin
if (a==1)
next_state = SAB;
else
next_state = IDLE;
z_rr=2'b10;
end
SAB:
begin
next_state
================================================================
example-42: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// Assigining z to the output z is a matter of placing z on the
always @*
case (cur_state)
	IDLE : begin
	if (a == 1'b1 & b == 1'b1)
	next_state = SA;
	else if (a == 1'b1)
	next_state = SA;
	else if (b == 1'b1)
	next_state = SB;
	else
	next_state = IDLE;
	z = 1'b0;
	end
	SA : begin
	if (b == 1'b1)
	next_state = SAB;
	else
	next_state = SA;
	z = 1'b0;
	end
	SAB : begin
	next_state = IDLE;
	z = 1'b1;
	end

================================================================
example-43: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk or posedge reset)
begin: state_table
	if(reset) cur_state <= IDLE;
	else
	cur_state <= next_state;
end
always @(a or b or cur_state or cur_inputs)
begin :signal_table
next_state = IDLE;
case(cur_state)
IDLE:
	if(a) begin
	next_state = SA;
	end
	else if(b) begin
	next_state = SB;
	end
	else if(cur_inputs) begin
	next_state = SAB;
	end
SA:
	if(b) begin
	next_state = SAB;
	end
	else if(cur_inputs) begin
	next_state = SAB;
	end
	else begin
	
================================================================
example-44: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// z is assigned zero when cur_state is IDLE
// Note that if only zero or only one of a or b is provided, then
// no output, and hence the output is not one and z is 0.

always @(posedge clk)
begin
	if (reset)
	cur_state <= IDLE;
	else
	cur_state <= next_state;
end

always @(cur_state or a or b)
begin
	case(cur_state)
	IDLE:
	begin
	if (a == 1 && b == 1)
	begin
	next_state = SAB;
	z = 1;
	end
	else 
	begin
	next_state = IDLE;
	z = 0;
	end
	end
	
	SA:
	begin
	if (b == 1)
	
================================================================
example-45: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
always @(posedge clk, posedge reset) begin
if(reset)
cur_state <= 1'b0;
else
cur_state <= next_state; 
end
always @ (a,b) begin
if(cur_state==IDLE) begin
if(a==1'b1 && b==1'b1)
next_state <= SA;
else if(a==1'b1 && b==1'b0)
next_state <= SB;
else if(a==1'b0 && b==1'b1) 
next_state <= SA;
else 
next_state <= IDLE;
end
else begin
if( cur_state == SA && a == 1'b1 )
next_state <= SAB;
else if( cur_state == SB && b == 1'b1 )
next_state <= S
================================================================
example-46: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// so it must be updated on each clock
assign z = (cur_state == IDLE)?
1:0;
// state transition logic
always @(cur_state,a,b)
begin
case (cur_state)
IDLE: begin
if ((a==1) & (b==1)) next_state = SAB;
else if ((a==1) & (b==0)) next_state = SA;
else if ((a==0) & (b==1)) next_state = SB;
else next_state = IDLE;
end
SA: begin
if ((b==1) & (a==1)) next_state = SAB;
else if ((b==0) & (a==1)) next_state = IDLE;
else next_state = SA;
end
SB: begin
if ((a==1) & (b==1
================================================================
example-47: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// In the case that someone changes state then z is tagged high
always @(a,b,cur_state)
begin
case(cur_state)
IDLE:
begin
if((a==1)&&(b==0))
begin
next_state = IDLE;
z = 0;
end
else if ((a==0)&&(b==0))
begin
next_state = IDLE;
z = 0;
end
else
begin
next_state = SAB;
z = 0;
end
end
SA:
begin
if(b==1)
begin
next_state = SA;
z = 0;
end
else
begin
next_state = SAB;
z = 0;
end
end
SB:
begin
if(a==1)
begin
next_state = SB;
z = 0;
end

================================================================
example-48: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
reg z;
always @ (posedge clk or posedge reset) // always statement starts from here
begin
if(reset)
z=0;
else
case(cur_state)
IDLE: begin
if (a && b) begin
next_state=SAB;
end
else begin
z=0;
next_state=IDLE;
end
end
SA: begin
if (!b) begin
z=1;
next_state=SAB;
end
else if (a && b) begin
z=1;
next_state=SAB;
end
else begin
z=0;
next_state=IDLE;
end
end
SAB: begin
if (!b)
z=1;
else if (a && b)
z=1;
else
z=0;
next_state=IDLE;
end
================================================================
example-49: 
// This is an FSM
module abro(
input clk,
input reset,
input a,
input b,
output z );
parameter IDLE = 0,
SA = 1,
SB = 2,
SAB = 3;
reg [1:0] cur_state,next_state;
// The output z is high when 1 is received for signals a and b in any order.
// If cur_state is IDLE and a and b are both high, state changes to SAB
// If cur_state is IDLE, and a is high, state changes to SA
// If cur_state is IDLE, and b is high, state changes to SB
// If cur_state is SA, and b is high, state changes to SAB
// If cur_state is SB, and a is high, state changes to SAB
// If cur_state is SAB, state changes to IDLE
// z is assigned one when cur_state is SAB
// FSM defines next state as follows:
// IDLE: if both a and b are 0, IDLE
// SA : if only a is 1, SA
// SB: if only b is 1, SB
// SAB: if a is 1 and b is 1, SAB
reg a_fail, b_fail, ab_fail, bx_fail;
//initialization of failure registers
reg a_err, b_err, ab_err, bx_err;
//probe to see if an input is high
// When an input is asserted as 1, z is assigned a one
// This is done into the FSM for each input and each module
// that is instantiated
reg z;
always @(posedge clk)
begin
//each FSM state begins
cur_state <= next_state;
end
always @(A, B, cur_state)

================================================================
